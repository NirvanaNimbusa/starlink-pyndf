\documentclass[twoside,11pt]{starlink}

% -----------------------------------------------------------------------------
\stardoccategory    {Starlink System Note}
\stardocinitials    {SSN}
\stardocsource      {sun\stardocnumber}
\stardoccopyright
{Copyright \copyright\ 2001 Council for the Central Laboratory of the Research
 Councils \newline\
Copyright \copyright\ 2008 Science and Technology Facilities Council}
\stardocnumber      {4.14}
\stardocauthors   {P.C.T. Rees \\
                   A.J. Chipperfield \\
                   P.W. Draper}
\stardocdate       {31 Jul 2008}
\stardoctitle      {EMS \linebreak Error Message Service}
\stardocversion     {Version 2.2-0}
\stardocmanual      {Programmer's Manual}
\stardocabstract  {This document describes the Error Message
Service, EMS, and its use in system software.
The purpose of EMS is to provide facilities for constructing and storing
error messages for future delivery to the user -- usually via the Starlink
Error Reporting System, ERR (see
\xref{SUN/104}{sun104}{err_error_reporting_system}).
EMS can be regarded as a simplified version of ERR without the binding to
any software environment (\textit{e.g.}\ for message output or access to the
parameter and data systems).
The routines in this library conform to the error reporting conventions
described in SUN/104.
A knowledge of these conventions, and of the ADAM system
(see \xref{SG/4}{sg4}{}), is assumed in what follows.

This document is intended for Starlink systems programmers and can safely be
ignored by applications programmers and users.}

% -----------------------------------------------------------------------------

% ? Document specific \providecommand or \newenvironment commands.
\providecommand{\listline}{\hspace{1pt}\\}
\setlength{\unitlength}{1mm}

% -----------------------------------------------------------------------------

\begin{document}
\scfrontmatter

%  Introduction page

\section{\xlabel{introduction}Introduction}

The Error Message Service is an implementation of the error reporting
conventions discussed in
\xref{SUN/104}{sun104}{err_error_reporting_system}
which is not dependent on any particular software environment and can
therefore be used in `stand-alone' programs and for implementing components of
software environments.
In order to allow its use in environment system software, EMS provides
no callable facility for delivering these messages to the user.
It just provides facilities for constructing and storing reported error
messages.
In doing so, it also provides many of the facilities required by
\xref{MSG and ERR}{sun104}{}. Indeed, in many cases the MSG and ERR routines
are implemented as straight-through calls to EMS routines.

EMS can also be used in the threaded parts of applications and libraries
when compiled with POSIX threads support, see Appendix \ref{threading}.

The hierarchical relationship between MSG, ERR and EMS is illustrated in
\textit{Figure~\ref{fig_hier}}.

\begin{figure}[h]
% \begin {footnotesize}
\begin{center}
\begin{tabular}{|cccc|} \hline
& & & \\
\hspace{8em} & \hspace{8em} & \hspace{8em} & \hspace{8em} \\
\multicolumn{2}{|c}{\fbox{\textbf{Message Reporting System}}}
   & \multicolumn{2}{c|}{\fbox{\textbf{Error Reporting System}}} \\
& \multicolumn{2}{|c|}{} & \\ \cline{2-3}
\multicolumn{2}{|c|}{} & \multicolumn{2}{c|}{} \\
& \multicolumn{2}{c}{\fbox{\textbf{Error Message Service}}} & \\
& & & \\
\hline
\end{tabular}
\end{center}
% \end {footnotesize}
\caption{\label{fig_hier}The relationship between MSG, ERR and EMS}
\end{figure}

EMS was originally written in Fortran and a C interface provided but since
Version 2.0 it is written in C and a Fortran interface provided. This document
concentrates on the Fortran interface. The C interface is described briefly --
the way it is used can be inferred from the use of the Fortran interface.

\section{\xlabel{when_to_use_the_error_message_service}When to Use the Error
Message Service}
At the level of applications code the Error Reporting System, ERR, exclusively
should be used for error reporting.
Within environment subroutine libraries the rule is to use calls to EMS unless
it is necessary to deliver error messages to the user (\textit{i.e.}\ by
calls to
\xref{\texttt{ERR\_FLUSH}}{sun104}{ERR_FLUSH}).
A subroutine library \emph{must}\/ use one or other of these error reporting
libraries exclusively: \textit{i.e.}\ if EMS calls are used within a
subroutine library, they must be used exclusively throughout the library --
no calls to ERR routines are allowed.
Furthermore, if ERR calls are used to report errors within a subroutine
library, say because calls to \texttt{ERR\_FLUSH} are required during
interaction with
the user, then it must be understood that this subroutine library exists at a
hierarchical level above the environment system software.
This subroutine library cannot then be called from other libraries purporting
to exist at lower levels within the subroutine hierarchy --
to do so could result in unpredictable behaviour when an error occurs.

An exception to the above is when working with a threaded application. For
these EMS should be used in the threaded portions and in general any error
reporting via ERR should be deferred until the threaded sections complete.
This avoids problems with global variable access in the ERR and ADAM
libraries. See Appendix \ref{threading}.

\section{\xlabel{reporting_errors}Reporting Errors}
The subroutine used to report errors is \texttt{EMS\_REP}.
It has a calling sequence analogous to that of
\xref{\texttt{ERR\_REP}}{sun104}{ERR_REP}, \textit{i.e.}
\begin{terminalv}
CALL EMS_REP( PARAM, TEXT, STATUS )
\end{terminalv}
The argument \texttt{PARAM} is the error message name, \texttt{TEXT}
is the error message text
and \texttt{STATUS} is the inherited status.
The \texttt{TEXT} and \texttt{STATUS}  arguments are the same as those used in
calls to \texttt{ERR\_REP} and are discussed fully in
\xref{SUN/104}{sun104}{reporting_errors}.

On exit from \texttt{EMS\_REP} the status argument remains unchanged, with
two exceptions:
\begin {itemize}
\item If \texttt{STATUS} set to SAI\_\_OK on entry,
\texttt{STATUS} is returned set to EMS\_\_BADOK.
\item If an output error occurs, \texttt{STATUS} is returned set to EMS\_\_OPTER.
\end {itemize}
Appendix \ref{incl_sect} lists the symbolic constants for all the possible
EMS errors.

The deferral of error reporting can be controlled within EMS:
\texttt{EMS\_MARK} and \texttt{EMS\_RLSE} respectively mark and release error
reporting contexts;
\texttt{EMS\_ANNUL} annuls all error reports pending output in a given error
context;
\texttt{EMS\_BEGIN} and \texttt{EMS\_END} respectively begin and end error
reporting environments.
The behaviour of these subroutines is analogous to \texttt{ERR\_MARK},
\texttt{ERR\_RLSE}, \texttt{ERR\_ANNUL}, \texttt{ERR\_BEGIN} and
\texttt{ERR\_END} provided by the Error Reporting System (see
\xref{SUN/104}{sun104}{deferred_error_reporting}).
EMS does not provide an analogue to
\xref{\texttt{ERR\_FLUSH}}{sun104}{ERR_FLUSH}.

\section{\xlabel{message_tokens}Message Tokens}
The facility to use message tokens to embed the values of program variables
within the message text is available in EMS.
As in MSG and ERR, these message tokens are  indicated by prefixing the token
name with an up-arrow, ``\wedge'', escape character within message text,
\textit{e.g.}
\begin{terminalv}
CALL EMS_REP( 'EMS_ROUTN_TOKEN', 'Error text: ^TOKEN', STATUS )
\end{terminalv}
Message tokens can be set to the most concise character encoding of a given
variable's value with the routines \texttt{EMS\_SET\textit{x}}, \textit{e.g.}
\begin{terminalv}
CALL EMS_SETC( 'TOKEN', 'A token' )
\end{terminalv}
For the \texttt{EMS\_SET\textit{x}} routines, \texttt{\textit{x}} corresponds
to one of five standard Fortran 77 data types:
\begin {center}
\begin {tabular}{||c|c||}
\hline
\textit{\textit{x}} & \textit{Fortran Type}\\
\hline
D & DOUBLE PRECISION\\
R & REAL\\
I & INTEGER\\
L & LOGICAL\\
C & CHARACTER\\
\hline
\end {tabular}
\end {center}
These routines are analogous to the subroutines \texttt{MSG\_SET\textit{x}}
provided by the Message Reporting System (see
\xref{SUN/104}{sun104}{message_tokens}).
As for the MSG routines, if the token has already been set, the new string
will be appended to the existing one.
All defined message tokens are annulled by a call to \texttt{EMS\_ANNUL},
\texttt{EMS\_ELOAD},
\texttt{EMS\_EXPND}, \texttt{EMS\_REP} or
\texttt{EMS\_MLOAD}\footnote{\texttt{EMS\_MLOAD} is now deprecated,
\texttt{EMS\_EXPND} should be used instead}.
They may be renewed to their previous defined values by a call to
\texttt{EMS\_RENEW} provided that no new tokens have been defined in the
meantime.

\section{\xlabel{reporting_status_fortran_io_and_operating_system_errors}Reporting
Status, Fortran I/O and Operating System Errors}\label{Stat_sect}
Three subroutines are provided by the Error Message Service to enable a message
token to be built from the error flag value returned from standard Starlink
library routines, system routines or Fortran I/O operations. (\emph{For C
programmers, \texttt{emsErrno} is also provided, see Section \ref{C_lang}.})
It is important that the correct routine is called, otherwise the wrong
message or, at best, only an error number will be obtained.

It should be noted that the messages returned using these subroutines
will depend upon the operating system in use.
The error messages returned by operating systems vary considerably in their
clarity and so should not be relied upon as the sole source of information
in error reports.

The subroutines are:
\begin{terminalv}
EMS_FACER( TOKEN, STATUS )
\end{terminalv}
where \texttt{STATUS} is a standard Starlink facility status value,
\begin{terminalv}
EMS_FIOER( TOKEN, IOSTAT )
\end{terminalv}
where \texttt{IOSTAT} is a Fortran I/O status code, and
\begin{terminalv}
EMS_SYSER( TOKEN, SYSTAT )
\end{terminalv}
where \texttt{SYSTAT} is a status value returned from a system routine.

In each case the message associated with the given error code is assigned to
the specified message token.
On completion, each of these subroutines returns its second argument
unchanged.

\section{\xlabel{message_output}Message Output}
\subsection{\xlabel{no_ems_flush}No EMS\_FLUSH}
At the risk of belabouring the point, the Error Message Service provides no
callable facility for delivering messages to the user, \textit{i.e.}\ there is
no analogue to
\xref{\texttt{ERR\_FLUSH}}{sun104}{ERR_FLUSH}
provided by EMS for the programmer.
This is a direct result of the binding of ERR to the particular
software environment being used.
In the Error Message Service no such binding can be used reliably.
EMS is only able to stack and annul error messages and to
control error deferral using the same error table as the ERR subroutine
library.
Responsibility for the delivery of error messages to the user therefore rests
at a higher level, ultimately with the application programmer.

Message delivery will usually be achieved by calling \texttt{ERR\_FLUSH} at a
higher level, or by
\htmlref{`Message Interception'}{intercepting_messages}\latex{ (see
Section~\ref{intercepting_messages})} but EMS has another feature which can be
helpful in `stand-alone' programs, \textit{i.e.} without an environment
present.

\subsection{\xlabel{ems_without_an_environment}EMS without an environment}
Outside any environment EMS has to have some reliable mechanism for ultimately
delivering any reported error messages to the user, since it cannot be
guaranteed that the ERR library is being used at the level of the application.
This is achieved by the having the initial error context level of EMS deliver
any reported error message immediately to the user using a C \texttt{printf}
statement: \textit{i.e.}\ if all an application does is call \texttt{EMS\_REP},
then all error messages are immediately delivered to the user when they are
reported.
Any higher error context level, set with a call to \texttt{EMS\_MARK} or
\texttt{EMS\_BEGIN},
will have the effect of deferring message output until the error reporting
context is returned to its initial level with calls to \texttt{EMS\_RLSE}
or \texttt{EMS\_END}.
Any deferred error messages will then be delivered to the user and any further
error messages reported in this context will again be delivered immediately to
the user.

The behaviour of EMS without an environment present means that it is essential
for error reporting contexts to be properly nested within a package and for a
subroutine library using EMS not to exit at a context level other than the
one at which it was invoked.
If context levels are incorrectly nested within a package it can lead to
EMS failing to deliver reported error messages when an application goes wrong.
Because the nested use of \texttt{EMS\_MARK} and \texttt{EMS\_RLSE}
(or \texttt{EMS\_BEGIN} and
\texttt{EMS\_END}) is normally confined within the same routine, incorrect
nesting of context levels will normally result from simple programming errors
which can be easily traced.
However, there is no simple safeguard against the incorrect nesting of error
context levels provided by EMS: thorough testing is the most effective
approach.
\begin{quote}
\emph{N.B. On some systems, C and Fortran output cannot be reliably
interspersed. This fallback output at the  EMS initial context level should
therefore not be used in programs which also use Fortran \texttt{WRITE}
statements.}
\end{quote}

\subsection{\xlabel{ems_within_an_environment}EMS within an environment}
When using EMS from within an environment, the environment should ensure that
the delivery of any reported error messages within the environment is deferred
and that any undelivered messages are output to the user when the application
has finished.
There are three routines (actually part of the ERR library), exclusively for
the use of environment implementors, which facilitate this task -- they are
discussed in Appendix \ref{ADAM_sect}.

\section{\xlabel{intercepting_messages}\label{intercepting_messages}Intercepting Messages}
Although there is no callable provision for message output directly from
EMS, the  output of messages at this level in the ADAM subroutine hierarchy is
still possible.
It can be done by intercepting any pending error messages within the current
error context (or informational messages) using subroutines \texttt{EMS\_ELOAD}
or
\texttt{EMS\_EXPND}, which return the message in a character variable, and then
using a private package-related mechanism to output the message.
Here, the mechanism used to output the message, \textit{e.g.}\ to a log file,
and its resilience to failure must be the responsibility of the subroutine
library calling EMS.
The use of private package equivalents to
\xref{\texttt{MSG\_OUT}}{sun104}{MSG_OUT}
or
\xref{\texttt{ERR\_FLUSH}}{sun104}{ERR_FLUSH}
must be fully justified and the justification presented in the documentation
for the subroutine library concerned.

\texttt{EMS\_ELOAD} returns error message pending in the current error context,
one by one in a series of calls; it has the calling sequence:
\begin{terminalv}
CALL EMS_ELOAD( PARAM, PARLEN, OPSTR, OPLEN, STATUS )
\end{terminalv}
On the first call of this routine, the error table for the current
context is copied into a holding area, the current error context
is annulled and the first message in the holding area is returned.
Thereafter, each time the routine is called, the next message from
the holding area is returned.
The argument \texttt{PARAM} is the returned message name and \texttt{PARLEN}
the length of the message name in \texttt{PARAM}.
\texttt{OPSTR} is the returned error message text and \texttt{OPLEN} is the
length of the error message in \texttt{OPSTR}.

The status associated with the returned message is returned in \texttt{STATUS}
until there are no more messages to return -- then \texttt{STATUS} is set to
SAI\_\_OK, \texttt{PARAM} and \texttt{OPSTR} are set to blanks and
\texttt{PARLEN} and \texttt{OPLEN} to 1.
If there are no messages pending on the first call, a warning message
is returned with \texttt{STATUS} set to EMS\_\_NOMSG.

After \texttt{STATUS} has been returned SAI\_\_OK, the whole process is
repeated for subsequent calls.
This process is the same as for
\xref{\texttt{ERR\_LOAD}}{sun104}{ERR_LOAD}\latex{ (see SUN/104)}
which just calls \texttt{EMS\_ELOAD}.

\texttt{EMS\_EXPND} has the calling sequence:
\begin{terminalv}
CALL EMS_EXPND( TEXT, OPSTR, OPLEN, STATUS )
\end{terminalv}
\texttt{TEXT} is the message text, \texttt{OPSTR} is the returned message text,
\texttt{OPLEN} is the length of the message in \texttt{OPSTR} and
\texttt{STATUS} is the inherited status.

The behaviour of \texttt{EMS\_EXPND} is to expand any message tokens in the
message text and return the expanded message through the character variable
\texttt{OPSTR}.

For both \texttt{EMS\_EXPND} and \texttt{EMS\_ELOAD}, if the message text is
longer than the declared length of OPSTR then the message is truncated with an
ellipsis, \textit{i.e.}\ ``\ldots'', but no error results.

The symbolic constants EMS\_\_SZPAR and EMS\_\_SZMSG are provided for declaring
the lengths of character variables which are to receive message names and
error messages in this way.
These constants are defined in the include file
\htmlref{\texttt{EMS\_PAR}}{incl_sect}\latex{ (see
Appendix~\ref{incl_sect})}.

\section{\xlabel{c_language_interface}C Language Interface}
\label{C_lang}
To enable EMS to be used in C-only programs, without the need to link with
Fortran libraries, it has now been implemented entirely
in C. A C function equivalent exists for each of the Fortran EMS routines
described in this document except \texttt{EMS\_FIOER} which is specific to the
Fortran language and has therefore been omitted.

The current naming scheme for the C functions (\texttt{emsAnnul}
\textit{etc.}) replaces the earlier one (\texttt{ems\_annul\_c} \textit{etc.}),
but the old names will still be recognised.
There is no change to the argument lists.
(See Appendix \ref{C_sect} for more details.)

Additional functions are available for C programmers:
\begin{itemize}

\item \texttt{emsErrno( char const *token, int errval )}
This will assign the message associated
with a C errno (\texttt{errval}) to the specified token. Note that this is
logically different from \texttt{emsSyser}; on UNIX they produce the same
result but on other systems they may be different.

\item \texttt{int emsGtune( char const *key, int *status )}
This returns the value of a tuning parameter. If differs from the Fortran
version as the value is returned, not passed back by reference.

\item \texttt{emsSetnc( char const *token, char const *string, int maxchar )}
This is similar to \texttt{emsSetc} but will limit the token length to
\texttt{maxchar} characters.
It must be used if \texttt{string} is not null-terminated.
\texttt{ems.h} defines \texttt{ems\_setc\_c} to be equivalent to
\texttt{emsSetnc} - there is no Fortran interface for this function.

\item \texttt{int emsStune( char const *key, int value, int *status )}
This replaces the \texttt{emsTune} function. It returns the old value of
the given parameter so that it can be re-established using another call
to this function (this may be necessary for systems that do not share
tuning values).


\end{itemize}
A full list of the C function prototypes is provided in Appendix~\ref{C_sect}.

The function \texttt{emsExpnd} has the argument \texttt{maxlen}, not found in
its equivalent Fortran call sequence.
This argument represents the maximum allowable string length for the expanded
message and is necessary for the use of returned C character strings where the
declared length cannot be determined.
Normally, the argument \texttt{maxlen} is given the global constant value
EMS\_\_SZMSG. There should be space for \texttt{maxlen}+1 characters in the
output string.

The correspondence between ANSI Fortran 77 data types and ANSI C data types
is not defined: \textit{i.e.\ it is implementation dependent}.
However, the most likely correspondence can be assumed and this has been coded
into the C/Fortran interface.
This correspondence is apparent from the C interface function prologues
provided in Appendix \ref{C_sect} and is summarised in the following table:

\begin {center}
\begin {tabular}{||c|c||}
\hline
\textit{C Type} & \textit{Fortran Type}\\
\hline
double & DOUBLE PRECISION\\
float & REAL\\
int & INTEGER\\
int & LOGICAL\\
char & CHARACTER\\
\hline
\end {tabular}
\end {center}

Note that the interpretation of the \texttt{int lvalue} argument presented to
the function \texttt{emsSetl} is that defined by the ANSI C language.

\section{\xlabel{compiling_and_linking_with_the_error_message_service}Compiling
and Linking with the Error Message Service}\label{comp_sect}

There are three Fortran include files available for use with the Error Message
Service: \texttt{SAE\_PAR}, \texttt{EMS\_PAR} and \texttt{EMS\_ERR}
(see Appendix \ref{incl_sect} for details of the symbolic constants which they
define).
The Starlink convention is that the name in upper case with no path or
extension is specified when including these files within Fortran code,
\textit{e.g.}:
\begin{terminalv}
*  Global Constants:
      INCLUDE 'SAE_PAR'
      INCLUDE 'EMS_PAR'
\end{terminalv}
Equivalent header files are installed in \texttt{/star/include} for use in C
code which is calling EMS -- they are named \texttt{sae\_par.h},
\texttt{ems\_par.h} and \texttt{ems\_err.h}.
In addition, \texttt{ems.h} contains the function prototypes for each of the C
functions.
The syntax
\begin{terminalv}
#include "sae_par.h"
#include "ems.h"
\end{terminalv}
should be used within the C code, and the compiler option
\texttt{-I/star/include} used when compiling C and Fortran code.

The Error Message Service is included automatically when
programs are linked using the ADAM application linking commands,
\texttt{alink} \textit{etc}.

To link a non-ADAM Fortran program with the the Error Message Service, the
command line would be something like:
\begin{terminalv}
% f77 -I$STARLINK_DIR/include program.f -L$STARLINK_DIR/lib `ems_link` \
      -o program.out
\end{terminalv}

The command to compile and link a C program might be:
\begin{terminalv}
% cc -o program -I$STARLINK_DIR/include -L$STARLINK_DIR/lib program.c \
     `ems_link`
\end{terminalv}

\begin {quote}
\emph{Note that the commands used to invoke the C and Fortran compilers vary
from one UNIX implementation to another (indeed, there may be more than
compiler of each type on the same machine).}
\end {quote}

If the C program makes no use of the EMS Fortran interface, the
\texttt{`ems\_link`} command may be changed to \texttt{`ems\_link Conly`}.
This will avoid the linker looking for the Starlink
\xref{CNF}{sun209}{}
library, which may not be present at a non-Starlink site.

\section{\xlabel{references}References}
\emph{Note}: Only the first author is listed here.

\begin{latexonly}
\begin {tabular}{lll}
Lawden, M.D. & \xref{SG/4}{sg4}{}
--- ADAM -- The Starlink Software Environment.\\
Rees, P.C.T. & \xref{SUN/104}{sun104}{}
--- MSG and ERR -- Message and Error Reporting Systems.\\
Chipperfield, A.J. & \xref{SUN/185}{sun185}{}
--- MESSGEN -- Starlink Facility Error Message Generation.
\end {tabular}
\end{latexonly}




\newpage
\appendix

\section{Justification for EMS}
The hierarchical structure of an application within a software environment
is illustrated in
\textit{Figure~\ref{fig_appov}}.

\begin{figure}[h]
\begin{footnotesize}
\begin{center}
\begin{picture}(160,59)(0,0)
\put(65.5,45){\framebox(29,7){\textbf{APPLICATION}}}
\put(2,21){\framebox(34.5,7){\textbf{Parameter System}}}
\put(38.5,21){\framebox(24.5,7){\textbf{Data System}}}
\put(65,21){\framebox(17.5,7){\textbf{File I/O}}}
\put(84.5,21){\framebox(30.5,7){\textbf{Magnetic Tapes}}}
\put(117,21){\framebox(18.5,7){\textbf{Graphics}}}
\put(137.5,21){\framebox(20.5,7){\textbf{Data Base}}}
\put(0,14){\framebox(160,24){}}
\put(2,34){\textbf{Environment Subroutine Libraries}}
\put(59,0){\framebox(42,7){\textbf{OPERATING SYSTEM}}}
\put(80,45){\line(0,-1){7}}
\put(80,14){\line(0,-1){7}}
\end{picture}
\end{center}
\end{footnotesize}
\caption{\label{fig_appov}Overview of an application}
\end{figure}

It can be seen from \textit{Figure \ref{fig_appov}} that between an application
and the
operating system any environment is realised as a number of subroutine
libraries, providing a set of documented facilities for the applications
programmer to use.
Between the user and an application, the environment will normally also
provide a user interface which controls the loading of specific applications,
the I/O to the user and the parameter system.

The exclusion of any user-callable message delivery mechanism from the Error
Message Service allows EMS to be used for error reporting within software
environment system routines without the danger of recursion on error.
Conversely, the Error and Message Reporting Systems,
\xref{ERR and MSG}{sun104}{}\latex{ (see SUN/104)},
have bindings to specific software environments and thus the ability to
deliver error and informational messages to the user via the user interface
of that environment.
The binding of ERR and MSG to a given software environment precludes their use
for error reporting from within the environment system software because the
error reporting would rely to some (probably unpredictable) extent upon the
working state of that environment.
Thus, ERR and MSG act as interfaces for a given environment with EMS, to be
used only within applications software.

As an example, the
\xref{ADAM}{sg4}{}
versions of ERR and MSG are able to obtain the message text associated with a
given message parameter from the ADAM interface file and are also able to
include ADAM parameter keywords and references (\textit{i.e.}\ file names,
\xref{HDS}{sun92}{}
object names or device names) in the message text.
These features are useful when reporting error and informational messages
from ADAM applications software.
However, in order to provide these facilities, MSG and ERR make calls to the
ADAM parameter system, data system and user interface and so depend
upon the working state of these parts of the ADAM environment.
These features preclude the use of MSG and ERR in the development of any
subroutine library used by the parameter system, data system or user interface.

\newpage
\section{\xlabel{threading}Using EMS together with POSIX threads
\label{threading}}
When built using the \texttt{--with-pthreads} configuration option, which is
the default on platforms supporting POSIX threads, EMS can be used in a
threaded application or library. The only requirement is that the sections of
the application that use threads are wrapped in
\texttt{emsMark}/\texttt{emsRlse} blocks, as in:
\begin{terminalv}

void *make_report( void *threadid )
{
    int tid;
    int status = SAI__ERROR;

    tid = (int) threadid;
    emsSeti( "THREADID", tid );
    emsRep( "THREAD", "Oh no an error in thread ^THREADID", &status );
    return NULL;
}

int main ( int argc, char *argv[] )
{
    pthread_t threads[ NUM_THREADS ];
    int rc;
    int t;
    int status = SAI__OK;

    emsMark();

    for ( t = 0; t < NUM_THREADS; t++ ) {
        pthread_create( &threads[ t ], NULL, make_report, (void *)t );
    }

    /*  Wait for threads to complete. */
    for ( t = 0; t < NUM_THREADS; t++ ) {
        pthread_join( threads[ t ], NULL );
    }

    /* Check for the exit status */
    emsStat( &status );

    emsRlse();
}

\end{terminalv}

The error messages can then be delivered or loaded as normal (when using ERR
it is important not to make any calls to it in the threaded section, as this
may access unprotected global data). The status return recovered by
\texttt{emsStat} will be one from one of the threads, it is not possible to
find out the status from all threads using EMS. In a standalone program as
shown the error messages:
\begin{terminalv}
!! Oh no an error in thread 1
!  Oh no an error in thread 2
!  Oh no an error in thread 3
!  Oh no an error in thread 4
\end{terminalv}
will be shown using the default delivery \texttt{printf} mechanism during the
\texttt{emsRlse} call (since the error stack context falls to the base level).

\newpage
\section{\xlabel{using_ems_within_adam_system_software}Using EMS within ADAM
system software} \label{ADAM_sect}
\subsection{\xlabel{ems_in_adam_overview}Overview}
This document has so far discussed the use of EMS in a general context.
In this section, specific differences between EMS and the ADAM versions of
the Message and Error Reporting Systems, MSG and ERR, are presented.

\subsection{\xlabel{message_parameters}Message parameters}
In calls to the ADAM version of \texttt{ERR\_REP}, the error message name
\texttt{PARAM} is a
globally unique identifier for the error message text which corresponds to
the message parameter of the error message.
The ADAM interface file can be used to associate this message parameter with
an error message, and only if this message parameter is not defined in the
interface file is the argument \texttt{TEXT} used in the error report.
When using \texttt{EMS\_REP} (or the deprecated \texttt{EMS\_MLOAD}) within the
ADAM environment software, no access to the ADAM interface file exists and so
the error message given by the argument \texttt{TEXT} is always used.
The use of a globally unique error message name is still recommended for
reported error messages to uniquely identify the error message text to the
programmer, using the convention outlined in
\xref{SUN/104}{sun104}{reporting_errors}.

\subsection{\xlabel{parameter_references}Parameter references}
The ADAM versions of MSG and ERR allow reference to ADAM program
parameters within the message text.
Reference can be made either to parameter-keyword associations or to the name
of an ADAM data system object, data file or device associated with a parameter.
In message text used in calls to MSG and ERR routines these parameter
associations are indicated by the percent, ``\%'', and dollar, ``\$'', escape
characters respectively.
EMS does not have access to the ADAM parameter system and so cannot refer
to ADAM parameters in the text of  messages.
The escape characters ``\%'' and ``\$'' are therefore treated literally as
part of the message text in calls to \texttt{EMS\_REP} and \texttt{EMS\_EXPND}
(or the deprecated \texttt{EMS\_MLOAD}), as they are in the stand-alone
versions of MSG and ERR.

\subsection{\xlabel{reserved_tokens}Reserved tokens}
In the ADAM versions of MSG and ERR a reserved token, `STATUS', can be
used to insert the message associated with a status value.
In EMS, as in the stand-alone versions of MSG and ERR, there are no reserved
message tokens

\subsection{\xlabel{synchronising_message_output}Synchronising message output}
Because there is no callable mechanism provided by EMS to deliver messages to
the user, no message synchronising mechanism is provided by EMS.

\subsection{\xlabel{routines_specific_to_the_adam_fixed_part}Routines specific
to the ADAM fixed part}
There are three ERR routines which start up, clear and stop the Error Reporting
System within the ADAM fixed part to ensure that the delivery of any
reported error messages is deferred and that any messages pending output are
delivered to the user when the application has finished.
These subroutines are \texttt{ERR\_START}, \texttt{ERR\_CLEAR} and
\texttt{ERR\_STOP} -- they are
discussed in this document because they are purely for system programming and
will affect the use of EMS as well as ERR within ADAM.

\texttt{ERR\_START} has the effect of marking a new EMS context and thus
deferring the delivery of any reported error messages to the user.
The new context is known as the default context.

\texttt{ERR\_CLEAR} has the effect of returning the current error context to
the `default' level set by \texttt{ERR\_START} and flushing any reported error
messages to the user.
Thus, the effect of any mismatched `mark' and `release' calls within an
application is annulled.

\texttt{ERR\_STOP} clears the error message table by calling
\texttt{ERR\_CLEAR} and then returns
the error reporting context to the initial context level, \textit{i.e.}\ the
level prior to the call to \texttt{ERR\_START}.

\begin {quote}
\emph{The use of these three routines is entirely reserved for starting up,
clearing and
stopping error reporting within the environment, \textit{e.g.}\ the ADAM fixed
part, and must not be used for any other purpose.}
\end {quote}

These routines exist only in the ADAM version of the ERR library and are linked
using the procedure given in
\xref{SUN/104}{sun104}{compiling_and_linking_with_msg_and_err}.

\begin {small}
\sstroutine{
   ERR\_CLEAR
}{
   Return the error table to the default context and flush its
   contents
}{
   \sstdescription{
      The Error Reporting System is returned to its default context
      level and any pending messages are flushed. This routine
      effectively resets the Error Reporting System:

      \sstitemlist{

         \sstitem
            unlike \texttt{ERR\_FLUSH}, no `faulty application' error message
            is reported if it is called when there are no error messages
            pending output, or if it is called with the status value set
            to SAI\_\_OK;

         \sstitem
            the error table is always annulled by a call to
            \texttt{ERR\_CLEAR}, irrespective of any message output errors
            which may occur.

      }
      On exit, the status is always returned as SAI\_\_OK.
   }
   \sstinvocation{
      CALL ERR\_CLEAR( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Implementation Notes
   }{
      This subroutine is for use only with the ADAM implementation of
      the Error Reporting System.
   }
}
\sstroutine{
   ERR\_START
}{
   Initialise the Error Reporting System
}{
   \sstdescription{
      Initialise the Error Reporting System and set a new context level
      (the default level) to defer error message delivery.
   }
   \sstinvocation{
      CALL ERR\_START
   }
   \sstdiytopic{
      Implementation Notes
   }{
      This subroutine is for use only with the ADAM implementation of
      the Error Reporting System.
   }
}
\sstroutine{
   ERR\_STOP
}{
   Close the Error Reporting System
}{
   \sstdescription{
      Flush any messages pending output and return the Error Reporting
      System to its initial state.
   }
   \sstinvocation{
      CALL ERR\_STOP( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Implementation Notes
   }{
      This subroutine is for use only with the ADAM implementation of
      the Error Reporting System.
   }
}
\end {small}
\rule{\textwidth}{0.5mm}

\newpage
\section{\xlabel{portability}Portability}

\subsection{\xlabel{porting_prerequisites}Porting prerequisites}
The Fortran interface to EMS makes use of the Starlink mixed language
programming package,
\xref{CNF}{sun209}{}\latex{ (see SUN/209)},
which must be available for building EMS and programs which use its Fortran
interface.

The correct operation of \texttt{EMS\_FACER} (and \texttt{emsFacer}) also
requires the necessary facility message files to be installed (see
\htmlref{`Operating system specific routines' below}{operating_system_specific_routines}).

\subsection{\xlabel{operating_system_specific_routines}
\label{operating_system_specific_routines}Operating system
specific routines}
\label{deps}
EMS is coded in ANSI C, according to the Starlink C coding conventions
described in SGP/4.
However, the following routines have system-specific features and may need
re-implementing for new platforms.
They may also produce differing results on different platforms.
\begin {description}
\item [\htmlref{\texttt{EMS\_FACER}}{EMS_FACER}]  Assign the message
associated with a Starlink status value to a \textit{token.}

On UNIX this is implemented using the \xref{MESSGEN}{sun185}{} system
\latex{(see SUN/185)}
and thus relies on the required Starlink facility message files
having been entered into the system.

When \texttt{EMS\_FACER} is called to to obtain the message associated with a
given \texttt{STATUS} value, it first works out the facility number from the
\texttt{STATUS} value.
It then searches for a file with the name
\texttt{fac\_}\textit{facnum}\texttt{\_err} (where \textit{facnum} is the
facility number).
If environment variable \texttt{EMS\_PATH} is defined, it is taken to be a
directory search path for the file;
if not, a directory search path of \texttt{../help} relative to each of the
directories on the user's \texttt{PATH} is used.

If the file cannot be found along the selected search path, or
a message cannot be associated for any other reason, a `FACERR' message is
substituted giving as much information as possible.
For example:
\begin{quote}
\textit{ident}\texttt{, error 147358667 (fac=200,messid=121)}
\end{quote}
where the given status value is 147358667 and 200 and 121 are the facility
number and message number derived from it.

\textit{ident} may be one of the following:
\begin{description}
\item[\texttt{FACERR\_\_BADARG}] --
the given status value was not a valid Starlink status value.
\item[\texttt{FACERR\_\_NOFAC}] --
the required facility message file was not found.
\item[\texttt{FACERR\_\_BADFIL}] --
the facility message file was faulty.
\item[\texttt{FACERR\_\_NOMSG}] --
the required message number was not found in the facility message file.
\end{description}
\item [\htmlref{\texttt{EMS\_FIOER}}{EMS_FIOER}]
Assign a Fortran I/O error message to a token.

This will generally need to be rewritten for each new target platform.
Current versions have the appropriate messages hardwired into the code.
\item [\htmlref{\texttt{EMS\_SYSER}}{EMS_SYSER}]  Assign an operating system
error message to a token.

This may need to be rewritten for a new target platform. At the
moment UNIX platforms use the same code which accesses \texttt{sys\_errlist}.
\item [\texttt{emsErrno}] Assign the message associated with a C errno to a
token.

On UNIX platforms this accesses \texttt{sys\_errlist} to obtain the message.
\end{description}

\section{\xlabel{include_files}Include Files}
\label{incl_sect}
The symbolic constants defined by the three include files used with EMS are
listed below. The way in which these files are included within Fortran or
C code is described in Section \ref{comp_sect}.
\begin {description}
\item \texttt{SAE\_PAR} (\texttt{sae\_par.h}) Defines the non-specific status
codes for Starlink.
\begin{description}
\item \texttt{SAI\_\_ERROR} -- Error encountered.
\item \texttt{SAI\_\_OK} -- No error.
\item \texttt{SAI\_\_WARN} -- Warning.
\end {description}

\item \texttt{EMS\_PAR} (\texttt{ems\_par.h}) Defines the Error Message Service
constants.
\begin{description}
\item \texttt{EMS\_\_BASE} -- The base context number.
\item \texttt{EMS\_\_MXMSG} -- Maximum number of messages.
\item \texttt{EMS\_\_MXOUT} -- Maximum length of output text.
\item \texttt{EMS\_\_SZMSG} -- Maximum length of error message text.
\item \texttt{EMS\_\_SZPAR} -- Maximum length of error message name.
\item \texttt{EMS\_\_SZTOK} -- Maximum length of message token text.
\item \texttt{EMS\_\_TOKEC} -- Message token escape character.
\end{description}

\item \texttt{EMS\_ERR} (\texttt{ems\_err.h}) Defines the Error Message Service
error codes.
\begin{description}
\item \texttt{EMS\_\_BADOK} -- Status set to SAI\_\_OK in call to
\texttt{EMS\_REP}
(improper use of \texttt{EMS\-\_REP}).
\item \texttt{EMS\_\_BDKEY} -- Invalid keyword will be ignored (improper use
of \texttt{EMS\_TUNE} or EMS\_GTUNE).
\item \texttt{EMS\_\_BTUNE} -- Conflicting actions (improper use of
\texttt{EMS\_TUNE}).
\item \texttt{EMS\_\_CXOVF} -- Error context stack overflow (EMS fault).
\item \texttt{EMS\_\_EROVF} -- Error message stack overflow (EMS fault).
\item \texttt{EMS\_\_NOENV} -- Error encountered reading environment variable
\texttt{EMS\_TUNE}.
\item \texttt{EMS\_\_NOMSG} -- No error messages pending output.
\item \texttt{EMS\_\_NSTER} -- Error in nested calls to \texttt{EMS\_BEGIN}
and \texttt{EMS\_END}
(improper use of EMS).
\item \texttt{EMS\_\_OPTER} -- Error encountered during message output.
\item \texttt{EMS\_\_UNSET} -- No status associated with message (improper
use of \texttt{EMS\_REP}).
\end{description}
\end {description}
Notes:
\begin{enumerate}
\item EMS\_\_BADOK is the status returned if \texttt{EMS\_REP} is called with
status SAI\_\_OK whereas EMS\_\_UNSET is the status associated with any
messages reported in this way and may therefore be returned by, for example,
\texttt{EMS\_STAT}.
\item EMS\_\_NOENV is provided for future developments -- it is not used at
the moment.
\end{enumerate}

\newpage
\section{\xlabel{fortran_subroutine_list}Fortran Subroutine List}
\begin {description}
\item [\htmlref{EMS\_ANNUL}{EMS_ANNUL}  ( STATUS )] \listline
\textit{Annul the contents of the current error context.}
\item [\htmlref{EMS\_BEGIN}{EMS_BEGIN}  ( STATUS )] \listline
\textit{Begin a new error reporting environment.}
\item [\htmlref{EMS\_ELOAD}{EMS_ELOAD}
( PARAM, PARLEN, OPSTR, OPLEN, STATUS )] \listline
\textit{Return messages from the current error context.}
\item [\htmlref{EMS\_END}{EMS_END}  ( STATUS )] \listline
\textit{End the current error reporting environment.}
\item [\htmlref{EMS\_EXPND}{EMS_EXPND}
( TEXT, OPSTR, OPLEN, STATUS )] \listline
\textit{Expand and return a message.}
\item [\htmlref{EMS\_FACER}{EMS_FACER}  ( TOKEN, STATUS )] \listline
\textit{Assign the message associated with a Starlink status to a token.}
\item [\htmlref{EMS\_FIOER}{EMS_FIOER}  ( TOKEN, IOSTAT )] \listline
\textit{Assign the message associated with a Fortran I/O error to a token.}
\item [\htmlref{EMS\_GTUNE}{EMS_GTUNE} ( KEY, VALUE, STATUS )] \listline
\textit{Inquire an EMS tuning parameter.}
\item [\htmlref{EMS\_LEVEL}{EMS_LEVEL}  ( LEVEL )] \listline
\textit{Inquire the current error context level.}
\item [\htmlref{EMS\_MARK}{EMS_MARK}] \listline
\textit{Start a new error context.}
\item [\htmlref{EMS\_MLOAD}{EMS_MLOAD}
( PARAM, TEXT, OPSTR, OPLEN, STATUS )] \listline
\textit{(Deprecated) Expand and return a message. }
\item [\htmlref{EMS\_RENEW}{EMS_RENEW}] \listline
\textit{Renew any annulled message tokens in the current context.}
\item [\htmlref{EMS\_REP}{EMS_REP} ( PARAM, TEXT, STATUS )] \listline
\textit{Report an error message.}
\item [\htmlref{EMS\_RLSE}{EMS_RLSE}] \listline
\textit{Release (i.e.\ end) the current error context.}
\item [\htmlref{EMS\_SETx}{EMS_SETx}  ( TOKEN, VALUE )] \listline
\textit{Concise encoding of a given value. }
\item [\htmlref{EMS\_STAT}{EMS_STAT}  ( STATUS )] \listline
\textit{Inquire the last reported error status.}
\item [\htmlref{EMS\_SYSER}{EMS_SYSER}  ( TOKEN, SYSTAT )] \listline
\textit{Assign the message associated with an operating system error
to a token.}
\item [\htmlref{EMS\_TUNE}{EMS_TUNE} ( KEY, VALUE, STATUS )] \listline
\textit{Set an EMS tuning parameter.}
\end {description}

\newpage
\section{\xlabel{c_interface_function_prototypes}C Interface Function
Prototypes} \label{C_sect}
\begin {description}

\item[void emsAnnul ( int \texttt{*}status );] \listline
\textit{Annul the contents of the current error context.}

\item[void emsBegin ( int \texttt{*}status );] \listline
\textit{Begin a new error reporting environment.}

\item[void emsEload
( char \texttt{*}parstr, int \texttt{*}parlen, char \texttt{*}opstr,
int \texttt{*}oplen, int \texttt{*}status );] \listline
\textit{Return messages from the current error context.}

\item[void emsEnd ( int \texttt{*}status );] \listline
\textit{End the current error reporting environment.}

\item[void emsErrno ( const char \texttt{*}token, int errval );] \listline
\textit{Assign the message associated with a C errno to a token.}

\item[void emsExpnd] \listline
\textbf{( const char \texttt{*}text, char \texttt{*}opstr,
const int maxlen, int \texttt{*}oplen, int \texttt{*}status );} \\
\textit{Expand and return a message.}

\item[void emsFacer ( const char \texttt{*}token, int facerr );] \listline
\textit{Assign the messages associated with a Starlink status value to a
token.}

\item[int emsGtune ( const char \texttt{*}key, int \texttt{*}status );]
\listline
\textit{Get the value of a tuning parameter}

\item[void emsLevel ( int \texttt{*}level );] \listline
\textit{Inquire the current error context level.}

\item[void emsMark ( void );] \listline
\textit{Start a new error context.}

\item[void emsMload] \listline
\textbf{( const char \texttt{*}param, const char \texttt{*}text,
char \texttt{*}opstr, int \texttt{*}oplen, int~\texttt{*}status );} \\
\textit{(Deprecated) Expand and return a message.}

\item[void emsRenew ( void );] \listline
\textit{Renew any annulled message tokens in the current context.}

\item[void emsRep ( const char \texttt{*}param, const char \texttt{*}text,
int \texttt{*}status );] \listline
\textit{Report an error message.}

\item[void emsRlse ( void );] \listline
\textit{Release (i.e.\ end) the current error context.}

\item[void emsSetc ( const char \texttt{*}token,
const char \texttt{*}cvalue, ... );] \listline
\textit{Concise encoding of a given null-terminated string. String
\texttt{cvalue} must be null-terminated. (For historical
reasons, additional arguments are permitted but have no effect.)}

\item[void emsSetnc ( const char \texttt{*}token, const char \texttt{*}cvalue,
int maxchar );] \listline
\textit{Concise encoding of a given CHARACTER value - maximum \texttt{maxchar}
characters.}

\item[void emsSetd ( const char \texttt{*}token, double dvalue );] \listline
\textit{Concise encoding of a given DOUBLE PRECISION value.}

\item[void emsSeti ( const char \texttt{*}token, int ivalue );] \listline
\textit{Concise encoding of a given INTEGER value.}

\item[void emsSetl ( const char \texttt{*}token, int lvalue );] \listline
\textit{Concise encoding of a given LOGICAL value.}

\item[void emsSetr ( const char \texttt{*}token, float fvalue );] \listline
\textit{Concise encoding of a given REAL value.}

\item[void emsStat ( int \texttt{*}status );] \listline
\textit{Inquire the last reported error status.}

\item[int emsStune ( const char \texttt{*}key, int value,
int \texttt{*}status );] \listline
\textit{Set an EMS tuning parameter, returning previous value.}

\item[void emsSyser ( const char \texttt{*}token, int systat );] \listline
\textit{Assign an operating system error message to a token.}

\item[void emsTune ( const char \texttt{*}key, int value,
int \texttt{*}status );] \listline
\textit{(Deprecated use emsStune) Set an EMS tuning parameter.}

\end {description}

\newpage
\section{\xlabel{fortran_subroutine_specifications}Fortran Subroutine
Specifications}
\label{routines}
\begin {small}
\sstroutine{
   EMS\_ANNUL
}{
   Annul the contents of the current error context
}{
   \sstdescription{
      Any pending error messages for the current error context are annulled,
      i.e. deleted. The values of any existing message tokens become
      undefined and the value of the status argument is reset to SAI\_\_OK.
   }
   \sstinvocation{
      CALL EMS\_ANNUL( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status: set to SAI\_\_OK on return.
      }
   }
}
\sstroutine{
   EMS\_BEGIN
}{
   Begin a new error reporting environment
}{
   \sstdescription{
      Begin a new error reporting environment by marking a new error
      reporting context and then resetting the status argument to SAI\_\_OK.
      If \texttt{EMS\_BEGIN} is called with the status argument set to an error
      value, a check is made to determine if there are any messages
      pending output in the current context: if there are none, then an
      error report to this effect will be made on behalf of the calling
      application.
   }
   \sstinvocation{
      CALL EMS\_BEGIN( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status: set to SAI\_\_OK on return.
      }
   }
}
\sstroutine{
   EMS\_ELOAD
}{
   Return error messages from the current error context
}{
   \sstdescription{
      On the first call of this routine, the error table for the current
      error context is copied into a holding area, the current context
      is annulled and the first message in the holding area is returned.
      Thereafter, each time the routine is called, the next message from
      the holding area is returned.
      The argument \texttt{PARAM} is the returned message name and
      \texttt{PARLEN} the length of the message name.
      \texttt{OPSTR} is the returned error message text and \texttt{OPLEN}
      is the length of the error message in \texttt{OPSTR}.
      If the message text is longer than the declared length of \texttt{OPSTR},
      then the message is truncated with an ellipsis, \textit{i.e.}\
      ``\ldots'', but no error results.

      The status associated with the returned message is returned in
      \texttt{STATUS} until there are no more messages to return -- then
      \texttt{STATUS} is set to SAI\_\_OK, \texttt{PARAM} and \texttt{OPSTR}
      are set to blanks and \texttt{PARLEN} and \texttt{OPLEN} to 1.
      If there are no messages pending on the first call, a warning message
      is generated and returned with \texttt{STATUS} set to EMS\_\_NOMSG

      After STATUS has been returned SAI\_\_OK, the whole process is repeated
      for subsequent calls.
   }
   \sstinvocation{
      CALL EMS\_ELOAD( PARAM, PARLEN, OPSTR, OPLEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The error message name.
      }
      \sstsubsection{
         PARLEN = INTEGER (Returned)
      }{
         The length of the error message name.
      }
      \sstsubsection{
         OPSTR = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The error message -- or blank if there are no more messages.
      }
      \sstsubsection{
         OPLEN = INTEGER (Returned)
      }{
         The length of the error message.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The status associated with the returned error message:
         it is set to SAI\_\_OK when there are no more messages.
      }
   }
}
\sstroutine{
   EMS\_END
}{
   End the current error reporting environment
}{
   \sstdescription{
      Check if any error messages are pending output in the previous
      error reporting context. If so, then annul and release the current
      context; if not, then just release the current context. Return
      the last reported status value.
   }
   \sstinvocation{
      CALL EMS\_END( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   EMS\_EXPND
}{
   Expand and return a message
}{
   \sstdescription{
      Any tokens in the supplied message are expanded and the result is
      returned in the character variable supplied. If the status argument
      is not set to SAI\_\_OK on entry, no action is taken except that the
      values of any existing message tokens are always left undefined
      after a call to \texttt{EMS\_EXPND}.
      If the expanded message is longer than
      the length of the supplied character variable, the message is
      terminated with an ellipsis.
   }
   \sstinvocation{
      CALL EMS\_EXPND( MSG, OPSTR, OPLEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         MSG = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The raw message text.
      }
      \sstsubsection{
         OPSTR = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The expanded message text.
      }
      \sstsubsection{
         OPLEN = INTEGER (Returned)
      }{
         The length of the expanded message.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
}
\sstroutine{
   EMS\_FACER
}{
   Assign the message associated with a Starlink status value to a token
}{
   \sstdescription{
      The text of the error message associated with the Starlink status
      value, \texttt{STATUS}, is assigned to the named message token. This
      token may then be included in an error message. If the token is
      already defined, the error message is appended to the existing token
      value.
   }
   \sstinvocation{
      CALL EMS\_FACER( TOKEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TOKEN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The message token name.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The Starlink status value.
      }
   }
   \sstdiytopic{
      System-specific
   }{
      The messages generated using this facility may vary slightly between
      systems.
      For more information, see Appendix \ref{deps}.
   }
}
\sstroutine{
   EMS\_FIOER
}{
   Assign a Fortran I/O error message to a token
}{
   \sstdescription{
      The text of the error message associated with the Fortran I/O status
      value, \texttt{IOSTAT}, is assigned to the named message token.
      This token may then be included in an error message. If the token is
      already defined, the error message is appended to the existing token
      value.
   }
   \sstinvocation{
      CALL EMS\_FIOER( TOKEN, IOSTAT )
   }
   \sstarguments{
      \sstsubsection{
         TOKEN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The message token name.
      }
      \sstsubsection{
         IOSTAT = INTEGER (Given)
      }{
         The Fortran I/O status value.
      }
   }
   \sstdiytopic{
      System-specific
   }{
      The messages generated using this facility will depend upon the
      computer system in use.
   }
}

\sstroutine{
   EMS\_GTUNE
}{
   Inquire an EMS tuning parameter
}{
   \sstdescription{
      Return the value of an EMS tuning parameter. The possible tuning
      parameters are those defined in \texttt{EMS\_TUNE}.

      The routine will attempt to execute regardless of the given value of
      \texttt{STATUS}. If the given value is not SAI\_\_OK, then it is left
      unchanged, even if the routine fails to complete. If \texttt{STATUS} is
      SAI\_\_OK on entry and the routine fails to complete, \texttt{STATUS}
      will be set and an error report made.

   }
   \sstinvocation{
      CALL EMS\_TUNE( KEY, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         KEY = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The tuning parameter keyword
      }
      \sstsubsection{
         VALUE = INTEGER (Returned)
      }{
         The current value of the tuning parameter.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}


\sstroutine{
   EMS\_LEVEL
}{
   Inquire the current error context level
}{
   \sstdescription{
      Return the number of context markers set in the error message
      table. Any returned value greater than one indicates that the
      delivery of reported error messages is deferred.
   }
   \sstinvocation{
      CALL EMS\_LEVEL( LEVEL )
   }
   \sstarguments{
      \sstsubsection{
         LEVEL = INTEGER (Returned)
      }{
         The error context level.
      }
   }
}
\sstroutine{
   EMS\_MARK
}{
   Start a new error context
}{
   \sstdescription{
      Begin a new error reporting context so that delivery of
      subsequently reported error messages is deferred and the messages
      held in the error table. Calls to \texttt{EMS\_ANNUL} or
      \texttt{ EMS\_ELOAD} will only annul or return the contents of the error
      table within this new context.
   }
   \sstinvocation{
      CALL EMS\_MARK
   }
}
\sstroutine{
   EMS\_MLOAD
}{
   (Deprecated) Expand and return a message
}{
   \sstdescription{
      Any tokens in the supplied message are expanded and the result is
      returned in the character variable supplied. If the status argument
      is not set to SAI\_\_OK on entry, no action is taken except that the
      values of any existing message tokens are always left undefined
      after a call to \texttt{EMS\_MLOAD}. If the expanded message is longer
      than the declared length of the supplied character variable, the message
      is terminated with an ellipsis.
   }
   \sstinvocation{
      CALL EMS\_MLOAD( PARAM, MSG, OPSTR, OPLEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The message name.
      }
      \sstsubsection{
         MSG = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The raw message text.
      }
      \sstsubsection{
         OPSTR = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The expanded message text.
      }
      \sstsubsection{
         OPLEN = INTEGER (Returned)
      }{
         The length of the expanded message.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine is now deprecated as the \texttt{PARAM} argument is
      redundant and the C interface gives no limit for the expanded string
      size. \texttt{EMS\_EXPND} should be used instead.
   }
}
\sstroutine{
   EMS\_RENEW
}{
   Renew any annulled message tokens in the current context
}{
   \sstdescription{
      Any message tokens which have been annulled by a call to
      \texttt{EMS\_REP}, \texttt{EMS\_EXPND}, \texttt{EMS\_\-MLOAD},
      \texttt{EMS\_ANNUL} or \texttt{EMS\_ELOAD}
      in the current context are renewed.
      If any new token value has been defined since the previous
      tokens were annulled (\textit{e.g.}\ using the \texttt{EMS\_SETx}
      routines), no action is taken. The intended use of \texttt{EMS\_RENEW}
      is to renew all existing message tokens immediately after a message has
      been issued so that they can be re-used in a subsequent message.
   }
   \sstinvocation{
      CALL EMS\_RENEW
   }
}
\sstroutine{
   EMS\_REP
}{
   Report an error message
}{
   \sstdescription{
      Report an error message. According to the error context, the
      error message is either sent to the user or retained in the
      error table. The latter case allows the application to take
      further action before deciding if the user should receive the
      message. The values associated with any existing message tokens
      are left undefined. On successful completion, the global status
      is returned unchanged; if the status argument is set to SAI\_\_OK
      on entry, an error report to this effect is made on behalf of
      the application and the status argument is returned set to
      EMS\_\_BADOK; if an output error occurs, the status argument is
      returned set to EMS\_\_OPTER.
   }
   \sstinvocation{
      CALL EMS\_REP( PARAM, TEXT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The error message name.
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The error message text.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status: this is left unchanged on successful
         completion, and is returned set to an EMS\_\_ error if an
         internal error occurs.
      }
   }
}
\sstroutine{
   EMS\_RLSE
}{
   Release (end) an error context
}{
   \sstdescription{
      Release a ``mark'' in the error message table, returning
      the Error Message Service to the previous error context. Note that
      any error messages pending output will be passed to this previous
      context, \emph{not}\/ annulled. When the context level reaches the base
      level, all pending messages will be delivered to the user.
   }
   \sstinvocation{
      CALL EMS\_RLSE
   }
}
\sstroutine{
   EMS\_SETx
}{
   Assign a value to a message token (concise)
}{
   \sstdescription{
      A given value is encoded using a concise format and the result
      assigned to the named message token. If the token is already
      defined, the result is appended to the existing token value.
      The given value may be one of the following Fortran 77 data types
      and there is one routine provided for each data type:

      \begin {center}
      \begin {tabular}{||c|c||}
      \hline
      \textit{x} & \textit{Fortran Type}\\
      \hline
      D & DOUBLE PRECISION\\
      R & REAL\\
      I & INTEGER\\
      L & LOGICAL\\
      C & CHARACTER\\
      \hline
      \end {tabular}
      \end {center}

      If these subroutines fail, it will usually be apparent in any
      messages which refer to this token.
   }
   \sstinvocation{
      CALL EMS\_SETx( TOKEN, VALUE )
   }
   \sstarguments{
      \sstsubsection{
         TOKEN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The message token name.
      }
      \sstsubsection{
         VALUE = Fortran 77 Type (Given)
      }{
         The value to be assigned to the message token.
      }
   }
   \sstdiytopic{
      System-specific
   }{
      The precise effect of failures will depend upon the computer system
      being used.
   }
}
\sstroutine{
   EMS\_STAT
}{
   Inquire the last reported error status
}{
   \sstdescription{
      The current error context is checked for any error messages reported
      since the context was created or last annulled.
      If none exist, \texttt{STATUS} is returned set to SAI\_\_OK.
      If there are any such messages, \texttt{STATUS} is returned set to the
      status value associated with the last reported error message.
   }
   \sstinvocation{
      CALL EMS\_STAT( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The last reported error status within the current error context.
      }
   }
}
\sstroutine{
   EMS\_SYSER
}{
   Assign an operating system error message to a token
}{
   \sstdescription{
      The text of the error message associated with the operating system
      status value, \texttt{SYSTAT}, is assigned to the named message token.
      This token may then be included in an error message. If the token is
      already defined, the error message is appended to the existing token
      value.
   }
   \sstinvocation{
      CALL EMS\_SYSER( TOKEN, SYSTAT )
   }
   \sstarguments{
      \sstsubsection{
         TOKEN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The message token name.
      }
      \sstsubsection{
         SYSTAT = INTEGER (Given)
      }{
         The operating system status value.
      }
   }
   \sstdiytopic{
      System-specific
   }{
      The messages generated using this facility will depend upon the
      computer system in use.
   }
}
\sstroutine{
   EMS\_TUNE
}{
   Set an EMS tuning parameter
}{
   \sstdescription{
      The value of the EMS tuning parameter is set appropriately, according
      to the value given. \texttt{EMS\_TUNE} may be called multiple times for
      the same parameter. The following keywords and values are permitted:
      \begin{description}
       \item['SZOUT'] Specifies a maximum line length to be used in the line
             wrapping process. By default the message to be output is split
             into chunks of no more than the maximum line length, and each
             chunk is written on a new line. The split is made at word
             boundaries if possible.
             The default maximum line length is 79 characters.

            If \texttt{VALUE} is set to 0, no wrapping will occur. If it is
            set greater than 6, it specifies the maximum output line length.
            Note that the minimum VALUE is 7, to allow for exclamation marks
            and indentation.
       \item['MSGDEF'] Specifies the default error reporting level. That is a
            level below which \texttt{EMS\_RLSE} will not go. It can therefore
            be used by environments such as ADAM to prevent any output by EMS
            due to unmatched marks and releases. This keyword should not be
            used in other cases.

       \item['STREAM'] Specifies whether or not ERR should treat its output
            unintelligently as a stream of characters.
            If \texttt{VALUE} is set to 0 (the default) all non-printing
            characters are replaced by blanks, and line wrapping occurs
            (subject to \texttt{SZOUT}).
            If \texttt{VALUE} is set to 1, no cleaning or line wrapping occurs.

       \item['REVEAL'] Allows the user to display all error messages cancelled
            when \texttt{EMS\_ANNUL} is called. This is a diagnostic tool which
            enables the programmer to see all error reports, even those
            'handled' by the program. If \texttt{VALUE} is set to 0 (the
            default) annulling occurs in the normal way. If \texttt{VALUE} is
            set to 1, the message will be displayed.
       \end{description}
      The routine will attempt to execute regardless of the given value of
      \texttt{STATUS}. If the given value is not SAI\_\_OK, then it is left
      unchanged, even if the routine fails to complete. If \texttt{STATUS} is
      SAI\_\_OK on entry and the routine fails to complete, \texttt{STATUS}
      will be set and an error report made.

   }
   \sstinvocation{
      CALL EMS\_TUNE( KEY, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         KEY = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The tuning parameter keyword
      }
      \sstsubsection{
         VALUE = INTEGER (Given)
      }{
         The value to be assigned (see Description)
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{\begin{enumerate}
      \item SZOUT applies to the case where EMS does its own output -
      \textit{i.e.} when messages are reported or impending when EMS is at
      its base level.
      Normally output will be from the ERR package and is tuned by
      \texttt{ERR\_TUNE}.
      \item Some aspects of output for both ERR and MSG are controlled by EMS
      and its tuning parameters therefore \texttt{ERR\_TUNE} and
      \texttt{MSG\_TUNE} call this
      subroutine to set the EMS tuning parameters appropriately. This may
      result in interference.
      \item The use of SZOUT and STREAM may be affected by the message delivery
      system in use. For example there may be a limit on the the size of a
      line output by a Fortran WRITE and automatic line wrapping may occur.
      In particular, a NULL character will terminate a message delivered by
      the ADAM message system.
      \end{enumerate}
   }
}
\end {small}

\end {document}
