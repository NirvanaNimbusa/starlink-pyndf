#include "sae_par.h"
#include "dat_par.h"
#include "prm_par.h"
#include "ndf1.h"

void CGEN_FUNCTION( ndf1Qma )( int el, const unsigned char qual[],
                             unsigned char badbit, int narray,
                             CGEN_TYPE array1[], CGEN_TYPE array2[],
                             CGEN_TYPE array3[], CGEN_TYPE array4[],
                             int *bad, int *status ){
/*
*+
*  Name:
*     ndf1Qma<T>

*  Purpose:
*     Perform quality masking on vectorised generic arrays.

*  Synopsis:
*     void ndf1Qma<T>( int el, const unsigned char qual[],
*                      unsigned char badbit, int narray, CGEN_TYPE
*                      array1[], CGEN_TYPE array2[], CGEN_TYPE array3[],
*                      CGEN_TYPE array4[], int *bad, int *status )

*  Description:
*     This function converts a vectorised quality array "qual" into a set
*     of "bad pixel" flags which are inserted into a matching set of up to
*     4 vectorised generic arrays.  This is done by performing a bit-wise
*     "AND" operation between elements of the "qual" array and the bitmask
*     "badbit". Where the result of this operation is non-zero, the
*     corresponding elements of "array1"..."array4" are set to the "bad"
*     value VAL__BAD<T> (the precise number of arrays processed is
*     determined by the "narray" parameter).  Other array elements are
*     unchanged.  A logical value "bad" is also returned indicating whether
*     any "bad" pixels were actually generated by this quality masking
*     process.

*  Parameters:
*     el
*        The number of elements to process in each vectorised array.
*     qual
*        The quality array. The supplied "qual" array should have at least
*        "el" elements.
*     badbit
*        The bad-bits mask to be applied to the quality array.
*     narray
*        Number of vectorised arrays to be processed in the range 1 to 4.
*        The function returns without action if this value is out of range.
*     array1
*        The 1st vectorised generic array to be processed. Up to four of
*        these will be processed, according to the value of the "narray"
*        parameter.  Any remaining arrays are not used.
*     array2
*        The 2nd vectorised generic array to be processed. Up to four of
*        these will be processed, according to the value of the "narray"
*        parameter.  Any remaining arrays are not used.
*     array3
*        The 3rd vectorised generic array to be processed. Up to four of
*        these will be processed, according to the value of the "narray"
*        parameter.  Any remaining arrays are not used.
*     array4
*        The 4th vectorised generic array to be processed. Up to four of
*        these will be processed, according to the value of the "narray"
*        parameter.  Any remaining arrays are not used.
*     *bad
*        Returned holding the whether any bad pixels were generated as a
*        result of the quality masking process.
*     *status
*        The global status.

*  Notes:
*     -  This function loops through the arrays in a backward direction.
*     This is to minimise paging on a virtual memory machine, since this
*     function will usually be followed by a processing loop which passes
*     forward through the same arrays.

*  Authors:
*     RFWS: R.F. Warren-Smith (STARLINK)
*     DSB: David S. Berry (EAO)

*  History:
*     3-APR-2019 (DSB):
*        Original version, based on equivalent Fortran function by RFWS.
*     3-MAY-2019 (DSB):
*        Change element index from int to hdsdim.

*-
*/

/* Local Variables: */
   hdsdim i;                /* Loop counter for array elements */

/* Check inherited global status. */
   if( *status != SAI__OK ) return;

/* Initialise. */
   *bad = 0;

/* There is nothing to do unless the mask is non-zero. */
   if( badbit != 0 ) {

/* 1 array to process:
   ==================
   Loop to process each array element. */
      if( narray == 1 ) {
         for( i = el - 1; i >= 0; i-- ){

/* Evaluate the quality masking function. */
            if( !NDF_QMASK( qual[ i ], badbit ) ) {

/* Set affected array elements to the bad value and note this has
   happened. */
               array1[ i ] = CGEN_BAD;
               *bad = 1;
            }
         }

/* 2 arrays to process:
   ===================
   Loop to process each array element. */
      } else if( narray == 2 ) {
         for( i = el - 1; i >= 0; i-- ){

/* Evaluate the quality masking function. */
            if( !NDF_QMASK( qual[ i ], badbit ) ) {

/* Set affected array elements to the bad value and note this has
   happened. */
               array1[ i ] = CGEN_BAD;
               array2[ i ] = CGEN_BAD;
               *bad = 1;
            }
         }

/* 3 arrays to process:
   ===================
   Loop to process each array element. */
      } else if( narray == 3 ) {
         for( i = el - 1; i >= 0; i-- ){

/* Evaluate the quality masking function. */
            if( !NDF_QMASK( qual[ i ], badbit ) ) {

/* Set affected array elements to the bad value and note this has
   happened. */
               array1[ i ] = CGEN_BAD;
               array2[ i ] = CGEN_BAD;
               array3[ i ] = CGEN_BAD;
               *bad = 1;
            }
         }

/* 4 arrays to process:
   ===================
   Loop to process each array element. */
      } else if( narray == 4 ) {
         for( i = el - 1; i >= 0; i-- ){

/* Evaluate the quality masking function. */
            if( !NDF_QMASK( qual[ i ], badbit ) ) {

/* Set affected array elements to the bad value and note this has
   happened. */
               array1[ i ] = CGEN_BAD;
               array2[ i ] = CGEN_BAD;
               array3[ i ] = CGEN_BAD;
               array4[ i ] = CGEN_BAD;
               *bad = 1;
            }
         }
      }
   }

/* Call error tracing function and exit. */
   if( *status != SAI__OK ) ndf1Trace( "ndf1Qma<T>", status );

}

