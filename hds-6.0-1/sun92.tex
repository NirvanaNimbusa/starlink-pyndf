\documentclass[twoside,11pt]{starlink}

% ? Specify used packages
% ? End of specify used packages

% -----------------------------------------------------------------------------
% ? Document identification
% Fixed part
\stardoccategory    {Starlink User Note}
\stardocinitials    {SUN}
\stardocsource      {sun\stardocnumber}
\stardoccopyright
{Copyright \copyright\ 2018 East Asian Observatory}

% Variable part - replace [xxx] as appropriate.
\stardocnumber      {92.14}
\stardocauthors   {R.F.~Warren-Smith\\ M.D.~Lawden\\
                                B.K.~McIlwrath \\ T.~Jenness\\ P.W.~Draper\\
                                D.S.~Berry}
\stardocdate        {6th February 2018}
\stardoctitle       {HDS\\ [\latex{1ex}]
                                Hierarchical Data System}
\stardocversion     {Version 6.0}
\stardocmanual      {Programmer's Manual}
\stardocabstract  {
HDS is a library of functions used for accessing file-based hierarchical
data and supports the storage of a wide variety of information. It is
particularly suited to the storage of large multi-dimensional arrays (with
their ancillary data) where efficient access is needed.

Historically the HDS library used a unique format for disk-file storage
developed by the UK Starlink project in the 1980's. However it now
supports both this historical Starlink format and also the popular HDF5 format.

HDS organises data into \htmlref{hierarchies}{fig:hierarchy}, broadly
similar to the directory structure of a hierarchical filing system,
but contained within a single HDS \st{container file.} The structures
stored in these files are self-describing and flexible; HDS supports
modification and extension of structures previously created, as well
as deletion, copying, renaming, \st{etc.}

All information stored in HDS files is portable between the machines
on which HDS is implemented. Thus, there are no format conversion
problems when moving between machines.

The \htmlref{routines}{appendix:alphalist} described in this document
may be used to perform operations on any HDS data. In addition, HDS
forms a toolkit for the construction of higher level (more
specialised) data structures and the software which accesses them.
HDS routines are therefore invoked indirectly by many other items of
Starlink software.
}
% ? End of document identification
% -----------------------------------------------------------------------------
% ? Document specific \providecommand or \newenvironment commands.
\providecommand{\hi}[1]{{\texttt{#1}}}
\providecommand{\qt}[1]{``#1''}
\providecommand{\st}[1]{{\emph{#1}}}
\providecommand{\astar}[0]{{$*$}}
\providecommand{\mplus}[0]{{$+$}}
\providecommand{\htmltext}[1]{}
% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\begin{document}
\scfrontmatter

\section {\xlabel{introduction}INTRODUCTION}

This document is intended for those people who intend to write
programs using HDS. It is tutorial in style and assumes no prior
knowledge of HDS, although some knowledge of a hierarchical filing
system will be helpful. Anyone who has used UNIX should understand the
analogies that are drawn between directories and HDS structures.

This note mainly deals with HDS as a \qt{stand-alone} software
package. Routines which interface HDS with a particular software
environment (\st{i.e.}\ the HDS/\xref{ADAM}{sg4}{} parameter system
routines) are not considered here.\footnote{See ADAM Programmer Note 7
for a description of these routines.}

Reference information is presented in the appendices.
Appendix~\ref{appendix:alphalist} gives a list of the calling
sequences for the HDS routines; this will be useful to experienced
programmers who just want to be reminded of the parameters required,
while Appendix~\ref{appendix:routines} gives full routine
specifications for all of HDS.  Appendix~\ref{appendix:errors}
describes the HDS error codes.
% Programming support for HDS, in the form of subroutine templates and
% on-line help, is also provided by the Starlink language sensitive
% editor STARLSE (SUN/105).

HDS stands for \qt{Hierarchical Data System}. It is a flexible system
for storing and retrieving data and takes over from a computer's
filing system at the level of an individual file (see
Fig~\ref{fig:hierarchy}). A conventional file effectively contains an
1-dimensional sequence of data elements, whereas an HDS file can
contain a more complex structure. There are many parallels between the
hierarchical way HDS stores data within files and the way that a
filing system organises the files themselves. These analogies will be
helpful in what follows.

\setlength{\unitlength}{1mm}
\begin{figure}
\label{fig:hierarchy}
\caption{The relationship between a computer's filing system and HDS.}
\begin{center}
\begin{picture}(150,90)
\setlength{\unitlength}{1mm}
\thicklines
\put (20,70){\framebox(30,5){Root directory}}
\put (0,55){\framebox(30,5){User directory}}
\put (40,55){\framebox(30,5){User directory}}
\put (40,45){\framebox(30,5){Subdirectory}}
\put (20,30){\framebox(30,5){File}}
\put (60,30){\framebox(30,5){File}}
\put (100,30){\framebox(30,5){Container File}}
\put (100,20){\framebox(30,5){HDS Object}}
\put (80,5){\framebox(30,5){Object}}
\put (120,5){\framebox(30,5){Object}}
\put (15,65){\vector(0,-1){5}}
\put (55,65){\vector(0,-1){5}}
\put (55,55){\vector(0,-1){5}}
\put (35,40){\vector(0,-1){5}}
\put (75,40){\vector(0,-1){5}}
\put (115,30){\vector(0,-1){5}}
\put (95,15){\vector(0,-1){5}}
\put (135,15){\vector(0,-1){5}}
\put (90,32.5){\vector(1,0){10}}
\put (100,32.5){\vector(-1,0){10}}
\put (35,70){\line(0,-1){5}}
\put (55,45){\line(0,-1){5}}
\put (115,20){\line(0,-1){5}}
\put (15,65){\line(1,0){40}}
\put (35,40){\line(1,0){40}}
\put (95,15){\line(1,0){40}}
\put (15,55){\line(0,-1){1}}
\put (15,53){\line(0,-1){1}}
\put (15,51){\line(0,-1){1}}
\put (23,80)\textbf{Filing System}
\put (110,80)\textbf{HDS}
\end{picture}
\end{center}
\end{figure}

The advantage of HDS is that it allows many different kinds of data to
be stored in a consistent and logical fashion. It is also very
flexible, in that objects can be added or deleted whilst retaining the
logical structure. HDS also provides portability of data, so that the
same data objects may be accessed from different types of computer
despite the fact that each may actually format its files and data in
different ways.

\section{\xlabel{HDF5}\label{sect:hdf5}DISK FORMATS AND HDF5}

Historically, the term ``HDS'' was used to refer both to a subroutine
library and also to an on-disk data format. Both were developed by the UK
Starlink project in the 1980's. Since then the subroutine library has
been used extensively - mainly within the Starlink
Software Collection but also outside. However the size of typical
astronomical data sets has increased enormously since the 1980's (as has
the typical astronomer's desktop computing power) and the original disk
format upon which the HDS library was based no longer looks like a good
match to current needs. Solving this problem by upgrading the original
disk format was deemed impractical as documentation on the internals of
the HDS disk format is sparse and the original developers are no
longer available. Instead, it was decided to move to the popular and well
supported HDF5 library and corresponding disk format - see
\htmladdnormallink{\texttt{{https://support.hdfgroup.org/HDF5/}}}{https://support.hdfgroup.org/HDF5/}

However, given the extensive use of the HDS library within the Starlink
Software Collection, simply changing all the HDS calls within starlink
application code to equivalent HDF5 calls would be prohibitive, both from
the point of view of the effort involved and also the likelihood of bugs
being introduced.

Instead it was decided to re-implement the routines within the HDS
library using calls to the routines provided by the HDF5 library, using
the HDF5 disk format in a way that mimics as closely as possible the
original HDS disk format. In this way no changes would be needed to
application code since all HDS routines would still be available and
would behave in the same way. In addition, data files created by the new
HDS library would be compatible with the wide range of publicly available
tools that already exist for examining HDF5 files.

For further information about the motivation behind this change and the
technicalities involved see ``Re-implementing the Hierarchical Data System
using HDF5'' (T. Jenness, Astronomy and Computing, Vol.12, 2015 -
\htmladdnormallink{\texttt{{https://arxiv.org/abs/1502.04029}}}{https://arxiv.org/abs/1502.04029}).

Note, this document has not yet been fully updated to refer to the new
library and disk format. If in doubt, send a query to the
\htmladdnormallink{Starlink support mailing list}{http://www.jiscmail.ac.uk/archives/starlink.html}
or consult the code (held in various repositories within the Starlink project
on github).

\subsection{\label{sect:version}Choosing the disk format version for new HDS files}

The new HDF5-based disk format is called ``HDS version 5'' (the previous
Starlink-specific disk format was version 4). Perhaps confusingly, the
HDS library and data format have always had independent version numbers.
So where-as the new HDF5-based \emph{data format} is ``HDS version 5'',
the new \emph{library} is ``HDS version 6.0''.

An obvious requirement was that version 6.0 of the HDS library should be
able to read and write both data formats (version 4 and version 5). This
is necessary for it to be possible to pass data files to and from sites
that still use version 5 of the HDS library (i.e. can only access files
that use the Starlink-specific HDS disk format). However, when creating a new
disk file, the HDS library (version 6) needs to known which disk format
(version 4 or version 5) to use. By default, the original disk format
(version 4) is used so that files created by version 6 of the HDS library
can be read by starlink systems that still use version 5. However, this
can be changed by setting the environment variable ``\texttt{HDS\_VERSION}''
to ``5'', or by using the HDS\_TUNE routine to set tuning parameter
``\texttt{VERSION}'' to 5.

All data files created by version 6 of the HDS library still have the
traditional extension - ``\texttt{.sdf}'' - (``Starlink Data File''),
regardless of the disk format in use.

\begin{center}
\emph{ Note, in a future release the default disk format will be changed from
version 4 to version 5.}
\end{center}

\section{\xlabel{HDS_objects}\label{sect:objects}OBJECTS}

HDS files are known as \st{container files} and by default have the
extension `.sdf'.  HDS files contain \st{data objects} which will
often be referred to simply as \st{objects}. An object is an entity
which contains data or other objects. This is the basis of the
hierarchical nature of HDS and is analogous to the concepts of
\st{file} and \st{directory} -- a directory can contain files and
directories which can themselves contain files and directories and so
on (see Fig~\ref{fig:hierarchy}).

An HDS object possesses a number of attributes, each of which is
described in more detail below:

\subsection{\label{sect:name}Name}

The primary way of identifying an HDS object is by its \st{name},
which must be unique within its own container object.  The name of an
object is a character string which may contain any printing
characters; white space is ignored and alphabetic characters are
capitalised. The maximum length of an HDS name is 15 characters.

There are no special rules governing the first character
(\st{i.e.}\ it can be numeric), so HDS itself allows great freedom in specifying
names (and also types -- see \htmlref{below}{sect:type}). In practice,
however, some restrictions will be imposed by considerations of
portability of data and applications, and of possible syntax conflicts
with the environment within which HDS is used.

\subsection{\label{sect:type}Type}

The \st{type} of an HDS object falls into two \st{classes}:

\begin{itemize}
\item Structure
\item Primitive
\end{itemize}

Structure objects contain other objects called
\st{components}. Primitive objects contain only numeric, character, or
logical values. Objects in the different classes are referred to as
\st{structures} and \st{primitives} while the more general term
\st{object} refers to either a \st{structure} or a
\st{primitive}. Structures are analogous to the directories in a
filing system -- they can contain a part of the hierarchy below
them. Primitives are analogous to files -- they are at the bottom of
any branch of the structure and contain the actual data.

In HDS, structure types are represented by character strings with the
same rules of formation as \htmlref{\st{name,}}{sect:name} except that
a structure type may not start with an underscore character `\_' (a
structure type may also be completely blank). Examples of structure
types are `IMAGE', `SPECTRUM', `INSTR\_RESP', \st{etc.} These do not
begin with an underscore, so they are easily distinguished from the
primitive types, which do.

Special rules apply to the primitive types, which all begin with an
underscore and are \qt{pre-defined} by HDS, as follows:

\begin{center}
\xlabel{table_of_HDS_data_types}
\begin{tabular}{|l|l|l|}
\hline
\st{HDS Type} & \st{Fortran Type} & \st{Description}\\
\hline \hline
\_INTEGER & INTEGER & Integer (signed)\\
\_INT64 & INTEGER{\astar}8 & 64-bit Integer (signed)\\
\_REAL & REAL & Single precision\\
\_DOUBLE & DOUBLE PRECISION & Double precision\\
\_LOGICAL & LOGICAL & Logical\\
\_CHAR[{\astar}n] & CHARACTER[{\astar}n] & Character string\\
\hline
\_WORD & INTEGER{\astar}2 & Word (signed)\\
\_UWORD & INTEGER{\astar}2 & Unsigned word\\
\_BYTE & BYTE & Byte (signed)\\
\_UBYTE & BYTE & Unsigned byte\\
\hline
\end{tabular}
\end{center}

The first five of these primitive types are referred to as
\st{standard data types}, since they correspond with standard
Fortran~77 data types. The last four are \st{non-standard data types}
and are typically required to accommodate raw data from instrumental
hardware, which may generate numbers in these formats.  The range of
values which may be stored in each primitive numeric type is
determined by the numerical capabilities of your machine and the
particular implementation of Fortran you are using. Details of HDS,
which include information about the properties of the primitive data
types on the system you are using, may be found in the file:

\begin{small}
\begin{terminalv}
hds_machine
\end{terminalv}
\end{small}


in the directory \texttt{\$STARLINK\_DIR/help}.

The rules by which character values are handled by HDS is the same as
for Fortran~77, \st{i.e.}\ character values are padded with blanks or
truncated from the right depending on the relative length of the
program value and the object.

\subsection{\label{sect:shape}Shape}

Every HDS object has a \st{shape} or dimensionality. This is
described by an integer (the number of dimensions) and an integer
array (containing the size of each dimension). A \st{scalar} (for
example a single number) has, by convention, a dimensionality of zero;
\st{i.e.}\ its number of dimensions is 0. A \st{vector} has a
dimensionality of 1; \st{i.e.}\ its number of dimensions is 1, and
the first element of the dimension array contains the size of the
vector.  An \st{array} refers to an object with 2 or more dimensions;
a maximum of 7 dimensions are allowed. Objects may be referred to as
\st{scalar primitives} or \st{vector structures} and so on.

\subsection{State}

The \st{state} of an HDS object specifies whether or not its value is
defined. It is represented as a logical value where .TRUE.\ means
defined and .FALSE.\ means undefined.

Objects start out undefined when they are created and become defined
when you write a value to them. In general, an error will result if
you attempt to obtain the value of an object while it is still
undefined.

\subsection{\label{sect:group}Group}

In order to access an HDS object it is first necessary to
\qt{associate} a \htmlref{\st{locator}}{sect:locators} with it (like
opening a file). This locator can then be used to address the
object. When the program no longer needs to access the object the
locator should be \htmlref{\qt{annulled}}{sect:annul} (like closing
the file again). A locator is roughly analogous to a Fortran logical
unit number (but is actually a character variable, not an
integer). The \st{group} attribute is used to form an association
between objects so that all their locators can be annulled together. A
group is written as a character string whose rules of formation are
the same as for \htmlref{\st{name}}{sect:name}.

\subsection{Value}

When a primitive object is first created it contains no value (rather
like opening a file) and it must be given a value in a separate
operation. A value can be a scalar, a vector or an array. The elements
of a vector or array must all be of the same \htmlref{type}{sect:type}.

\subsection{\label{sect:ndf}Illustration}

To fix \htmlref{these ideas}{sect:objects}, look at the example
below. Here we have described a structure of \htmlref{type}{sect:type}
`NDF' using the following notation to describe each object:

\begin{small}
\begin{terminalv}
NAME[(dimensions)] <TYPE> [value]
\end{terminalv}
\end{small}

Note that scalar objects have no dimensions and that each level down
the hierarchy is indented.

\begin{small}
\begin{terminalv}
DATASET <NDF>
   DATA_ARRAY(512,1024)    <_UBYTE>   0,0,0,1,2,3,255,3,...
   LABEL                   <_CHAR*80> 'This is the data label'
   AXIS(2) <AXIS>
      AXIS <AXIS>
         DATA_ARRAY(512)   <_REAL>    0.5,1.5,2.5,...
         LABEL             <_CHAR*30> 'Axis 1'
      AXIS <AXIS>
         DATA_ARRAY(1024)  <_REAL>    5,10,15.1,20.3,...
         LABEL             <_CHAR*10> 'Axis 2'
\end{terminalv}
\end{small}

This example exhibits several of the properties mentioned above:

\begin{itemize}
\item Both structures and primitives are present in the structure.
\item Scalar and non-scalar objects are present.
\item The AXIS component is a vector structure (with two elements).
\end{itemize}

\section{\xlabel{routines_and_constants}ROUTINES AND CONSTANTS}

\subsection{Routine Names}

HDS objects are created, accessed, modified and deleted in programs by
means of calls to HDS \htmlref{routines}{appendix:alphalist}. The
routine names have the following structure:

\begin{small}
\begin{terminalv}
<pkg>_<func><qual>
\end{terminalv}
\end{small}

where \verb+<pkg>+ is the \qt{package name}, \verb+<func>+ represents
the function performed by the routine and \verb+<qual>+ is a qualifier
which is used to identify different versions of the GET, MAP, MOD, NEW
and PUT routines.

\subsection{Symbolic Names and Include Files}

Stand-alone HDS programs will typically have the following structure:

\begin{small}
\begin{terminalv}
<declarations>

INCLUDE 'SAE_PAR'
INCLUDE 'DAT_PAR'
INCLUDE 'DAT_ERR'
INCLUDE 'CMP_ERR'

STATUS = SAI__OK

<executable statements>

END
\end{terminalv}
\end{small}

Various symbolic names should be used for important constant values in
HDS programs to make the programs clear, portable and to insulate them
from possible future changes. These symbolic names are defined by
several Fortran \qt{include} files.  This explains the existence of
the \hi{INCLUDE} statements in the example above. The following
include files are available:

\begin{description}

\item [SAE\_PAR:]
This file is not actually part of HDS, but it defines the global
symbolic constant SAI\_\_OK (the value of the status return indicating
success) and will be required by nearly all routines which call
HDS. It should normally be included as a matter of course.

\item [\xlabel{list_of_symbolic_constants}DAT\_PAR:]
Defines various symbolic constants for HDS. These should be used
whenever the associated value is required (typically this is when
program variables are defined):

\begin{center}
\begin{tabular}{ll}
DAT\_\_MXDIM & Maximum number of object dimensions\\
DAT\_\_NOLOC & Null (invalid) \htmlref{locator}{sect:locators} value\\
DAT\_\_NOWLD & Null wild-card search context\\
DAT\_\_SZGRP & Size of \htmlref{group}{sect:group} name\\
DAT\_\_SZLOC & Size of locator\\
DAT\_\_SZMOD & Size of access mode string\\
DAT\_\_SZNAM & Size of object \htmlref{name}{sect:name}\\
DAT\_\_SZTYP & Size of \htmlref{type}{sect:type} string
\end{tabular}
\end{center}

\item [DAT\_ERR:]
This defines symbolic names for the error status values returned by
the DAT\_ and HDS\_ routines.

\item [CMP\_ERR:]
This defines symbolic names for the additional error status values
returned by the \htmlref{CMP\_ routines}{appendix:cmproutines}.
\end{description}

If it is required to test for specific error conditions, the
appropriate include file should be used and the symbolic names (listed
in Appendix~\ref{appendix:errors}) used in the test. Here is an
example of how to use these symbols:

\begin{small}
\begin{terminalv}
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
      INCLUDE 'DAT_ERR'
      ...

      CHARACTER * ( DAT__SZLOC ) LOC1, LOC2
      CHARACTER * ( DAT__SZNAM ) NAME
      INTEGER STATUS
      ...

* Find a structure component.
      CALL DAT_FIND( LOC1, NAME, LOC2, STATUS )

* Check the status value returned.
      IF ( STATUS .EQ. SAI__OK ) THEN
         <normal action>
      ELSE IF ( STATUS .EQ. DAT__OBJNF ) THEN
         <take appropriate action for object not found>
      ELSE
         <action on other errors>
      END IF
\end{terminalv}
\end{small}

\section{\xlabel{creating_objects}\label{sect:creating}CREATING OBJECTS}

Here is an example showing how to create the NDF structure in
\S\ref{sect:ndf}.

\begin{small}
\begin{terminalv}
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
      CHARACTER * ( DAT__SZLOC ) NLOC, ALOC, CELL
      INTEGER DIMS( 2 ), STATUS
      DATA DIMS / 512, 1024 /

*  Create a container file with a top level scalar object of type NDF.
      CALL HDS_NEW( 'dataset', 'DATASET', 'NDF', 0, 0, NLOC, STATUS )

*  Create components in the top level object.
      CALL DAT_NEW( NLOC, 'DATA_ARRAY', '_UBYTE', 2, DIMS, STATUS )
      CALL DAT_NEWC( NLOC, 'LABEL', 80, 0, 0, STATUS )
      CALL DAT_NEW( NLOC, 'AXIS', 'AXIS', 1, 2, STATUS )

*  Create components in the AXIS structure...

*  Get a locator to the AXIS component.
      CALL DAT_FIND( NLOC, 'AXIS', ALOC, STATUS )

*  Get a locator to the array cell AXIS(1).
      CALL DAT_CELL( ALOC, 1, 1, CELL, STATUS )

*  Create internal components within AXIS(1) using the CELL locator.
      CALL DAT_NEW( CELL, 'DATA_ARRAY', '_REAL', 1, DIM( 1 ), STATUS )
      CALL DAT_NEWC( CELL, 'LABEL', 30, 0, 0, STATUS )

*  Annul the cell locator
      CALL DAT_ANNUL( CELL, STATUS )

*  Do the same for AXIS(2).
      CALL DAT_CELL( ALOC, 1, 2, CELL, STATUS )
      CALL DAT_NEW( CELL, 'DATA_ARRAY', '_REAL', 1, DIM( 2 ), STATUS )
      CALL DAT_NEWC( CELL, 'LABEL', 10, 0, 0, STATUS )
      CALL DAT_ANNUL( CELL, STATUS )

*  Access objects which have been created.
      ...

*  Tidy up
      CALL DAT_ANNUL( ALOC, STATUS )
      CALL DAT_ANNUL( NLOC, STATUS )

      END
\end{terminalv}
\end{small}

The following points should be borne in mind:

\begin{itemize}

\item The structure we have created is in no way static -- we can add
new objects or delete existing ones at any level without disturbing
what already exists.

\item No primitive values have been stored yet (\st{i.e.}\ the
structure does not yet contain any data) -- we will do that next.

\item All new container files are created using the disk format indicated
by the \htmlref{``VERSION'' tuning parameter}{sect:version}.

\end{itemize}

Here are some notes on particular aspects of this example:

\begin{description}

\item [DAT\_\_SZLOC:]
This is an INTEGER constant which is defined in the include file
DAT\_PAR and specifies the length in characters of all HDS
\htmlref{locators}{sect:locators}. Similar constants, DAT\_\_SZNAM and DAT\_\_SZTYP, specify
the maximum lengths of object \htmlref{names}{sect:name} and
\htmlref{types}{sect:type}.

\item [STATUS:]
HDS \htmlref{routines}{appendix:alphalist} conform to Starlink error
handling conventions (described fully in \xref{SUN/104}{sun104}{}) and
use \st{inherited status checking}. This normally means (unless
otherwise noted in the routine description) that if the STATUS
variable is not set to a value indicating success on entry
(STATUS=SAI\_\_OK), then the subroutine will exit without action. This
behaviour can be very useful in reducing the effort required to check
properly for all possible error conditions.

\item [\htmlref{HDS\_NEW}{HDS_NEW}:]
A container file called \qt{dataset} is created (HDS provides the
default file extension of `.sdf'). A scalar structure called DATASET
with a type of `NDF' is created within this file, and a locator (NLOC)
is associated with this structure. It is usually convenient, although
not essential, to make the top-level object name match the container
file name, as here.

\item [\htmlref{DAT\_NEW}{DAT_NEW}/\htmlref{DAT\_NEWC}{DAT_NEWC}:]
These routines create new objects within HDS itself -- they are not
equivalent to \htmlref{HDS\_NEW}{HDS_NEW} because they don't have any
reference to the container file, only to a higher level structure.

We use two variants of this routine simply because the character
string length has to be specified when creating a character object and
it is normally most convenient to provide this via an additional
integer argument.  However, DAT\_NEW may be used to create new objects
of any type, including character objects. In this case the character
string length would be provided via the type specification, \st{e.g.}\
`\_CHAR{\astar}15' (a character string length of one is assumed if
`\_CHAR' is specified alone).

\item [\htmlref{DAT\_FIND}{DAT_FIND}:]
After an object has been created it is necessary to associate a
locator with it before values can be inserted into it; DAT\_FIND
performs this function.

\item [\htmlref{DAT\_CELL}{DAT_CELL}:]
There are several routines for accessing subsets of objects. DAT\_CELL
obtains a locator to a scalar object (structure or primitive) within a
non-scalar object like a vector.

\item [\htmlref{DAT\_ANNUL}{DAT_ANNUL}:]
This is used to release a locator (just as CLOSE releases a logical
unit number in Fortran). It also closes the container file when it is
no longer being used.

\end{description}

\section{\xlabel{writing_and_reading}WRITING AND READING OBJECTS}

Having created our structure we now want to put some values into
it. This can be done by using the \htmlref{DAT\_PUT}{DAT_PUT} and
\htmlref{DAT\_PUTC}{DAT_PUTC} routines. For example, to fill the main
data array in the \htmlref{above example}{sect:creating} with
values we might do the following:

\begin{small}
\begin{terminalv}
      ...
      BYTE IMVALS( 512, 1024 )
      CHARACTER * ( DAT__SZLOC ) LOC

*  Put data from array IMVALS to the object DATA_ARRAY.
      CALL DAT_FIND( NLOC, 'DATA_ARRAY', LOC, STATUS )
      CALL DAT_PUT( LOC, '_UBYTE', 2, DIMS, IMVALS, STATUS )
      CALL DAT_ANNUL( LOC, STATUS )

*  Put data from character constant to the object LABEL.
      CALL DAT_FIND( NLOC, 'LABEL', LOC, STATUS )
      CALL DAT_PUTC( LOC, 0, 0, 'This is the data label', STATUS )
      CALL DAT_ANNUL( LOC, STATUS )
      ...
\end{terminalv}
\end{small}

Because this sort of activity occurs quite often, \qt{packaged} access
routines have been developed and are available to the programmer (see
Appendix~\ref{appendix:alphalist}).  A complementary set of routines
also exists for getting data from objects back into program arrays or
variables; these are the DAT\_GET routines. Again, packaged versions
exist and are often handy in reducing the number of subroutine calls
required.

\section{\xlabel{mapping_data}\label{sect:mapping}ACCESSING OBJECTS BY MAPPING}

Another technique for accessing values stored in primitive HDS objects
is termed \qt{mapping}.\footnote{This terminology derives from the
facility provided by some operating systems for \st{mapping} the
contents of files into the computer's memory, so that they appear as
if they are arrays of numbers directly accessible to a
program. Although HDS exploits this technique when available, other
techniques can also be used to simulate this behaviour, so HDS does
not depend on the operating system providing this facility.} An
important advantage of this technique is that it removes a size
restriction imposed by having to declare fixed size program arrays to
hold data. This simplifies software, so that a single routine can
handle objects of arbitrary size without recourse to accessing
subsets.

HDS provides mapped access to primitive objects via the DAT\_MAP
routines. Essentially \htmlref{DAT\_MAP}{DAT_MAP} will return a
pointer to a region of the computer's memory in which the object's
values are stored. This pointer can then be passed to another routine
using the (non-standard, but widely available) Fortran \qt{\%VAL}
facility,\footnote{This technique works because Fortran normally
passes the address of an array to a subroutine, so the routine is
fooled into thinking it's getting an array.} together with the
\xref{CNF\_PVAL}{sun209}{CNF_PVAL} function\footnote{We illustrate the
use of the \xref{CNF\_PVAL}{sun209}{CNF_PVAL} function in this
document, although in most existing software which calls HDS this
function is not used. It has been introduced because of the
possibility that Fortran software which stores pointers in 32-bit
INTEGERs may need to execute in circumstances where 64 bits are
required to store a memory pointer. The purpose of the CNF\_PVAL
function is then to expand the pointer value out to its full size
before use, if necessary. On currently-supported platforms, this step
is not normally needed, so use of CNF\_PVAL may considered
optional. However, its inclusion in new software is recommended as a
useful precaution.} (described in \xref{SUN/209}{sun209}{}) which is
defined in the CNF\_PAR include file.  An example will illustrate
this:

\begin{small}
\label{example:mapping}
\begin{terminalv}
      ...
      INCLUDE 'CNF_PAR'
      INTEGER PNTR, EL

*  Map the DATA_ARRAY component of the NDF structure as a vector of type
*  _REAL (even though the object is actually a 512 x 1024 array whose
*  elements are of type _UBYTE).
      CALL DAT_FIND( NLOC, 'DATA_ARRAY', LOC, STATUS )
      CALL DAT_MAPV( LOC, '_REAL', 'UPDATE', PNTR, EL, STATUS )

*  Pass the "array" to a subroutine.
      CALL SUB( EL, %VAL( CNF_PVAL( PNTR ) ), STATUS )

*  Unmap the object and annul the locator.
      CALL DAT_UNMAP( LOC, STATUS )
      CALL DAT_ANNUL( LOC, STATUS )

      END

*  Routine which takes the LOG of all values in a REAL array.
      SUBROUTINE SUB( N, A, STATUS )
      INCLUDE 'SAE_PAR'
      INTEGER N, STATUS
      REAL A( N )
      IF ( STATUS .NE. SAI__OK ) RETURN

      DO 1 I = 1, N
         A( I ) = LOG( A( I ) )
 1    CONTINUE

      END
\end{terminalv}
\end{small}

This example illustrates two features of HDS which we haven't already
mentioned:

\begin{description}

\item [Vectorisation:]
It is possible to force HDS to regard objects as vectors, irrespective
of their true \htmlref{shape}{sect:shape}. This facility was useful in
the above example as it made the subroutine SUB much more general in
that it could be applied to any numeric primitive object.

\item [\label{sect:typeconversion}Automatic type conversion:]
The program can specify the data type it wishes to work with and the
program will work even if the data is stored as a different
\htmlref{type}{sect:type}. HDS will (if necessary) automatically
convert the data to the type required by the program.\footnote{This
will work even if the object was originally created on a different
computer which formats its numbers differently.} This useful feature
can greatly simplify programming -- simple programs can handle all
data types.  Automatic conversion works on reading, writing and
mapping.

\end{description}

Note that once a primitive has been mapped, the associated
\htmlref{locator}{sect:locators} cannot be used to access further data
until the original object is unmapped.

\section{\xlabel{mapping_character_data}\label{sect:charmapping}MAPPING CHARACTER DATA}

Although the \htmlref{previous example}{example:mapping} used a
numeric \htmlref{type}{sect:type} of `\_REAL' to access the data, HDS
actually allows any primitive type to be specified as an access type,
including `\_CHAR'. In the particular case of mapping data as
character strings, however, there are some additional considerations
imposed by the way that compilers handle this data type. These are
described here.

HDS gives you a choice about how to determine the length of the
character strings it will map. You may either specify the length you
want explicitly, \st{e.g:}

\begin{small}
\begin{terminalv}
CALL DAT_MAPV( LOC '_CHAR*30', 'READ', PNTR, EL, STATUS )
\end{terminalv}
\end{small}

(in which case HDS would map an array of character strings with each
string containing 30 characters) or you may leave HDS to decide on the
length required by omitting the length specification, thus:

\small
\begin{small}
\begin{terminalv}
CALL DAT_MAPV( LOC '_CHAR', 'READ', PNTR, EL, STATUS )
\end{terminalv}
\end{small}

In this latter case, HDS will determine the number of characters
actually required to format the object's values without loss of
information. It uses decimal strings for numerical values and the
values `TRUE' and `FALSE' to represent logical values as character
strings. If the object is already of character type, then its actual
length will be used directly. The routine
\htmlref{DAT\_MAPC}{DAT_MAPx} also operates in this manner.

On most UNIX systems, the length of a character string is passed to a
subroutine by the compiler, which adds an additional \qt{invisible}
length argument to the end of the subroutine call for each character
argument passed. Unfortunately, a compiler cannot recognise the data
type of a mapped array, so it will not be able to automatically add
length information about mapped character strings. This information
must therefore be passed explicitly.

As an example, suppose we mapped an array of character strings
specifying that each string should be of length 80 characters, thus:

\begin{small}
\begin{terminalv}
CALL DAT_MAPV( LOC, '_CHAR*80', 'READ', PNTR, EL, STATUS )
\end{terminalv}
\end{small}
\normalsize

This mapped array could be passed to a subroutine for use as follows:

\begin{small}
\begin{terminalv}
INCLUDE 'CNF_PAR'

...

CALL SHOW( EL, %VAL( CNF_PVAL( PNTR ) ), %VAL( CNF_CVAL( 80 ) ) )
\end{terminalv}
\end{small}

The character string length (80) is passed as an additional argument
(which does not appear in the formal argument list of the SHOW
subroutine) using the \qt{\%VAL} facility. The array would then be
declared for use within this routine as if it were a normal Fortran
character array, as follows:

\begin{small}
\begin{terminalv}
SUBROUTINE SHOW( EL, CARRAY )
INTEGER EL
CHARACTER * ( * ) CARRAY( EL )
...
\end{terminalv}
\end{small}

Its character string length could then be determined, as usual, by
using the Fortran intrinsic LEN function within the SHOW routine.

Note that if an access mode of `\_CHAR' were specified when mapping
the array (leaving HDS to determine the length of the mapped strings)
then an additional call to \htmlref{DAT\_CLEN}{DAT_CLEN} would be
required to determine this length, as follows:

\begin{small}
\begin{terminalv}
...
INTEGER LENGTH

CALL DAT_MAPV( LOC, '_CHAR', 'READ', PNTR, EL, STATUS )
CALL DAT_CLEN( LOC, LENGTH, STATUS )
CALL SHOW( EL, %VAL( CNF_PVAL( PNTR ) ), %VAL( CNF_CVAL( LENGTH ) ) )
\end{terminalv}
\end{small}

If more than one mapped character array is being passed, then the
length of each must be passed separately by adding it to the end of
the argument list.  This must be done in the same order as the arrays
themselves are passed.

Unfortunately, this technique will only work if there are no other
character values being passed at earlier points in the argument
list. Otherwise, there is no way of adding additional length
information so that it appears in the correct position relative to the
\qt{invisible} information that the compiler will already have
generated for the other argument(s). The only solution in such cases
is to provide a dummy routine whose purpose is simply to permute the
argument order so that mapped character arrays may be passed at the
start of the formal argument list.

\section{\xlabel{copying}\xlabel{deleting}COPYING AND DELETING OBJECTS}

HDS objects may be individually copied and deleted.  The routines
\htmlref{DAT\_COPY}{DAT_COPY} and \htmlref{DAT\_ERASE}{DAT_ERASE} will
recursively copy and erase all levels of the hierarchy below that
specified in the subroutine call:

\begin{small}
\begin{terminalv}
      ...
      CHARACTER * ( DAT__SZLOC ) OLOC

*  Copy the AXIS structure to component AXISCOPY of the structure located
*  by OLOC (which must have been previously defined).
      CALL DAT_FIND( NLOC, 'AXIS', ALOC, STATUS )
      CALL DAT_COPY( ALOC, OLOC, 'AXISCOPY', STATUS )
      CALL DAT_ANNUL( ALOC, STATUS )

* Erase the original AXIS structure.
      CALL DAT_ERASE( NLOC, 'AXIS', STATUS )
\end{terminalv}
\end{small}

Note that we \htmlref{annulled}{sect:annul} the
\htmlref{locator}{sect:locators} to the AXIS object before attempting
to delete it. This whole operation can also be done using
\htmlref{DAT\_MOVE}{DAT_MOVE}:

\begin{small}
\begin{terminalv}
CALL DAT_MOVE( ALOC, OLOC, 'AXISCOPY', STATUS )
\end{terminalv}
\end{small}

\section{\xlabel{accessing_subsets}SUBSETS OF OBJECTS}

The routine \htmlref{DAT\_CELL}{DAT_CELL} accesses a single element of
an array (an example was shown in \S\ref{sect:creating}). The routine
\htmlref{DAT\_SLICE}{DAT_SLICE} accesses a subset of an arbitrarily
dimensioned object. This subset can then be treated for most purposes
as if it were an object in its own right. For example:

\begin{small}
\begin{terminalv}
      ...
      CHARACTER * ( DAT__SZLOC ) SLICE
      INTEGER LOWER( 2 ), UPPER( 2 )
      DATA LOWER / 100, 100 /
      DATA UPPER / 200, 200 /

*  Get a locator to the subset DATA_ARRAY(100:200,100:200).
      CALL DAT_FIND( NLOC, 'DATA_ARRAY', LOC, STATUS )
      CALL DAT_SLICE( LOC, 2, LOWER, UPPER, SLICE, STATUS )

*  Map the subset as a vector.
      CALL DAT_MAPV( SLICE, '_REAL', 'UPDATE', PNTR, EL, STATUS )
      ...
\end{terminalv}
\end{small}

In contrast to DAT\_SLICE, \htmlref{DAT\_ALTER}{DAT_ALTER} makes a
permanent change to a non-scalar object. The object can be made larger
or smaller, but only the last dimension can be ALTERed. This function
is entirely dynamic, \st{i.e.}\ can be done at any time provided that
the object is not mapped for access. Note that DAT\_ALTER works on
both primitives and structures. It is important to realise that the
number of dimensions cannot be changed by DAT\_ALTER.

\section{\xlabel{temporary_objects}TEMPORARY OBJECTS}

Temporary objects of any \htmlref{type}{sect:type} and \htmlref{shape}{sect:shape} may be
created by using the \htmlref{DAT\_TEMP}{DAT_TEMP} routine. This
returns a \htmlref{locator}{sect:locators} to the newly created object and this may then be
manipulated just as if it were an ordinary object (in fact a temporary
container file is created with a unique name to hold all such objects,
and this is deleted when the program terminates, or when
\htmlref{HDS\_STOP}{HDS_STOP} is called, if this happens
earlier). This is often useful for providing workspace for algorithms
which may have to deal with large arrays.

\section{\xlabel{using_locators}\label{sect:locators}USING LOCATORS}

\subsection{\xlabel{locator_validity}Locator Validity}

As has been illustrated \htmlref{earlier}{sect:creating}, HDS
refers to data objects by means of values held in character variables
called \st{locators}.  Of course, these character values are not HDS
data objects themselves; they simply identify the data objects, whose
internal details are hidden within the HDS system.

Each locator has a unique value which will not be re-used, and this
property makes it possible to tell at any time whether a character
value is a valid HDS locator or not.  A locator's validity depends on
a number of things, such as its actual value (the value
DAT\_\_NOLOC\footnote{As defined in the include file DAT\_PAR.} is
never valid for instance) and the previous history and current state
of the HDS system (a locator which refers to a data object which has
been deleted will no longer be valid).  Note that locator values
should not be explicitly altered by applications, as this may also
cause them to become invalid.

Locator validity can be determined by using the routine
\htmlref{DAT\_VALID}{DAT_VALID}, which returns a logical value of
.TRUE.\ via its VALID argument if the locator supplied is valid:

\begin{small}
\begin{terminalv}
CALL DAT_VALID( LOC, VALID, STATUS )
\end{terminalv}
\end{small}

This is the only HDS routine to which an invalid locator may be passed
without provoking an error.

\subsection{\xlabel{annulling_locators}\label{sect:annul}Annulling Locators}

The number of locators available at any time is quite large, but each
locator consumes various computer resources which may be limited, so
it is important to ensure that locators are \st{annulled\/} once they
have been finished with, \st{i.e.}\ when access to the associated
data object is no longer required.

Annulling an HDS locator renders it invalid and resets its value to
DAT\_\_NOLOC.  It differs from simply setting the locator's variable
to this value, however, because it ensures that all resources
associated with it are released and made available for re-use. A
locator is annulled using the routine \htmlref{DAT\_ANNUL}{DAT_ANNUL},
as follows:

\begin{small}
\begin{terminalv}
CALL DAT_ANNUL( LOC, STATUS )
\end{terminalv}
\end{small}

Note that annulling an invalid locator will produce an error, but this
will be ignored if the STATUS argument is not set to SAI\_\_OK when
DAT\_ANNUL is called (\st{i.e.}\ indicating that a previous error has
occurred). This means that it is not usually necessary to check
whether a locator is valid before annulling it, so long as the only
possible reason for it being invalid is a previous error which has set
a STATUS value.

\subsection{\xlabel{cloning_locators}Cloning Locators}

Since an HDS locator only refers to a data object and does not itself
contain any data values, it is possible to have several locators
referring to the same object.  A duplicate locator for an HDS object
may be derived from an existing one by a process called \st{cloning},
which is performed by the routine \htmlref{DAT\_CLONE}{DAT_CLONE}, as
follows:

\begin{small}
\begin{terminalv}
CALL DAT_CLONE( LOC1, LOC2, STATUS )
\end{terminalv}
\end{small}

This returns a second locator LOC2 which refers to the same data
object as LOC1.

Cloning is not required frequently, but it can occasionally be useful
in allowing an application to \qt{hold on} to a data object when a
locator is passed to a routine which may \htmlref{annul}{sect:annul}
it; \st{i.e.}\ you simply pass the original locator and keep the
cloned copy.

\subsection{\xlabel{primary_and_secondary_locators}\label{sect:primary}Primary and Secondary Locators}

Since data objects are stored in container files, HDS has to decide
when to open and close these files (it would be very inefficient if a
file had to be opened every time an object within it was
referenced). To allow control over this, HDS locators are divided into
two classes termed \st{primary} and \st{secondary}. It is primary
locators that are responsible for holding container files open.

To be more specific, an HDS container file will remain open, so that
data objects within it are accessible, for as long as there is at
least one valid primary locator associated with it (that is, with one
of the data objects within the file). Not surprisingly, those routines
intended for opening container files (\htmlref{HDS\_OPEN}{HDS_OPEN},
\htmlref{HDS\_NEW}{HDS_NEW} and \htmlref{HDS\_WILD}{HDS_WILD}) will
return primary locators -- so that the file subsequently remains
open. However, all other routines return secondary locators (with the
exception of \htmlref{DAT\_PRMRY}{DAT_PRMRY}, which may be used to
manipulate this attribute -- see \S\ref{sect:promote}).

\subsection{\xlabel{container_file_reference_counts}\label{sect:refct}Container File Reference Counts}

The number of \htmlref{primary}{sect:primary} locators associated with
an HDS container file is called its \st{reference count} and may be
determined using the \htmlref{DAT\_REFCT}{DAT_REFCT} routine as
follows:

\begin{small}
\begin{terminalv}
CALL DAT_REFCT( LOC, REFCT, STATUS )
\end{terminalv}
\end{small}

Here, LOC is a locator associated with any object in the file and the
reference count is returned via the integer REFCT argument. The file
will remain open for as long as this value is greater than zero.

Normally, a file's reference count will fall to zero due to
\htmlref{annulling}{sect:annul} the last primary locator associated
with it (usually the locator obtained when the file was originally
opened), and at this point the file will be closed. Before this
happens, however, any mapped primitive objects within it will be
unmapped. In addition, any secondary locators that remain associated
with data objects in the same file will be annulled (\st{i.e.}\ they
will become invalid).\footnote{You are advised not to depend on this
mechanism for annulling secondary locators because you will not
normally have complete control over a file's reference count (for
instance, it may be opened independently for some other purpose in the
same piece of software).} No further reference to objects within the
file may be made until it has been explicitly re-opened.

\subsection{\xlabel{promoting_and_demoting_locators}\label{sect:promote}Promoting and Demoting Locators}

A locator may, at any time, be \qt{promoted} to become a
\htmlref{primary}{sect:primary} locator (thus incrementing the
container file's \htmlref{reference count}{sect:refct}) or
\qt{demoted} to become a secondary locator (and decrementing the
reference count). This is done by using the
\htmlref{DAT\_PRMRY}{DAT_PRMRY} routine with its (first) SET argument
set to .TRUE., thus:

\begin{small}
\begin{terminalv}
PRMRY = .TRUE.             ! Promote the locator
CALL DAT_PRMRY( .TRUE., LOC, PRMRY, STATUS )
\end{terminalv}
\end{small}

With its first argument set to .FALSE., the same routine may also be
used to enquire whether a locator is primary or not.

The main reason for promoting locators is to allow HDS objects to be
passed between routines while ensuring that the associated container
file remains open, so that the object remains accessible. For example,
consider the following simple routine which returns a locator for a
named object inside a container file:

\begin{small}
\begin{terminalv}
      SUBROUTINE FINDIT( FILE, LOC, STATUS )

      <declarations, etc.>

*  Open the container file and find the required object.
      CALL HDS_OPEN( FILE, 'READ', TMPLOC, STATUS )
      CALL DAT_FIND( TMPLOC, 'MY_OBJECT', LOC, STATUS )

*  Promote the new locator and annul the original.
      CALL DAT_PRMRY( .TRUE., LOC, .TRUE., STATUS )
      CALL DAT_ANNUL( LOCTMP, STATUS )
      END
\end{terminalv}
\end{small}

Note how the temporary locator returned by
\htmlref{HDS\_OPEN}{HDS_OPEN} is \htmlref{annulled}{sect:annul} after
first promoting the secondary locator derived from it, so that the
container file remains open. If this is the first time the file has
been opened, its reference count will be 1 when this routine exits, so
it will be closed when the caller later annuls the returned locator
LOC.

\section{\xlabel{enquiries}ENQUIRIES}

One of the most important properties of HDS is that its data files are
self describing. This means that each object carries with it
information describing all its attributes (not just its value), and
these attributes can be obtained by means of enquiry routines. An
example will illustrate:

\begin{small}
\begin{terminalv}
      ...
      PARAMETER ( MAXCMP = 10 )
      CHARACTER * ( DAT__SZNAM ) NAME( MAXCMP )
      CHARACTER * ( DAT__SZTYP ) TYPE( MAXCMP )
      INTEGER NCOMP, I
      LOGICAL PRIM( MAXCMP )

*  Enquire the names and types of up to MAXCMP components...

*  First store the total number of components.
      CALL DAT_NCOMP( NLOC, NCOMP, STATUS)

*  Now index through the structure's components, obtaining locators and the
*  required information.
      DO 1 I = 1, MIN( NCOMP, MAXCMP )

*  Get a locator to the I'th component.
         CALL DAT_INDEX( NLOC, I, LOC, STATUS )

* Obtain its name and type.
         CALL DAT_NAME( LOC, NAME( I ), STATUS )
         CALL DAT_TYPE( LOC, TYPE( I ), STATUS )

* Is it primitive?
         CALL DAT_PRIM( LOC, PRIM( I ), STATUS )
         CALL DAT_ANNUL( LOC, STATUS )
 1    CONTINUE
      ...
\end{terminalv}
\end{small}

Here \htmlref{DAT\_INDEX}{DAT_INDEX} is used to get \htmlref{locators}{sect:locators} to
objects about which (in principle) we know nothing. This is just like
listing the files in a directory, except that the order in which the
components are stored in an HDS structure is arbitrary so they won't
necessarily be accessed in alphabetical order.

\section{\xlabel{packaged_routines}PACKAGED ROUTINES}

HDS provides families of routines which provide a more convenient
method of access to objects than the basic routines. For instance
DAT\_PUTnx and DAT\_GETnx package \htmlref{DAT\_PUT}{DAT_PUT} and
\htmlref{DAT\_GET}{DAT_GET} by dimensionality and
\htmlref{type}{sect:type}. Thus \htmlref{DAT\_PUT0I}{DAT_PUT0x} will
write a single INTEGER value to a scalar
primitive. \htmlref{DAT\_GET1R}{DAT_GET1x} will read the value of a
vector primitive and store it in a REAL program array. There are no
DAT\_GET2x routines; all dimensionalities higher than one are handled
by \htmlref{DAT\_GETNx}{DAT_GETNx} and
\htmlref{DAT\_PUTNx}{DAT_PUTNx}.

Another family of routines are the \htmlref{CMP\_
routines}{appendix:cmproutines}. These access components of the
\qt{current level}. This usually involves:

\begin{itemize}

\item FINDing the required object and getting a \htmlref{locator}{sect:locators} to it.

\item Performing the required operation, \st{e.g.}\ PUTting some
value into it.

\item \htmlref{ANNULling}{sect:annul} the locator.

\end{itemize}

The CMP\_ routines package this sort of operation, replacing three or so
subroutine calls with one. The naming scheme is based on the
associated \htmlref{DAT\_ routines}{appendix:datroutines}. An example is
shown below.

\begin{small}
\begin{terminalv}
      ...
      CHARACTER * 80 DLAB
      INTEGER DIMS( 2 )
      REAL IMVALS( 512, 1024 )
      DATA DIMS / 512, 1024 /

*  Get REAL values from the DATA_ARRAY component.
      CALL CMP_GETNR( NLOC, 'DATA_ARRAY', 2, DIMS, IMVALS, DIMS, STATUS )

*  Get a character string from the LABEL component and store it in DLAB.
      CALL CMP_GET0C( NLOC, 'LABEL', DLAB, STATUS )
      ...
\end{terminalv}
\end{small}

\section{\xlabel{tuning_HDS}\label{sect:tuning}TUNING}

\subsection{\xlabel{setting_HDS_tuning_parameters}Setting HDS Tuning Parameters}

HDS has a number of internal integer \st{tuning parameters} whose
values control various aspects of its behaviour and some of which may
have an important effect on its performance. Each of these parameters
has a default value, but may be over-ridden by either of two
mechanisms.

\begin{description}

\item[\textbf{Environment Variables.}]\mbox{}\\
By defining appropriate environment variables it is possible to set
new default values for HDS tuning parameters. The translation of these
environment variables is picked up when HDS starts up (typically when
the first HDS routine is called) and an attempt is then made to
interpret the resulting value as an integer. If successful, the
default value of the tuning parameter is set to the new value. If not,
it remains unchanged. HDS applies sensible constraints to any new
values supplied.

For example, the UNIX C~shell environment variable definition:

\begin{small}
\begin{terminalv}
setenv HDS_INALQ 10
\end{terminalv}
\end{small}

could be used to increase the default size of all newly created HDS
files to 10 blocks.\footnote{An HDS block is 512 bytes.}

The name of the environment variable is constructed by prefixing the
string `HDS\_' to the tuning parameter name. All such environment
variables must be specified using upper case.

It should be recognised that this ability to set tuning parameter
values via environment variables can be dangerous. It is provided
mainly to encourage experimentation and to overcome \qt{one-off}
tuning problems, but it carries a risk of disrupting normal program
behaviour. In particular, you should not expect that all HDS programs
will necessarily continue to work with all possible settings of their
tuning parameters, and software developers are urged not to write
programs which depend on non-default settings of HDS tuning
parameters, as this may give rise to conflicts with other software. If
a tuning parameter setting really is critical, then it should be set
by the software itself (see below), so as to prohibit outside
interference.

\item[\textbf{Calling \htmlref{HDS\_TUNE}{HDS_TUNE}.}]\mbox{}\\
Tuning parameter values may also be set directly from within an item
of software by means of calls to the routine HDS\_TUNE. This allows
programs to over-ride the default settings (or those established
\st{via} environment variables). To modify the `MAP' tuning parameter,
for example, the following call might be used:

\begin{small}
\begin{terminalv}
CALL HDS_TUNE( 'MAP', 0, STATUS )
\end{terminalv}
\end{small}

This would have the effect of disabling file mapping in favour of
reading and writing as the preferred method of accessing data in
container files. The related routine \htmlref{HDS\_GTUNE}{HDS_GTUNE}
may be used to determine the current setting of a tuning parameter
(see \S\ref{sect:gtune} for an example of its use).

\end{description}

\subsection{\xlabel{tuning_parameters_available}\label{sect:tuning_parameters}Tuning Parameters Available}

HDS currently uses the following tuning parameters to control its
behaviour.

\subsubsection*{Parameters which control the top level HDS library}

\begin{description}

\item [\xlabel{HDS_VERSION_tuning_parameter}VERSION - Data Format for New Files:]\mbox{}\\
This determines the data format that is used when a new container file is
created. It may take the value 3, 4 or 5, and currently defaults to 4
(although this will change to 5 in a future release). Version 4 is a
Starlink-specific data format that is a development of the original HDS
data format created by the Starlink project in the 1980's. Version 5 uses
the HDF5 data format on disk to mimic the facilities of version 4. Such
files cannot be accessed by versions of the HDS library prior to version
6, but can be examined using various publicly available HDF5 tools - see
section \htmlref{``DISK FORMATS AND HDF5''}{sect:hdf5}.  Version 3 refers
to the Starlink-specific data format as it was prior to the introduction of
64-bit mode.

\begin{description}
\item[VERSION$=$5:]\mbox{}\\
Use the HDS data format 5 library, which is based on HDF5.

\item[VERSION$=$4:]\mbox{}\\
Use the HDS data format 4 library with its
``\texttt{64BIT}'' tuning parameter set to 1.

\item[VERSION$=$3:]\mbox{}\\
Use the same HDS library as data format 4, but with its
``\texttt{64BIT}'' tuning parameter set to 0.
\end{description}

\item [\xlabel{HDS_V4LOCKERROR_tuning_parameter}V4LOCKERROR - controls error reporting:]\mbox{}\\
If non-zero, an error is reported if a thread lock function (datLock,
datUnlock or datLocked) is used on a locator for an object stored using
disk format version 4. Otherwise, the function returns without action.
The default is to return without action. This facility is intended for
debugging purposes.

\end{description}

\subsubsection*{Parameters used with both HDS version 4 and version 5 files}

\begin{description}

\item [\xlabel{HDS_MAP_tuning_parameter}MAP - Use file mapping if available?]\mbox{}\\
This value controls the method by which HDS performs I/O operations on
the values of primitive objects and may take the following values:

\begin{description}

\item[MAP$=$1:]\mbox{}\\
Use \qt{file mapping} (if supported) as the preferred method of
accessing primitive data.

\item[MAP$=$0:]\mbox{}\\
Use read/write operations (if supported) as the preferred data access
method.

\item[MAP$=-$1:]\mbox{}\\
Use whichever method is normally faster for sequential access to all
elements of a large array of data.

\item[MAP$=-$2:]\mbox{}\\
Use whichever method is normally faster for sparse random access to a
large array of data.

\item[MAP$=-$3:]\mbox{}\\
Use whichever method normally makes the smaller demand on system
memory resources (normally this means a request to minimise use of
address space or swap file space, but the precise interpretation is
operating system dependent). This is normally the appropriate option
if you intend to use HDS arrays as temporary workspace.

\end{description}

HDS converts all other values to one. The value may be changed at any
time.

A subsequent call to \htmlref{HDS\_GTUNE}{HDS_GTUNE}, specifying the
`MAP' tuning parameter, will return 0 or 1 to indicate which option
was actually chosen. This may depend on the capabilities of the host
operating system and the particular implementation of HDS in use. The
default value for this tuning parameter is also system dependent (see
\S\ref{sect:system_map}).

Typically, file mapping has the following plus and minus points:

\begin{itemize}

\item[\textbf{\mplus}] It allows large arrays accessed via the HDS mapping
routines to be sparsely accessed in an efficient way. In this case,
only those regions of the array actually accessed will need to be
read/written, as opposed to reading the entire array just to access a
small fraction of it. This might be useful, for instance, if a
1-dimensional profile through a large image were being generated.

\item[\textbf{\mplus}] It allows HDS container files to act as \qt{backing store}
for the virtual memory associated with objects accessed via the
mapping routines. The operating system can then use HDS files, rather
than its own backing (swap) file, to implement virtual memory
management. This means that you do not need to have a large system
backing file available in order to access large datasets.

\item[\textbf{\mplus}] For the same reason, temporary objects created with
\htmlref{DAT\_TEMP}{DAT_TEMP} and mapped to provide temporary
workspace make no additional demand on the system backing file.

\item[\textbf{?}] On some operating systems file mapping may be less
efficient in terms of elapsed time than direct read/write
operations. Conversely, on some operating systems it may be more
efficient.

\item[\textbf{$-$}] Despite the memory efficiency of file mapping, there may be
a significant efficiency penalty when large arrays are mapped to
provide workspace. This is because the scratch data will often be
written back to the container file when the array is unmapped (despite
the fact that the file is about to be deleted). This can take a
considerable time and cannot be prevented as the operating system has
control over this process.

Unfortunately, on some operating systems, this process appears to
occur even when normal system calls are used to allocate memory
because file mapping is used implicitly. In this case, HDS's file
mapping is at no particular disadvantage.

\item[\textbf{$-$}] Not all operating systems support file mapping and it
generally requires system-specific programming techniques, making it
more trouble to implement on a new operating system.

\end{itemize}

Using read/write access has the following advantages and
disadvantages:

\begin{itemize}

\item[\textbf{\mplus?}] On some operating systems it may be more efficient than
file mapping in terms of elapsed time in cases where an array of data
will be accessed in its entirety (the normal situation). This is
generally not true of UNIX systems, however,

\item[\textbf{$-$}] It is an inefficient method of accessing a small subset of
a large array because it requires the entire array to be
read/written. The solution to this problem is to explicitly access the
required subset using (\st{e.g.\/}) \htmlref{DAT\_SLICE}{DAT_SLICE},
although this complicates the software somewhat.

\item[\textbf{$-$}] It makes demands on the operating system's backing
file which the file mapping technique avoids (see above). As a result,
there is little point in creating scratch arrays with DAT\_TEMP for
use as workspace unless file mapping is available (because the system
backing file will be used anyway).

\item[\textbf{?}] If an object is accessed several times simultaneously using
HDS mapping routines, then modifications made via one mapping may not
be consistently reflected in the other mapping (modifications will
only be updated in the container file when the object is unmapped, so
the two mappings may get out of step in the mean time). Conversely, if
file mapping is in use and a primitive object is mapped in its
entirety without \htmlref{type conversion}{sect:typeconversion}, then
this behaviour does not occur (all mappings remain consistent). It may
occur, however, if a slice is being accessed or if type conversion is
needed.

It is debatable which behaviour is preferable. The best policy is to
avoid the problem entirely by not utilising multiple access to the
same object while modifications are being made.

\end{itemize}

\item [\xlabel{HDS_SHELL_tuning_parameter}SHELL - Preferred shell:]\mbox{}\\
This parameter determines which UNIX shell should be used to interpret
container file names which contain \qt{special} characters
representing pattern-matching, environment variable substitution,
\st{etc.} Each shell typically has its own particular way of
interpreting these characters, so users of HDS may wish to select the
same shell as they normally use for entering commands. The following
values are allowed:

\begin{description}

\item[SHELL$=$2:]\mbox{}\\
Use the \qt{tcsh} shell (if available). If this is not available, then
use the same shell as when SHELL$=$1.

\item[SHELL$=$1:]\mbox{}\\
Use the \qt{csh} shell (C~shell on traditional UNIX systems). If this
is not available, then use the same shell as when SHELL$=$0.

\item[SHELL$=$0 (the default):]\mbox{}\\
Use the \qt{sh} shell. This normally means the Bourne Shell on
traditional UNIX systems, but on systems which support it, the similar
POSIX \qt{sh} shell may be used instead.

\item[SHELL$=-$1:]\mbox{}\\
Don't use any shell for interpreting single file names (all special
characters are to be interpreted literally). When performing
\qt{wild-card} searches for multiple files (with
\htmlref{HDS\_WILD}{HDS_WILD}), use the same shell as when SHELL$=$0.

\end{description}

HDS converts all other values to zero.

\end{description}

\subsubsection*{Parameters used only with HDS version 4 files}

\begin{description}

\item [\xlabel{HDS_INALQ_tuning_parameter}INALQ - Initial File Allocation Quantity:]\mbox{}\\
This value determines how many blocks\footnote{An HDS block is 512
bytes.} are to be allocated when a new container file is created. The
default value of 2 is the minimum value allowed; the first block
contains header information and the second contains the top-level
object. Note that the host operating system may impose further
restrictions on allowable file sizes, so the actual size of a file may
not match the value specified exactly.

The value of this parameter reverts to its default value (or the value
specified by the HDS\_INALQ environment variable) after each file is
created, so if it is being set from within a program, it must be set
every time that it is required.

If a file is to be extended frequently (through the creation of new
objects within it), then this parameter may provide a worthwhile
efficiency gain by allowing a file of a suitable size to be created
initially. On most UNIX systems, however, the benefits are minimal.

\item [\xlabel{HDS_MAXWPL_tuning_parameter}MAXWPL - Maximum Size of the \qt{Working Page List}:]\mbox{}\\
This value specifies how many blocks\htmltext{\footnote{An HDS block
is 512 bytes.}}  are to be allocated to the memory cache which HDS
uses to hold information about the structure of HDS files and objects
and to buffer its I/O operations when obtaining this information. The
default value is 32 blocks; this value cannot be
decreased. Modifications to this value will only have an effect if
made before HDS becomes active (\st{i.e.}\ before any call is made to
another HDS routine).

There will not normally be any need to increase this value unless
excessively complex data structures are being accessed with very large
numbers of \htmlref{locators}{sect:locators} simultaneously active.

\item [\xlabel{HDS_NBLOCKS_tuning_parameter}NBLOCKS - Size of the internal \qt{Transfer Buffer}:]\mbox{}\\
When HDS has to move large quantities of data from one location to
another, it often has to store an intermediate result. In such cases,
rather than allocate a large buffer to hold all the intermediate data,
it uses a smaller buffer and performs the transfer in pieces. This
parameter specifies the maximum size in blocks\htmltext{\footnote{An
HDS block is 512 bytes.}} which this transfer buffer may have and is
constrained to be no less than the default, which is 32 blocks.

The value should not be too small, or excessive time will be spent in
loops which repeatedly refill the buffer. Conversely, too large a
value will make excessive demands on memory. In practice there is a
wide range of acceptable values, so this tuning parameter will almost
never need to be altered.

\item [\xlabel{HDS_NCOMP_tuning_parameter}NCOMP - Optimum number of structure components:]\mbox{}\\
This value may be used to specify the expected number of components
which will be stored in an HDS structure. HDS does not limit the
number of structure components, but when a structure is first created,
space is set aside for creation of components in future. If more than
the expected number of components are subsequently created, then HDS
must eventually re-organise part of the container file to obtain the
space needed. Conversely, if fewer components are created, then some
space in the file will remain unused. The value is constrained to be
at least one, the default being 6 components.

The value of this parameter is used during the creation of the first
component in every new structure.  It reverts to its default value (or
the value specified by the HDS\_NCOMP environment variable)
afterwards, so if it is being set from within a program, it must be
set every time it is needed.

\item [\xlabel{HDS_SYSLCK_tuning_parameter}SYSLCK - System wide lock flag:]\mbox{}\\
This parameter is present for historical reasons and has no effect on
UNIX systems.

\item [\xlabel{HDS_WAIT_tuning_parameter}WAIT - Wait for locked files?]\mbox{}\\
This parameter is present for historical reasons and currently has no
effect on UNIX systems, where HDS file locking is not implemented.

\item [\xlabel{HDS_64BIT_tuning_parameter}64BIT - Use 64-bit (HDS version 4) files?]\mbox{}\\
This value can be used to select whether new files are created
in the 64-bit (HDS version 4) format.  If 64BIT=0 then
files are created in the previous (HDS version 3) format.

This parameter is normally overriden by the VERSION parameter
of the top level library.

\end{description}

\subsection{\xlabel{tuning_in_practice}\label{sect:gtune}Tuning in Practice}

Normally, a single application which wished to tune HDS itself (rather
than accepting the default settings, or those specified by environment
variables) would do so via calls to \htmlref{HDS\_TUNE}{HDS_TUNE} at
the start, and would thus establish a default \qt{tuning profile} to
apply throughout the rest of the program.  Similarly, a software
environment can initially tune HDS to obtain the required default
behaviour for the applications it will later invoke.

Sometimes, however, it may be necessary to modify a tuning parameter
to improve performance locally while not affecting behaviour of other
parts of a program (or other applications in a software
environment). The routine \htmlref{HDS\_GTUNE}{HDS_GTUNE} may
therefore be used to determine the current setting of an HDS tuning
parameter, so that it may later be returned to its original value. For
instance, if the `MAP' parameter were to be set locally to allow
sparse access to a large array of data, the following technique might
be used:

\begin{small}
\begin{terminalv}
      ...
      INTEGER OLDMAP

*  Obtain the original setting of the MAP parameter.
      CALL HDS_GTUNE( 'MAP', OLDMAP, STATUS )
      IF ( STATUS .EQ. SAI__OK ) THEN

*  Set a new value.
         CALL HDS_TUNE( 'MAP', -2, STATUS )

         <map the array>

*  Return to the old tuning setting.
         CALL ERR_BEGIN( STATUS )
         CALL HDS_TUNE( 'MAP', OLDMAP, STATUS )
         CALL ERR_END( STATUS )
      END IF
\end{terminalv}
\end{small}

Notice how great care has been taken over handling error
conditions. In a large software system it could prove disastrous if a
tuning parameter remained set to an incorrect value (perhaps causing
gross inefficiencies elsewhere) simply because HDS\_TUNE did not
execute after an unexpected error had caused STATUS to be set to an
error value.

\section{\xlabel{compiling_and_linking}COMPILING AND LINKING}

Standalone applications which use HDS may be linked by specifying `hds\_link`
on the compiler command line. Thus, to compile and link a stand-alone
application called \qt{prog}, the following might be used:

\begin{small}
\begin{terminalv}
f77 prog.f -I$STARLINK_DIR/include -L$STARLINK_DIR/lib `hds_link` -o prog
\end{terminalv}
\end{small}

Note the use of the \qt{$-$L} flag to specify the location of the Starlink
libraries and the backward quote characters which perform command
substitution. Include files are located using the \qt{$-$I} flag.

Users of the ADAM programming environment (\xref{SG/4}{sg4}{}) on UNIX
systems need take no special steps in order to link with HDS because
the normal commands for building ADAM tasks will do this
automatically. Thus, for instance, an A-task which calls HDS routines
might be built simply as follows:

\begin{small}
\begin{terminalv}
alink prog.f
\end{terminalv}
\end{small}

If you want to compile subroutine source code without linking, you should use
the \qt{-I} flag as for the standalone example:

\begin{small}
\begin{terminalv}
f77 -c -I$STARLINK_DIR/include subroutine.f
\end{terminalv}
\end{small}

\section{ACKNOWLEDGEMENTS}

The \htmlref{routines}{appendix:alphalist} historically distributed as
HDS and which are still used to access HDS version 4 files, derive from
two original sources. The first is the initial
implementation written by Dave Pearce and Anton Walter at RAL for the
VAX/VMS operating system (initially using the BLISS language), which
was subsequently converted into C by Mike Lawden (RAL) and William
Lupton (RGO and AAO). The second source is a collection of
higher-level routines mostly written at University College London in
Fortran~77 by Sid Wright and Jack Giddings. William Lupton
subsequently performed some of the initial work aimed at making HDS
more portable.

HDS then underwent considerable internal change, including substantial
re-coding to produce a fully portable system based on the POSIX operating
system interface - work done by Rodney Warren-Smith at RAL.

More recently, Tim Jenness (Cornell University) has re-implemented the
HDS API on top of the HDF5 library to create the current (version 6)
library.

\appendix

\newpage
\section{\xlabel{alphabetical_list_of_routines}\label{appendix:alphalist}ALPHABETICAL LIST OF HDS ROUTINES}

% Note that the argument lists of all the following routines, together
% with on-line help information, are available within the Starlink
% language sensitive editor STARLSE (SUN/105).

\label{appendix:cmproutines}
\small
\noindent
\textbf{\htmlref{CMP\_GET0x}{CMP_GET0x}}\st{(loc,name;value,status)} -- Read scalar component\\
\textbf{\htmlref{CMP\_GET1x}{CMP_GET1x}}\st{(loc,name,elx;value,el,status)} -- Read vector component\\
\textbf{\htmlref{CMP\_GETNx}{CMP_GETNx}}\st{(loc,name,ndim,dimx;value,dim,status)} -- Read array component\\
\textbf{\htmlref{CMP\_GETVx}{CMP_GETVx}}\st{(loc,name,elx;value,el,status)} -- Read vectorised component\\
\textbf{\htmlref{CMP\_LEN}{CMP_LEN}}\st{(loc,name;len,status)} -- Enquire component precision\\
\textbf{\htmlref{CMP\_MAPN}{CMP_MAPN}}\st{(loc,name,type,mode,ndim;pntr,dim,status)} -- Map array component\\
\textbf{\htmlref{CMP\_MAPV}{CMP_MAPV}}\st{(loc,name,type,mode;pntr,el,status)} -- Map vectorised component\\
\textbf{\htmlref{CMP\_MOD}{CMP_MOD}}\st{(loc,name,type,ndim,dim;status)} -- Obtain component\\
\textbf{\htmlref{CMP\_MODC}{CMP_MODC}}\st{(loc,name,len,ndim,dim;status)} -- Obtain string component\\
\textbf{\htmlref{CMP\_PRIM}{CMP_PRIM}}\st{(loc,name;reply,status)} -- Enquire component primitive\\
\textbf{\htmlref{CMP\_PUT0x}{CMP_PUT0x}}\st{(loc,name,value;status)} -- Write scalar component\\
\textbf{\htmlref{CMP\_PUT1x}{CMP_PUT1x}}\st{(loc,name,el,value;status)} -- Write vector component\\
\textbf{\htmlref{CMP\_PUTNx}{CMP_PUTNx}}\st{(loc,name,ndim,dimx,value,dim;status)} -- Write array component\\
\textbf{\htmlref{CMP\_PUTVx}{CMP_PUTVx}}\st{(loc,name,el,value;status)} -- Write vectorised component\\
\textbf{\htmlref{CMP\_SHAPE}{CMP_SHAPE}}\st{(loc,name,ndimx;dim,ndim,status)} -- Enquire component shape\\
\textbf{\htmlref{CMP\_SIZE}{CMP_SIZE}}\st{(loc,name;size,status)} -- Enquire component size\\
\textbf{\htmlref{CMP\_STRUC}{CMP_STRUC}}\st{(loc,name;reply,status)} -- Enquire component structure\\
\textbf{\htmlref{CMP\_TYPE}{CMP_TYPE}}\st{(loc,name;type,status)} -- Enquire component type\\
\textbf{\htmlref{CMP\_UNMAP}{CMP_UNMAP}}\st{(loc,name;status)} -- Unmap component\\

\label{appendix:datroutines}
\textbf{\htmlref{DAT\_ALTER}{DAT_ALTER}}\st{(loc,ndim,dim;status)} -- Alter object size \\
\textbf{\htmlref{DAT\_ANNUL}{DAT_ANNUL}}\st{(loc;status)} -- Annul locator \\
\textbf{\htmlref{DAT\_BASIC}{DAT_BASIC}}\st{(loc,mode;pntr,len,status)} -- Map primitive as basic units \\
\textbf{\htmlref{DAT\_CCOPY}{DAT_CCOPY}}\st{(loc1,loc2,name;loc3,status)} -- Copy one structure level\\
\textbf{\htmlref{DAT\_CCTYP}{DAT_CCTYP}}\st{(size;type)} -- Create type string\\
\textbf{\htmlref{DAT\_CELL}{DAT_CELL}}\st{(loc1,ndim,sub;loc2,status)} -- Locate cell \\
\textbf{\htmlref{DAT\_CLEN}{DAT_CLEN}}\st{(loc;clen,status)} -- Enquire character string length \\
\textbf{\htmlref{DAT\_CLONE}{DAT_CLONE}}\st{(loc1;loc2,status)} -- Clone locator \\
\textbf{\htmlref{DAT\_COERC}{DAT_COERC}}\st{(loc1,ndim;loc2,status)} -- Coerce object shape \\
\textbf{\htmlref{DAT\_COPY}{DAT_COPY}}\st{(loc1,loc2,name;status)} -- Copy object \\
\textbf{\htmlref{DAT\_DREP}{DAT_DREP}}\st{(loc;format,order,status)} -- Obtain primitive data representation information\\
\textbf{\htmlref{DAT\_ERASE}{DAT_ERASE}}\st{(loc,name;status)} -- Erase component \\
\textbf{\htmlref{DAT\_ERMSG}{DAT_ERMSG}}\st{(status;length,msg)} -- Translate error status\\
\textbf{\htmlref{DAT\_FIND}{DAT_FIND}}\st{(loc1,name;loc2,status)} -- Find named component \\
\textbf{\htmlref{DAT\_GET}{DAT_GET}}\st{(loc,type,ndim,dim;value,status)} -- Read primitive \\
\textbf{\htmlref{DAT\_GETx}{DAT_GETx}}\st{(loc,ndim,dim;value,status)} -- Read primitive \\
\textbf{\htmlref{DAT\_GET0x}{DAT_GET0x}}\st{(loc;value,status)} -- Read scalar primitive\\
\textbf{\htmlref{DAT\_GET1x}{DAT_GET1x}}\st{(loc,elx;value,el,status)} -- Read vector primitive\\
\textbf{\htmlref{DAT\_GETNx}{DAT_GETNx}}\st{(loc,ndim,dimx;value,dim,status)} -- Read array primitive\\
\textbf{\htmlref{DAT\_GETVx}{DAT_GETVx}}\st{(loc,elx;value,el,status)} -- Read vectorised primitive\\
\textbf{\htmlref{DAT\_INDEX}{DAT_INDEX}}\st{(loc1,index;loc2,status)} -- Index into component list \\
\textbf{\htmlref{DAT\_LEN}{DAT_LEN}}\st{(loc;len,status)} -- Enquire primitive precision \\
\textbf{\htmlref{DAT\_MAP}{DAT_MAP}}\st{(loc,type,mode,ndim,dim;pntr,status)} -- Map primitive \\
\textbf{\htmlref{DAT\_MAPx}{DAT_MAPx}}\st{(loc,mode,ndim,dim;pntr,status)} -- Map primitive \\
\textbf{\htmlref{DAT\_MAPN}{DAT_MAPN}}\st{(loc,type,mode,ndim;pntr,dim,status)} -- Map array primitive\\
\textbf{\htmlref{DAT\_MAPV}{DAT_MAPV}}\st{(loc,type,mode;pntr,el,status)} -- Map vectorised primitive\\
\textbf{\htmlref{DAT\_MOULD}{DAT_MOULD}}\st{(loc,ndim,dim;status)} -- Alter object shape \\
\textbf{\htmlref{DAT\_MOVE}{DAT_MOVE}}\st{(loc1,loc2,name;status)} -- Move object \\
\textbf{\htmlref{DAT\_MSG}{DAT_MSG}}\st{(token,loc)} -- Assign object name to message token \\
\textbf{\htmlref{DAT\_NAME}{DAT_NAME}}\st{(loc;name,status)} -- Enquire object name \\
\textbf{\htmlref{DAT\_NCOMP}{DAT_NCOMP}}\st{(loc;ncomp,status)} -- Enquire number of components \\
\textbf{\htmlref{DAT\_NEW}{DAT_NEW}}\st{(loc,name,type,ndim,dim;status)} -- Create component \\
\textbf{\htmlref{DAT\_NEW0x}{DAT_NEW0x}}\st{(loc,name;status)} -- Create scalar component\\
\textbf{\htmlref{DAT\_NEW0C}{DAT_NEW0C}}\st{(loc,name,len;status)} -- Create scalar string component\\
\textbf{\htmlref{DAT\_NEW1x}{DAT_NEW1x}}\st{(loc,name,el;status)} -- Create vector component\\
\textbf{\htmlref{DAT\_NEW1C}{DAT_NEW1C}}\st{(loc,name,len,el;status)} -- Create vector string component\\
\textbf{\htmlref{DAT\_NEWC}{DAT_NEWC}}\st{(loc,name,len,ndim,dim;status)} -- Create string component\\
\textbf{\htmlref{DAT\_PAREN}{DAT_PAREN}}\st{(loc1;loc2,status)} -- Find parent \\
\textbf{\htmlref{DAT\_PREC}{DAT_PREC}}\st{(loc;nbyte,status)} -- Enquire storage precision\\
\textbf{\htmlref{DAT\_PRIM}{DAT_PRIM}}\st{(loc;reply,status)} -- Enquire object primitive \\
\textbf{\htmlref{DAT\_PRMRY}{DAT_PRMRY}}\st{(set;loc,prmry,status)} -- Set or enquire
primary/secondary locator \\
\textbf{\htmlref{DAT\_PUT}{DAT_PUT}}\st{(loc,type,ndim,dim,value;status)} -- Write primitive \\
\textbf{\htmlref{DAT\_PUTx}{DAT_PUTx}}\st{(loc,ndim,dim,value;status)} -- Write primitive \\
\textbf{\htmlref{DAT\_PUT0x}{DAT_PUT0x}}\st{(loc,value;status)} -- Write scalar primitive\\
\textbf{\htmlref{DAT\_PUT1x}{DAT_PUT1x}}\st{(loc,el,value;status)} -- Write vector primitive\\
\textbf{\htmlref{DAT\_PUTNx}{DAT_PUTNx}}\st{(loc,ndim,dimx,value,dim;status)} -- Write array primitive\\
\textbf{\htmlref{DAT\_PUTVx}{DAT_PUTVx}}\st{(loc,el,value;status)} -- Write vectorised primitive\\
\textbf{\htmlref{DAT\_REF}{DAT_REF}}\st{(loc;ref,lref,status)} -- Obtain reference name for object \\
\textbf{\htmlref{DAT\_REFCT}{DAT_REFCT}}\st{(loc;refct,status)} -- Enquire the reference count for
a container file \\
\textbf{\htmlref{DAT\_RENAM}{DAT_RENAM}}\st{(loc,name;status)} -- Rename object \\
\textbf{\htmlref{DAT\_RESET}{DAT_RESET}}\st{(loc;status)} -- Reset object state \\
\textbf{\htmlref{DAT\_RETYP}{DAT_RETYP}}\st{(loc,type;status)} -- Change object type \\
\textbf{\htmlref{DAT\_SHAPE}{DAT_SHAPE}}\st{(loc,ndimx;dim,ndim,status)} -- Enquire object shape \\
\textbf{\htmlref{DAT\_SIZE}{DAT_SIZE}}\st{(loc;size,status)} -- Enquire object size \\
\textbf{\htmlref{DAT\_SLICE}{DAT_SLICE}}\st{(loc1,ndim,diml,dimu;loc2,status)} -- Locate slice \\
\textbf{\htmlref{DAT\_STATE}{DAT_STATE}}\st{(loc;reply,status)} -- Enquire object state \\
\textbf{\htmlref{DAT\_STRUC}{DAT_STRUC}}\st{(loc;reply,status)} -- Enquire object structure \\
\textbf{\htmlref{DAT\_TEMP}{DAT_TEMP}}\st{(type,ndim,dim;loc,status)} -- Create temporary object \\
\textbf{\htmlref{DAT\_THERE}{DAT_THERE}}\st{(loc,name;reply,status)} -- Enquire component existence \\
\textbf{\htmlref{DAT\_TYPE}{DAT_TYPE}}\st{(loc;type,status)} -- Enquire object type \\
\textbf{\htmlref{DAT\_UNMAP}{DAT_UNMAP}}\st{(loc;status)} -- Unmap object \\
\textbf{\htmlref{DAT\_VALID}{DAT_VALID}}\st{(loc;reply,status)} -- Enquire locator valid \\
\textbf{\htmlref{DAT\_VEC}{DAT_VEC}}\st{(loc1;loc2,status)} -- Vectorise object \\
\textbf{\htmlref{DAT\_WHERE}{DAT_WHERE}}\st{(loc;block,offset,status)} -- Where is primitive data in file? \\

\label{appendix:hdsroutines}
\textbf{\htmlref{HDS\_COPY}{HDS_COPY}}\st{(loc,file,name;status)} -- Copy object to container file \\
\textbf{\htmlref{HDS\_ERASE}{HDS_ERASE}}\st{(loc;status)} -- Erase container file \\
\textbf{\htmlref{HDS\_EWILD}{HDS_EWILD}}\st{(iwld,status)} -- End a wild-card search for HDS container
files \\
\textbf{\htmlref{HDS\_FLUSH}{HDS_FLUSH}}\st{(group;status)} -- Flush locator group \\
\textbf{\htmlref{HDS\_FREE}{HDS_FREE}}\st{(loc;status)} -- Free container file \\
\textbf{\htmlref{HDS\_GROUP}{HDS_GROUP}}\st{(loc;group,status)} -- Enquire locator group \\
\textbf{\htmlref{HDS\_GTUNE}{HDS_GTUNE}}\st{(param;value,status)} -- Enquire value of tuning parameter \\
\textbf{\htmlref{HDS\_LINK}{HDS_LINK}}\st{(loc,group;status)} -- Link locator group \\
\textbf{\htmlref{HDS\_LOCK}{HDS_LOCK}}\st{(loc;status)} -- Lock container file \\
\textbf{\htmlref{HDS\_NEW}{HDS_NEW}}\st{(file,name,type,ndim,dim;loc,status)} -- Create container file \\
\textbf{\htmlref{HDS\_OPEN}{HDS_OPEN}}\st{(file,mode;loc,status)} -- Open container file \\
\textbf{\htmlref{HDS\_SHOW}{HDS_SHOW}}\st{(topic;status)} -- Show HDS statistics \\
\textbf{\htmlref{HDS\_STATE}{HDS_STATE}}\st{(state,status)} -- Enquire HDS state \\
\textbf{\htmlref{HDS\_STOP}{HDS_STOP}}\st{(status)} -- Close down HDS \\
\textbf{\htmlref{HDS\_TRACE}{HDS_TRACE}}\st{(loc;nlev,path,file,status)} -- Trace object path \\
\textbf{\htmlref{HDS\_TUNE}{HDS_TUNE}}\st{(param,value;status)} -- Set HDS parameter \\
\textbf{\htmlref{HDS\_WILD}{HDS_WILD}}\st{(fspec,mode;iwld,loc,status)} -- Perform a wild-card search
for HDS container files
\normalsize

\newpage
\section{\xlabel{routine_descriptions}\label{appendix:routines}ROUTINE DESCRIPTIONS}

This appendix gives specifications for all the stand-alone HDS
routines.  Some general information on the most common parameters is
given below:

\begin{itemize}

\item \st{dim, dimx, ndim, ndimx:}
Parameters \st{dim} and \st{ndim} specify the \htmlref{shape}{sect:shape} of an object;
\st{dimx} and \st{ndimx} specify the largest permitted values of
\st{dim} and \st{ndim}. The vector \st{dim} holds the sizes of the
object dimensions. Thus \st{dim(1)} holds the size of the first
dimension, \st{dim(2)} holds the size of the second dimension, and so
on. The integer \st{ndim} holds the number of dimensions in an
object. HDS supports a maximum of seven object dimensions, thus
\st{dim} should have a maximum of seven elements and \st{ndim} should
not be more than 7. The values of \st{dim} and \st{ndim} must match
the actual shape of the object being processed. A value of zero for
\st{ndim} denotes a scalar object; any value specified for \st{dim}
will be ignored in this case. A vector containing a single value is
different from a scalar.

\item \st{el, elx:}
When an object is a vector (or is treated as one), \st{el} holds the
number of elements in the vector. When a vector is being read (as in
the GET routines), the actual number of elements may be unknown. In
this case \st{elx} holds the maximum permissible number of
elements. This should be equal to the size of the \st{value} array
which is to receive the vector.

\item \st{loc, loc1, loc2, loc3:}
A \htmlref{locator}{sect:locators} is a CHARACTER{\astar}(DAT\_\_SZLOC)
variable, substring or array element used to \qt{locate} objects
within the data system. The contents are used by HDS to access
internal information and must not be altered explicitly by a program.
When more than one routine parameter is a locator, \st{loc1},
\st{loc2} and \st{loc3} are used to identify them. The locator for a
structure array refers to the array as a whole. Each element of a
structure array is itself a structure If you wish to address an
element of a structure array you must obtain a new locator for it
(using \htmlref{DAT\_CELL}{DAT_CELL}). It is important to distinguish
between routines which operate on structures and those which operate
on arrays.

\item \htmlref{\st{name:}}{sect:name}
This is a character value specifying the name of an object. A name is
written as a character string containing any printing
characters. White space is ignored and alphabetic characters are
capitalised. There are no special rules governing the first character
(\st{i.e.}\ it can be numeric).

\item \st{pntr:}
Routines which map an object value return a pointer to the first
element of that object in the parameter \st{pntr}. This can be
converted to a normal array reference by use of the non-standard
Fortran \qt{\%VAL} facility together with the
\xref{CNF\_PVAL}{sun209}{CNF_PVAL} function as shown in
\S\ref{sect:mapping} and \S\ref{sect:charmapping}.

\item \st{status:}
This receives the HDS status value. If, on entry, a routine finds that
\st{status} is not equal to SAI\_\_OK it assumes an error has
occurred previously and returns immediately without action. This
allows tests of \st{status} to be deferred until after several
routine calls have been made. If a routine detects an error itself, it
will set \st{status} to one of the error codes specified in
Appendix~\ref{appendix:errors} and will make an error report in the
usual manner (see \xref{SUN/104}{sun104}{}). Where exceptions to this
behaviour exist, they are documented in the individual routine
descriptions.

\item \htmlref{\st{type:}}{sect:type}
This specifies the data type the program wishes to use when
manipulating a value. This may be different from the data type used to
store the value. We will call the type used by the program the
\st{access type} and the type used to store the value the \st{storage
type}. If these two types differ, automatic conversion is
performed. This is particularly relevant to the GET, PUT and MAP
routines. The types specified in the names or the \st{type} parameter
of these routines refer to the access type, thus
\htmlref{CMP\_GET0I}{CMP_GET0x} will read a scalar component and
present it to the program as an integer, no matter how that value is
stored in the container file. Thus, \st{type} means \st{access type};
it also specifies the \st{storage type} in routines which write a
value.

\item \st{value:}
This holds the value of a primitive and could be a scalar, vector or
an array.  If a value is being read, the size and shape of the vector
or array \st{value} should match the shape of the object. In some
routines \st{value} holds a \qt{vectorised} object value. This means
that the value will be addressed as a linear sequence of elements
instead of as its normal structure. The effect of this depends on how
a structure is mapped. The purpose of vectorising an array is to
enable a simple operation (\st{e.g.}\ adding a constant) to be carried
out on every element without bothering about how each element should
be addressed

\end{itemize}


\newpage
\small
\sstroutine{
   CMP\_GET0x
}{
   Read scalar component
}{
   \sstdescription{
      Read a scalar primitive component of a structure.
   }
   \sstinvocation{
      CALL CMP\_GET0x( LOC, NAME, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         VALUE = ? (Returned)
      }{
         Component value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each standard data \htmlref{type}{sect:type}; to call them,
      replace x by C (Character), D (Double), I (Integer), L (Logical),
      R (Real).
   }
}
\sstroutine{
   CMP\_GET1x
}{
   Read vector component
}{
   \sstdescription{
      Read a vector primitive component of a structure.
   }
   \sstinvocation{
      CALL CMP\_GET1x( LOC, NAME, ELX, VALUE, EL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         ELX = INTEGER (Given)
      }{
         Maximum size of value.
      }
      \sstsubsection{
         VALUE = ?( ELX ) (Returned)
      }{
         Component value.
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         Number of elements.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each standard data \htmlref{type}{sect:type}; to call them,
      replace x by C (Character), D (Double), I (Integer), L (Logical),
      R (Real).
   }
}
\sstroutine{
   CMP\_GETNx
}{
   Read array component
}{
   \sstdescription{
      Read an array primitive component of a structure.
   }
   \sstinvocation{
      CALL CMP\_GETNx( LOC, NAME, NDIM, DIMX, VALUE, DIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         DIMX = INTEGER( NDIM ) (Given)
      }{
         Dimensions of value.
      }
      \sstsubsection{
         VALUE = ?( $<$dimx( 1 )$>$, $<$dimx( 2 )$>$, ... ) (Returned)
      }{
         Component value.
      }
      \sstsubsection{
         DIM = INTEGER( NDIM ) (Returned)
      }{
         Component dimensions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each standard data \htmlref{type}{sect:type}; to call them,
      replace x by C (Character), D (Double), I (Integer), L (Logical),
      R (Real).
   }
}
\sstroutine{
   CMP\_GETVx
}{
   Read vectorised component
}{
   \sstdescription{
      Read a primitive component of a structure as if vectorised.
   }
   \sstinvocation{
      CALL CMP\_GETVx( LOC, NAME, ELX, VALUE, EL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         ELX = INTEGER (Given)
      }{
         Maximum size of value.
      }
      \sstsubsection{
         VALUE = ?( ELX ) (Returned)
      }{
         Component value.
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         Number of elements.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each standard data \htmlref{type}{sect:type}; to call them,
      replace x by C (Character), D (Double), I (Integer), L (Logical),
      R (Real).
   }
}
\sstroutine{
   CMP\_LEN
}{
   Enquire component precision
}{
   \sstdescription{
      Enquire the number of bytes per element of a primitive component.
   }
   \sstinvocation{
      CALL CMP\_LEN( LOC, NAME, LEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         LEN = INTEGER (Returned)
      }{
         Number of bytes per element.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   CMP\_MAPN
}{
   Map array component
}{
   \sstdescription{
      Map a primitive component of a structure as an array.
   }
   \sstinvocation{
      CALL CMP\_MAPN( LOC, NAME, TYPE, MODE, NDIM, PNTR, DIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         TYPE = CHARACTER \astar\ ( DAT\_\_SZTYP ) (Given)
      }{
         Data \htmlref{type}{sect:type}.
      }
      \sstsubsection{
         MODE = CHARACTER \astar\ ( DAT\_\_SZMOD ) (Given)
      }{
         Access mode (\hi{'}READ\hi{'}, \hi{'}UPDATE\hi{'} or \hi{'}WRITE\hi{'}).
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         PNTR = INTEGER (Returned)
      }{
         Pointer to the mapped value.
      }
      \sstsubsection{
         DIM = INTEGER( NDIM ) (Returned)
      }{
         Component dimensions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   CMP\_MAPV
}{
   Map vectorised component
}{
   \sstdescription{
      Map a primitive component of a structure as if vectorised.
   }
   \sstinvocation{
      CALL CMP\_MAPV( LOC, NAME, TYPE, MODE, PNTR, EL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         TYPE = CHARACTER \astar\ ( DAT\_\_SZTYP ) (Given)
      }{
         Data \htmlref{type}{sect:type}.
      }
      \sstsubsection{
         MODE = CHARACTER \astar\ ( DAT\_\_SZMOD ) (Given)
      }{
         Access mode (\hi{'}READ\hi{'}, \hi{'}UPDATE\hi{'} or \hi{'}WRITE\hi{'}).
      }
      \sstsubsection{
         PNTR = INTEGER (Returned)
      }{
         Pointer to the mapped value.
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         Number of elements.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   CMP\_MOD
}{
   Ensure component exists
}{
   \sstdescription{
      Ensure that a component with the specified
\htmlref{name}{sect:name}, \htmlref{type}{sect:type} and \htmlref{shape}{sect:shape}
      exists.  If a component with the required name does not exist,
      one is created.  If a component with that name does exist but has
      a different type or shape, it is deleted and a new one created
      with the required attributes.
   }
   \sstinvocation{
      CALL CMP\_MOD( LOC, NAME, TYPE, NDIM, DIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component name.
      }
      \sstsubsection{
         TYPE = CHARACTER \astar\ ( DAT\_\_SZTYP ) (Given)
      }{
         Data type.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         DIM = INTEGER( NDIM ) (Given)
      }{
         Object dimensions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   CMP\_MODC
}{
   Ensure that string component exists
}{
   \sstdescription{
      Ensure that a component with the specified \htmlref{name}{sect:name}, \htmlref{type}{sect:type}, string
      precision and \htmlref{shape}{sect:shape} exists. If a component with the required name
      does not exist, one is created.  If a component with that name
      does exist but has a different type, string precision or shape,
      it is deleted and a new one created with the required attributes.
   }
   \sstinvocation{
      CALL CMP\_MODC( LOC, NAME, LEN, NDIM, DIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component name.
      }
      \sstsubsection{
         LEN = INTEGER (Given)
      }{
         Number of characters per value.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         DIM = INTEGER( NDIM ) (Given)
      }{
         Object dimensions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   CMP\_PRIM
}{
   Enquire component primitive
}{
   \sstdescription{
      Enquire if a structure component is a primitive object.
   }
   \sstinvocation{
      CALL CMP\_PRIM( LOC, NAME, REPLY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         REPLY = LOGICAL (Returned)
      }{
         .TRUE. if primitive, otherwise .FALSE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   CMP\_PUT0x
}{
   Write scalar component
}{
   \sstdescription{
      Write a scalar primitive component.
   }
   \sstinvocation{
      CALL CMP\_PUT0x( LOC, NAME, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Component value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each standard data \htmlref{type}{sect:type}; to call them,
      replace x by C (Character), D (Double), I (Integer), L (Logical),
      R (Real).
   }
}
\sstroutine{
   CMP\_PUT1x
}{
   Write vector component
}{
   \sstdescription{
      Write a vector primitive component.
   }
   \sstinvocation{
      CALL CMP\_PUT1x( LOC, NAME, EL, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements.
      }
      \sstsubsection{
         VALUE = ?( EL ) (Given)
      }{
         Component value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each standard data \htmlref{type}{sect:type}; to call them,
      replace x by C (Character), D (Double), I (Integer), L (Logical),
      R (Real).
   }
}
\sstroutine{
   CMP\_PUTNx
}{
   Write array component
}{
   \sstdescription{
      Write an array primitive component.
   }
   \sstinvocation{
      CALL CMP\_PUTNx( LOC, NAME, NDIM, DIMX, VALUE, DIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         DIMX = INTEGER( NDIM ) (Given)
      }{
         Dimensions of value.
      }
      \sstsubsection{
         VALUE = ?( $<$dimx( 1 )$>$, $<$dimx( 2 )$>$, ... ) (Given)
      }{
         Component value.
      }
      \sstsubsection{
         DIM = INTEGER( NDIM ) (Given)
      }{
         Component dimensions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each standard data \htmlref{type}{sect:type}; to call them,
      replace x by C (Character), D (Double), I (Integer), L (Logical),
      R (Real).
   }
}
\sstroutine{
   CMP\_PUTVx
}{
   Write vectorised component
}{
   \sstdescription{
      Write a primitive component as if it were vectorised.
   }
   \sstinvocation{
      CALL CMP\_PUTVx( LOC, NAME, EL, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements.
      }
      \sstsubsection{
         VALUE = ?( EL ) (Given)
      }{
         Component value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each standard data \htmlref{type}{sect:type}; to call them,
      replace x by C (Character), D (Double), I (Integer), L (Logical),
      R (Real).
   }
}
\sstroutine{
   CMP\_SHAPE
}{
   Enquire component shape
}{
   \sstdescription{
      Enquire the \htmlref{shape}{sect:shape} of a component.
   }
   \sstinvocation{
      CALL CMP\_SHAPE( LOC, NAME, NDIMX, DIM, NDIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         NDIMX = INTEGER (Given)
      }{
         Size of DIM array.
      }
      \sstsubsection{
         DIM = INTEGER( NDIMX ) (Returned)
      }{
         Component dimensions.
      }
      \sstsubsection{
         NDIM = INTEGER (Returned)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   CMP\_SIZE
}{
   Enquire component size
}{
   \sstdescription{
      Enquire the size of a component.  For an array this will be the
      product of the dimensions; for a scalar, a value of 1 is
      returned.
   }
   \sstinvocation{
      CALL CMP\_SIZE( LOC, NAME, SIZE, STATUS )
   }
\newpage
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         Component size.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   CMP\_STRUC
}{
   Enquire component structure
}{
   \sstdescription{
      Enquire if a structure component is a structure.
   }
   \sstinvocation{
      CALL CMP\_STRUC( LOC, NAME, REPLY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         REPLY = LOGICAL (Returned)
      }{
         .TRUE. if a structure, otherwise .FALSE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   CMP\_TYPE
}{
   Enquire component type
}{
   \sstdescription{
      Enquire the \htmlref{type}{sect:type} of a structure component.
   }
   \sstinvocation{
      CALL CMP\_TYPE( LOC, NAME, TYPE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         TYPE = CHARACTER \astar\ ( DAT\_\_SZTYP ) (Returned)
      }{
         Data type.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   CMP\_UNMAP
}{
   Unmap component
}{
   \sstdescription{
      Unmap a structure component mapped by \htmlref{CMP\_MAPN}{CMP_MAPN} or
      \htmlref{CMP\_MAPV}{CMP_MAPV}.
   }
   \sstinvocation{
      CALL CMP\_UNMAP( LOC, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_ALTER
}{
   Alter object size
}{
   \sstdescription{
      Alter the size of an array by increasing or reducing the last (or
      only) dimension.  If a structure array is to be reduced in size,
      the operation will fail if any truncated elements contain
      components.
   }
   \sstinvocation{
      CALL DAT\_ALTER( LOC, NDIM, DIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         DIM = INTEGER( NDIM ) (Given)
      }{
         Object dimensions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_ANNUL
}{
   Annul locator
}{
   \sstdescription{
      Cancel the association between a \htmlref{locator}{sect:locators} and an object. Any
      primitive value currently mapped to the locator is automatically
      unmapped. If the last \htmlref{primary}{sect:primary} locator associated with a container
      file is annulled, then the container file will be closed.
   }
   \sstinvocation{
      CALL DAT\_ANNUL( LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given and Returned)
      }{
         Object locator. A value of DAT\_\_NOLOC is returned.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine attempts to execute even if status is set on entry,
      although no further error report will be made if it subsequently
      fails under these circumstances. In particular, it will fail if
      the locator supplied is not valid, but this will only be reported
      if status is set to SAI\_\_OK on entry.
   }
}
\sstroutine{
   DAT\_BASIC
}{
   Map primitive as basic units
}{
   \sstdescription{
      Map a primitive as a sequence of basic machine units (bytes) for
      reading, writing or updating.
   }
   \sstinvocation{
      CALL DAT\_BASIC( LOC, MODE, PNTR, LEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         MODE = CHARACTER \astar\ ( DAT\_\_SZMOD ) (Given)
      }{
         Access mode (\hi{'}READ\hi{'}, \hi{'}UPDATE\hi{'} or \hi{'}WRITE\hi{'}).
      }
      \sstsubsection{
         PNTR = INTEGER (Returned)
      }{
         Pointer to the mapped value.
      }
      \sstsubsection{
         LEN = INTEGER (Returned)
      }{
         Total number of bytes mapped.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      If the primitive data have been written on a different machine
      which uses a different data representation, then they will be
      mapped as written (i.e. they will not be converted to or from the
      data representation used by the host machine).
   }
}
\sstroutine{
   DAT\_CCOPY
}{
   Copy one structure level
}{
   \sstdescription{
      Copy an object into a structure and give the new component the
      specified \htmlref{name}{sect:name}.  If the source object is a structure, a new
      structure of the same \htmlref{type}{sect:type} and \htmlref{shape}{sect:shape} is created but the content
      of the original structure is not copied.
   }
   \sstinvocation{
      CALL DAT\_CCOPY( LOC1, LOC2, NAME, LOC3, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC1 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         LOC2 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure locator.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component name.
      }
      \sstsubsection{
         LOC3 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Returned)
      }{
         Component locator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_CCTYP
}{
   Create type string
}{
   \sstdescription{
      Create a \htmlref{type}{sect:type} string for a specified size of character string.
   }
   \sstinvocation{
      CALL DAT\_CCTYP( SIZE, TYPE )
   }
   \sstarguments{
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         Character string size.
      }
      \sstsubsection{
         TYPE = CHARACTER \astar\ ( DAT\_\_SZTYP ) (Returned)
      }{
         Type string.
      }
   }
}
\sstroutine{
   DAT\_CELL
}{
   Locate cell
}{
   \sstdescription{
      Return a \htmlref{locator}{sect:locators} to a \qt{cell} (element) of an array object.
   }
   \sstinvocation{
      CALL DAT\_CELL( LOC1, NDIM, SUB, LOC2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC1 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object locator.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         SUB = INTEGER( NDIM ) (Given)
      }{
         Subscript values.
      }
      \sstsubsection{
         LOC2 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Returned)
      }{
         Cell locator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      Typically, this is used to locate an element of a structure array
      for subsequent access to its components, although this does not
      preclude its use in accessing a single pixel in a 2-D image for
      example.
   }
}
\sstroutine{
   DAT\_CLEN
}{
   Obtain character string length
}{
   \sstdescription{
      The routine returns the number of characters required to
      represent the values of a primitive object. If the object is
      character-type, then its length is returned directly. Otherwise,
      the value returned is the number of characters required to format
      the object\hi{'}s values (as a decimal string if appropriate) without
      loss of information.
   }
   \sstinvocation{
      CALL DAT\_CLEN( LOC, CLEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive object \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         CLEN = INTEGER (Returned)
      }{
         Character string length.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The value returned by this routine is equal to the default
         number of characters allocated to each element whenever a
         primitive object is mapped using an access type of \qt{\_CHAR} (i.e.
         without specifying the length to be used explicitly).

         \sstitem
         If this routine is called with STATUS set, then a value of 1
         will be returned for the CLEN argument, although no further
         processing will occur. The same value will also be returned if
         the routine should fail for any reason.
      }
   }
}
\sstroutine{
   DAT\_CLONE
}{
   Clone locator
}{
   \sstdescription{
      Clone (duplicate) a \htmlref{locator}{sect:locators}.
   }
   \sstinvocation{
      CALL DAT\_CLONE( LOC1, LOC2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC1 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object locator.
      }
      \sstsubsection{
         LOC2 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Returned)
      }{
         Object locator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      All information is inherited except that concerned with any
      mapped primitive data and the \htmlref{primary/secondary}{sect:primary} locator
      characteristic (a secondary locator is always produced -- see
      \htmlref{DAT\_PRMRY}{DAT_PRMRY}). A call to this routine is NOT equivalent to the
      Fortran statement \qt{LOC2 = LOC1}.
   }
}
\sstroutine{
   DAT\_COERC
}{
   Coerce object shape
}{
   \sstdescription{
      Temporarily coerce an object into changing its \htmlref{shape}{sect:shape}.
   }
   \sstinvocation{
      CALL DAT\_COERC( LOC1, NDIM, LOC2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC1 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         LOC2 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Returned)
      }{
         Coerced object locator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      If the number of dimensions in the object is to be increased,
      each additional dimension size is set to 1, e.g. if loc1 is
      associated with a 2-D object of shape (512,256) say, setting ndim
      to 3 transforms the dimensions to (512,256,1).  Likewise, if the
      number of dimensions is to be reduced, the appropriate trailing
      dimension sizes are discarded; the routine will fail if any of
      these do not have the value 1.  As with \htmlref{DAT\_VEC}{DAT_VEC}, only the
      appearance of the object is changed -- the original shape
      remains intact.
   }
}
\sstroutine{
   DAT\_COPY
}{
   Copy object
}{
   \sstdescription{
      Recursively copy an object into a component. This means that the
      complete object (including its components and its components's
      components, etc.) is copied, not just the top level.
   }
   \sstinvocation{
      CALL DAT\_COPY( LOC1, LOC2, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC1 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         LOC2 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure locator.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component name.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_DREP
}{
   Obtain primitive data representation information
}{
   \sstdescription{
      The routine returns information describing how the data stored in
      a primitive object are actually represented. An object's data
      representation will match that used by the computer system on
      which it was created, and this forms a permanent attribute of the
      object. If necessary, HDS will automatically perform conversion
      to the representation used by the host computer when the data are
      accessed (except when using \htmlref{DAT\_BASIC}{DAT_BASIC}, which provides direct
      access to the data without conversion).
   }
   \sstinvocation{
      CALL DAT\_DREP( LOC, FORMAT, ORDER, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive object \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         FORMAT = CHARACTER \astar\ ( \astar\ ) (Returned)
      }{
         Description of the format used to encode each data element
         (see the \qt{Data Format} section).
      }
      \sstsubsection{
         ORDER = CHARACTER \astar\ ( \astar\ ) (Returned)
      }{
         Description of the (byte) storage order used for each data
         element (see the \qt{Storage Order} section).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      Not all combinations of data format and storage order are
      supported.
   }
   \sstdiytopic{
      Data Format
   }{
      HDS currently supports the following encodings of primitive data
      elements. Each description is preceded by the character string
      returned by DAT\_DREP to describe it:

      \sstitemlist{

         \sstitem
         \hi{'}BIT0\hi{'}: Used to encode logical values, in which the least
         significant bit (bit zero) holds the logical value such that 1
         implies .TRUE. and 0 implies .FALSE.. All other bits are
         disregarded (except in \qt{bad} data values when they are all
         significant).

         \sstitem
         \hi{'}NZ\hi{'}: Used to encode logical values, in which all bits set to
         zero implies .FALSE. and any bit set to 1 (i.e. a non-zero data
         value) implies .TRUE..

         \sstitem
         \hi{'}BINARY\hi{'}: Used for unsigned integers; this is a straight
         binary encoding.

         \sstitem
         \hi{'}2COMP\hi{'}: Used for signed integers in which a \qt{2's complement}
         binary encoding of the sign information is employed.

         \sstitem
         \hi{'}VAXF\hi{'}: Used for single precision floating point values; this
         is the VAX/VMS \qt{F-floating} number representation.

         \sstitem
         \hi{'}IEEE\_S\hi{'}: Used for single precision floating point values;
         this is the standard IEEE single precision floating point format.

         \sstitem
         \hi{'}VAXD\hi{'}: Used for double precision floating point values; this
         is the VAX/VMS \qt{D-floating} number representation.

         \sstitem
         \hi{'}IEEE\_D\hi{'}: Used for double precision floating point values;
         this is the standard IEEE double precision floating point format.

         \sstitem
         \hi{'}ASCII\hi{'}: Used for character strings; each character employs
         the standard ASCII encoding.
      }
   }
   \sstdiytopic{
      Storage Order
   }{
      HDS currently supports the following storage orders for the bytes
      of primitive data elements. Each description is preceded by the
      character string returned by DAT\_DREP to describe it:

      \sstitemlist{

         \sstitem
         \hi{'}MSB\hi{'}: Most significant byte stored first.

         \sstitem
         \hi{'}LSB\hi{'}: Least significant byte stored first.

      }
      In the case of floating point formats, the byte in question is the
      most/least significant byte of the fraction.
   }
}
\sstroutine{
   DAT\_ERASE
}{
   Erase component
}{
   \sstdescription{
      Recursively delete a component.  This means that all its lower
      level components are deleted as well.
   }
   \sstinvocation{
      CALL DAT\_ERASE( LOC, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_ERMSG
}{
   Translate a status value into an error message
}{
   \sstdescription{
      This routine translates an error status value into an associated
      error message. It first attempts to translate the value supplied
      as a DAT\_\_ error code. If this fails, it then attempts to
      translate it as a system status code for the host operating
      system. If this also fails, then the returned string is a message
      indicating that the status value could not be translated.
   }
   \sstinvocation{
      CALL DAT\_ERMSG( STATUS, LENGTH, MSG )
   }
\newpage
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The error status value to be translated.
      }
      \sstsubsection{
         LENGTH = INTEGER (Returned)
      }{
         Number of significant characters in the returned error message
         (i.e.  excluding trailing blanks). This value will not exceed
         the length of the character variable supplied for the MSG
         argument.
      }
      \sstsubsection{
         MSG = CHARACTER \astar\ ( \astar\ ) (Returned)
      }{
         The error message.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the variable supplied for the MSG argument is not long
         enough to accommodate the error message, then the message will be
         truncated and the returned value of LENGTH will reflect the
         truncated length.

         \sstitem
         No returned error message will contain more significant
         characters than the value of the EMS\_\_SZMSG symbolic constant.
         This constant is defined in the include file EMS\_PAR.
      }
   }
}
\sstroutine{
   DAT\_FIND
}{
   Find named component
}{
   \sstdescription{
      Obtain a \htmlref{locator}{sect:locators} for a named component.
   }
   \sstinvocation{
      CALL DAT\_FIND( LOC1, NAME, LOC2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC1 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure locator.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         LOC2 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Returned)
      }{
         Component locator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      If the structure is an array, loc1 must be explicitly associated
      with an individual cell.  If the component is a structure array,
      loc2 will be associated with the complete array, not the first
      cell.  Access to its components can only be made through another
      locator explicitly associated with an individual cell (see
      \htmlref{DAT\_CELL}{DAT_CELL}).
   }
}
\sstroutine{
   DAT\_GET
}{
   Read primitive
}{
   \sstdescription{
      Read a primitive (access type specified by a parameter).
   }
   \sstinvocation{
      CALL DAT\_GET( LOC, TYPE, NDIM, DIM, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         TYPE = CHARACTER \astar\ ( DAT\_\_SZTYP ) (Given)
      }{
         Data \htmlref{type}{sect:type}.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         DIM = INTEGER( NDIM ) (Given)
      }{
         Object dimensions.
      }
      \sstsubsection{
         VALUE = ?( $<$dim( 1 )$>$, $<$dim( 2 )$>$, ... ) (Returned)
      }{
         Object value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      When reading character strings the normal Fortran 77 rules for
      character assignment are followed, ie. if the string length of
      the primitive object is less than that of the value array, each
      string is padded to the right with blanks; if greater, the
      strings are truncated from the right.
   }
}
\sstroutine{
   DAT\_GETx
}{
   Read primitive
}{
   \sstdescription{
      Read a primitive (access \htmlref{type}{sect:type} specified by routine name).
   }
   \sstinvocation{
      CALL DAT\_GETx( LOC, NDIM, DIM, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         DIM = INTEGER( NDIM ) (Given)
      }{
         Object dimensions.
      }
      \sstsubsection{
         VALUE = ?( $<$dim( 1 )$>$, $<$dim( 2 )$>$, ... ) (Returned)
      }{
         Object value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each standard data type; to call them,
      replace x by C (Character), D (Double), I (Integer), L (Logical),
      R (Real).  See \htmlref{DAT\_GET}{DAT_GET} notes on character conversion.
   }
}
\sstroutine{
   DAT\_GET0x
}{
   Read scalar primitive
}{
   \sstdescription{
      Read a scalar primitive.
   }
   \sstinvocation{
      CALL DAT\_GET0x( LOC, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         VALUE = ? (Returned)
      }{
         Object value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each standard data \htmlref{type}{sect:type}; to call them,
      replace x by C (Character), D (Double), I (Integer), L (Logical),
      R (Real).  See \htmlref{DAT\_GET}{DAT_GET} notes on character conversion.
   }
}
\sstroutine{
   DAT\_GET1x
}{
   Read vector primitive
}{
   \sstdescription{
      Read a vector primitive.
   }
   \sstinvocation{
      CALL DAT\_GET1x( LOC, ELX, VALUE, EL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         ELX = INTEGER (Given)
      }{
         Maximum size of value.
      }
      \sstsubsection{
         VALUE = ?( ELX ) (Returned)
      }{
         Object value.
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         Number of elements.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each standard data \htmlref{type}{sect:type}; to call them,
      replace x by C (Character), D (Double), I (Integer), L (Logical),
      R (Real).  See \htmlref{DAT\_GET}{DAT_GET} notes on character conversion.
   }
}
\sstroutine{
   DAT\_GETNx
}{
   Read array primitive
}{
   \sstdescription{
      Read an array primitive.
   }
   \sstinvocation{
      CALL DAT\_GETNx( LOC, NDIM, DIMX, VALUE, DIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         DIMX = INTEGER( NDIM ) (Given)
      }{
         Dimensions of value.
      }
      \sstsubsection{
         VALUE = ?( $<$dimx( 1 )$>$, $<$dimx( 2 )$>$, ... ) (Returned)
      }{
         Object value.
      }
      \sstsubsection{
         DIM = INTEGER( NDIM ) (Returned)
      }{
         Object dimensions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each standard data \htmlref{type}{sect:type}; to call them,
      replace x by C (Character), D (Double), I (Integer), L (Logical),
      R (Real).  See \htmlref{DAT\_GET}{DAT_GET} notes on character conversion.
   }
}
\sstroutine{
   DAT\_GETVx
}{
   Read vectorised primitive
}{
   \sstdescription{
      Read a primitive as if it were vectorised (ie. regardless of its actual \htmlref{shape}{sect:shape}).
   }
   \sstinvocation{
      CALL DAT\_GETVx( LOC, ELX, VALUE, EL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         ELX = INTEGER (Given)
      }{
         Maximum size of value.
      }
      \sstsubsection{
         VALUE = ?( ELX ) (Returned)
      }{
         Object value.
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         Number of elements.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each standard data \htmlref{type}{sect:type}; to call them,
      replace x by C (Character), D (Double), I (Integer), L (Logical),
      R (Real).  See \htmlref{DAT\_GET}{DAT_GET} notes on character conversion.
   }
}
\sstroutine{
   DAT\_INDEX
}{
   Index into component list
}{
   \sstdescription{
      Index into a structure's component list and return a \htmlref{locator}{sect:locators} to
      the object at the given position.
   }
   \sstinvocation{
      CALL DAT\_INDEX( LOC1, INDEX, LOC2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC1 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure locator.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         List position.
      }
      \sstsubsection{
         LOC2 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Returned)
      }{
         Component locator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_LEN
}{
   Enquire primitive length
}{
   \sstdescription{
      Enquire the length of a primitive. In the case of a character
      object, this is the number of characters per element. For other
      primitive \htmlref{type}{sect:type}s it is the number of bytes per element.
   }
   \sstinvocation{
      CALL DAT\_LEN( LOC, LEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         LEN = INTEGER (Returned)
      }{
         Number of bytes per element.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_MAP
}{
   Map primitive
}{
   \sstdescription{
      Map a primitive (access \htmlref{type}{sect:type} specified by a parameter).
   }
   \sstinvocation{
      CALL DAT\_MAP( LOC, TYPE, MODE, NDIM, DIM, PNTR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         TYPE = CHARACTER \astar\ ( DAT\_\_SZTYP ) (Given)
      }{
         Data type.
      }
      \sstsubsection{
         MODE = CHARACTER \astar\ ( DAT\_\_SZMOD ) (Given)
      }{
         Access mode (\hi{'}READ\hi{'}, \hi{'}UPDATE\hi{'} or \hi{'}WRITE\hi{'}).
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         DIM = INTEGER( NDIM ) (Given)
      }{
         Object dimensions.
      }
      \sstsubsection{
         PNTR = INTEGER (Returned)
      }{
         Pointer to the mapped value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_MAPx
}{
   Map primitive
}{
   \sstdescription{
      Map a primitive (access \htmlref{type}{sect:type} specified by routine name).
   }
   \sstinvocation{
      CALL DAT\_MAPx( LOC, MODE, NDIM, DIM, PNTR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         MODE = CHARACTER \astar\ ( DAT\_\_SZMOD ) (Given)
      }{
         Access mode (\hi{'}READ\hi{'}, \hi{'}UPDATE\hi{'} or \hi{'}WRITE\hi{'}).
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         DIM = INTEGER( NDIM ) (Given)
      }{
         Object dimensions.
      }
      \sstsubsection{
         PNTR = INTEGER (Returned)
      }{
         Pointer to the mapped value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each standard data \htmlref{type}{sect:type}; to call them,
      replace x by C (Character), D (Double), I (Integer), L (Logical),
      R (Real).
   }
}
\sstroutine{
   DAT\_MAPN
}{
   Map array primitive
}{
   \sstdescription{
      Map a primitive as an array.
   }
   \sstinvocation{
      CALL DAT\_MAPN( LOC, TYPE, MODE, NDIM, PNTR, DIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         TYPE = CHARACTER \astar\ ( DAT\_\_SZTYP ) (Given)
      }{
         Data \htmlref{type}{sect:type}.
      }
      \sstsubsection{
         MODE = CHARACTER \astar\ ( DAT\_\_SZMOD ) (Given)
      }{
         Access mode (\hi{'}READ\hi{'} \hi{'}UPDATE\hi{'} or \hi{'}WRITE\hi{'}).
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         PNTR = INTEGER (Returned)
      }{
         Pointer to the mapped value.
      }
      \sstsubsection{
         DIM = INTEGER( NDIM ) (Returned)
      }{
         Object dimensions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_MAPV
}{
   Map vectorised primitive
}{
   \sstdescription{
      Map a primitive as if it were vectorised.
   }
   \sstinvocation{
      CALL DAT\_MAPV( LOC, TYPE, MODE, PNTR, EL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         TYPE = CHARACTER \astar\ ( DAT\_\_SZTYP ) (Given)
      }{
         Data \htmlref{type}{sect:type}.
      }
      \sstsubsection{
         MODE = CHARACTER \astar\ ( DAT\_\_SZMOD ) (Given)
      }{
         Access mode (\hi{'}READ\hi{'}, \hi{'}UPDATE\hi{'} or \hi{'}WRITE\hi{'}).
      }
      \sstsubsection{
         PNTR = INTEGER (Returned)
      }{
         Pointer to the mapped value.
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         Number of elements.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_MOULD
}{
   Alter object shape
}{
   \sstdescription{
      Alter an object's \htmlref{shape}{sect:shape} permanently.
   }
   \sstinvocation{
      CALL DAT\_MOULD( LOC, NDIM, DIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         DIM = INTEGER( NDIM ) (Given)
      }{
         Object dimensions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      The shape is altered permanently (unlike \htmlref{DAT\_COERC}{DAT_COERC}).  The number
      of dimensions cannot be increased.
   }
}
\sstroutine{
   DAT\_MOVE
}{
   Move object
}{
   \sstdescription{
      Move an object to a new location (ie. copy and erase the
      original).
   }
   \sstinvocation{
      CALL DAT\_MOVE( LOC1, LOC2, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC1 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given and Returned)
      }{
         Object \htmlref{locator}{sect:locators}. A value of DAT\_\_NOLOC is returned.
      }
      \sstsubsection{
         LOC2 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure locator.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      If the object is an array, loc1 must point to the complete array,
      not a slice or cell. loc1 is \htmlref{annulled}{sect:annul} if the operation is
      successful (if it is the last \htmlref{primary}{sect:primary} locator associated with a
      container file, then the container file will be closed -- see
      \htmlref{DAT\_PRMRY}{DAT_PRMRY}). The operation will fail if a component of the same
      name already exists in the structure. The object to be moved need
      not be in the same container file as the structure.
   }
}
\sstroutine{
   DAT\_MSG
}{
   Assign the name of an HDS object to a message token
}{
   \sstdescription{
      The routine assigns the full name (including the file name) of an
      HDS object to a message token for use with the ERR\_ and MSG\_
      routines (\xref{SUN/104}{sun104}{}) or with the EMS\_ routines (\xref{SSN/4}{ssn4}{}). Appropriate
      syntax is used to represent file names which do not have the
      standard `.sdf' file extension.
   }
   \sstinvocation{
      CALL DAT\_MSG( TOKEN, LOC )
   }
   \sstarguments{
      \sstsubsection{
         TOKEN = CHARACTER \astar\ ( \astar\ ) (Given)
      }{
         Name of the message token.
      }
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         \htmlref{Locator}{sect:locators} to the HDS object.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine has no STATUS argument and does not perform
         normal error checking. If it should fail, then no value will be
         assigned to the message token and this will be apparent in the
         final message.
      }
   }
}
\sstroutine{
   DAT\_NAME
}{
   Enquire object name
}{
   \sstdescription{
      Enquire the \htmlref{name}{sect:name} of an object.
   }
   \sstinvocation{
      CALL DAT\_NAME( LOC, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Returned)
      }{
         Object name.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_NCOMP
}{
   Enquire number of components
}{
   \sstdescription{
      Return the number of components in a structure.
   }
   \sstinvocation{
      CALL DAT\_NCOMP( LOC, NCOMP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NCOMP = INTEGER (Returned)
      }{
         Number of components.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      If the structure is an array, loc must be explicitly associated
      with an individual cell.
   }
}
\sstroutine{
   DAT\_NEW
}{
   Create component
}{
   \sstdescription{
      Create a new component in a structure.
   }
   \sstinvocation{
      CALL DAT\_NEW( LOC, NAME, TYPE, NDIM, DIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         TYPE = CHARACTER \astar\ ( DAT\_\_SZTYP ) (Given)
      }{
         Data \htmlref{type}{sect:type}.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         DIM = INTEGER( NDIM ) (Given)
      }{
         Component dimensions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      If type matches one of the primitive type names a primitive of
      the appropriate type is created, otherwise the object is assumed
      to be a structure.  The new object can subsequently be located by
      \htmlref{DAT\_FIND}{DAT_FIND}.  The operation will fail if a component of the same
      name already exists.
   }
}
\sstroutine{
   DAT\_NEW0x
}{
   Create scalar component
}{
   \sstdescription{
      Create a new scalar primitive component in a structure.
   }
   \sstinvocation{
      CALL DAT\_NEW0x( LOC, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each standard data \htmlref{type}{sect:type}; to call them,
      replace x by D (Double), I (Integer), L (Logical), R (Real).
   }
}
\sstroutine{
   DAT\_NEW0C
}{
   Create scalar string component
}{
   \sstdescription{
      Create a new scalar string component in a structure.
   }
   \sstinvocation{
      CALL DAT\_NEW0C( LOC, NAME, LEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         LEN = INTEGER (Given)
      }{
         Number of characters per value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_NEW1x
}{
   Create vector component
}{
   \sstdescription{
      Create a new vector primitive component in a structure.
   }
   \sstinvocation{
      CALL DAT\_NEW1x( LOC, NAME, EL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each standard data \htmlref{type}{sect:type}; to call them,
      replace x by D (Double), I (Integer), L (Logical), R (Real).
   }
}
\sstroutine{
   DAT\_NEW1C
}{
   Create vector string component
}{
   \sstdescription{
      Create a new vector string component in a structure.
   }
   \sstinvocation{
      CALL DAT\_NEW1C( LOC, NAME, LEN, EL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         LEN = INTEGER (Given)
      }{
         Number of characters per value.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_NEWC
}{
   Create string component
}{
   \sstdescription{
      Create a new component whose elements are of \htmlref{type}{sect:type} \qt{\_CHAR{\astar}n}.
   }
   \sstinvocation{
      CALL DAT\_NEWC( LOC, NAME, LEN, NDIM, DIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         LEN = INTEGER (Given)
      }{
         Number of characters per value.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         DIM = INTEGER( NDIM ) (Given)
      }{
         Object dimensions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_PAREN
}{
   Locate parent structure
}{
   \sstdescription{
      The routine returns a \htmlref{locator}{sect:locators} for the parent structure of an HDS
      object; i.e. the structure which contains the object.
   }
   \sstinvocation{
      CALL DAT\_PAREN( LOC1, LOC2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC1 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object locator.
      }
      \sstsubsection{
         LOC2 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Returned)
      }{
         Parent structure locator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         On successful exit, the parent structure locator will identify
         a scalar structure (number of dimensions zero). If appropriate,
         this may be a cell of a structure array.

         \sstitem
         An error will result, and the STATUS value DAT\_\_OBJIN will be
         returned if the object supplied does not have a parent; i.e. if
         it is the top-level object in a container file. The DAT\_\_OBJIN
         error code is defined in the include file DAT\_ERR.

         \sstitem
         If this routine is called with STATUS set, then a value of
         DAT\_\_NOLOC will be returned for the LOC2 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The
         DAT\_\_NOLOC constant is defined in the include file DAT\_PAR.
      }
   }
   \sstdiytopic{
      Example
   }{
      The parent of the object A.B.C.D is A.B.C, the parent of
      X.DATA.ARRAY(1:256) is X.DATA, and the parent of Z.STRUC(17).FLAG
      is Z.STRUC(17).
   }
}
\sstroutine{
   DAT\_PREC
}{
   Enquire storage precision
}{
   \sstdescription{
      Enquire the number of basic machine units (bytes) used to store a
      single element of a primitive.
   }
   \sstinvocation{
      CALL DAT\_PREC( LOC, NBYTE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NBYTE = INTEGER (Returned)
      }{
         Number of machine units.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_PRIM
}{
   Enquire object primitive
}{
   \sstdescription{
      Enquire if an object is a primitive.
   }
   \sstinvocation{
      CALL DAT\_PRIM( LOC, REPLY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         REPLY = LOGICAL (Returned)
      }{
         .TRUE. if primitive, otherwise .FALSE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_PRMRY
}{
   Set or enquire primary/secondary locator status
}{
   \sstdescription{
      The routine may be used to promote a \htmlref{locator}{sect:locators} to become a
      \qt{primary} locator, to demote it to become a \qt{secondary} locator,
      or to enquire about the \htmlref{primary/secondary}{sect:primary} status of a locator.
      It allows control over the duration for which an HDS container
      file remains open; each file remains open only so long as there
      is at least one primary locator associated with it.
   }
   \sstinvocation{
      CALL DAT\_PRMRY( SET, LOC, PRMRY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SET = LOGICAL (Given)
      }{
         If a .TRUE. value is given for this argument, then the routine
         will perform a \qt{set} operation to set the primary/secondary
         status of a locator.  Otherwise it will perform an \qt{enquire}
         operation to return the value of this status without changing
         it.
      }
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given and Returned)
      }{
         The locator whose primary/secondary status is to be set or
         enquired.
      }
      \sstsubsection{
         PRMRY = LOGICAL (Given and Returned)
      }{
         If SET is .TRUE., then this is an input argument and specifies
         the new value to be set (.TRUE. for a primary locator, .FALSE.
         for a secondary locator). If SET is .FALSE., then this is an
         output argument and will return a value indicating whether or
         not a primary locator was supplied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The value of the LOC argument will not normally be changed.
         However, if it is the last primary locator associated with a
         container file, and is being demoted from a primary to a
         secondary locator, then the container file will be left without
         an associated primary locator. In this case, the locator supplied
         will be \htmlref{annulled}{sect:annul} (along with any other secondary locators
         associated with the same file), a value of DAT\_\_NOLOC will be
         returned, and the file will be closed.

         \sstitem
         The DAT\_\_NOLOC constant is defined in the include file
         DAT\_PAR.
      }
   }
}
\sstroutine{
   DAT\_PUT
}{
   Write primitive
}{
   \sstdescription{
      Write a primitive (\htmlref{type}{sect:type} specified by a parameter).
   }
   \sstinvocation{
      CALL DAT\_PUT( LOC, TYPE, NDIM, DIM, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         TYPE = CHARACTER \astar\ ( DAT\_\_SZTYP ) (Given)
      }{
         Data type.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         DIM = INTEGER( NDIM ) (Given)
      }{
         Object dimensions.
      }
      \sstsubsection{
         VALUE = ?( $<$dim( 1 )$>$, $<$dim( 2 )$>$, ... ) (Given)
      }{
         Object value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      When writing character strings the normal Fortran 77 rules for
      character assignment are followed, ie. if the string length of the value
      array is less than that of the primitive, each string is padded to the
      right with blanks; if greater, they are truncated from the right.
   }
}
\sstroutine{
   DAT\_PUTx
}{
   Write primitive
}{
   \sstdescription{
      Write a primitive (\htmlref{type}{sect:type} specified by routine name).
   }
   \sstinvocation{
      CALL DAT\_PUTx( LOC, NDIM, DIM, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         DIM = INTEGER( NDIM ) (Given)
      }{
         Object dimensions.
      }
      \sstsubsection{
         VALUE = ?( $<$dim( 1 )$>$, $<$dim( 2 )$>$, ... ) (Given)
      }{
         Object value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each standard data type; to call them,
      replace x by C (Character), D (Double), I (Integer), L (Logical),
      R (Real).  See \htmlref{DAT\_PUT}{DAT_PUT} notes on character conversion.
   }
}
\sstroutine{
   DAT\_PUT0x
}{
   Write scalar primitive
}{
   \sstdescription{
      Write a scalar primitive.
   }
   \sstinvocation{
      CALL DAT\_PUT0x( LOC, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Object value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each standard data \htmlref{type}{sect:type}; to call them,
      replace x by C (Character), D (Double), I (Integer), L (Logical),
      R (Real).  See \htmlref{DAT\_PUT}{DAT_PUT} notes on character conversion.
   }
}
\sstroutine{
   DAT\_PUT1x
}{
   Write vector primitive
}{
   \sstdescription{
      Write a vector primitive.
   }
   \sstinvocation{
      CALL DAT\_PUT1x( LOC, EL, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements.
      }
      \sstsubsection{
         VALUE = ?( EL ) (Given)
      }{
         Object value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each standard data \htmlref{type}{sect:type}; to call them,
      replace x by C (Character), D (Double), I (Integer), L (Logical),
      R (Real).  See \htmlref{DAT\_PUT}{DAT_PUT} notes on character conversion.
   }
}
\sstroutine{
   DAT\_PUTNx
}{
   Write array primitive
}{
   \sstdescription{
      Write an array primitive.
   }
   \sstinvocation{
      CALL DAT\_PUTNx( LOC, NDIM, DIMX, VALUE, DIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         DIMX = INTEGER( NDIM ) (Given)
      }{
         Dimensions of value.
      }
      \sstsubsection{
         VALUE = ?( $<$dimx( 1 )$>$, $<$dimx( 2 )$>$, ... ) (Given)
      }{
         Object value.
      }
      \sstsubsection{
         DIM = INTEGER( NDIM ) (Given)
      }{
         Object dimensions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each standard data \htmlref{type}{sect:type}; to call them,
      replace x by C (Character), D (Double), I (Integer), L (Logical),
      R (Real).  See \htmlref{DAT\_PUT}{DAT_PUT} notes on character conversion.
   }
}
\sstroutine{
   DAT\_PUTVx
}{
   Write vectorised primitive
}{
   \sstdescription{
      Write a primitive as if it were vectorised (ie. regardless of its actual
      \htmlref{shape}{sect:shape}).
   }
   \sstinvocation{
      CALL DAT\_PUTVx( LOC, EL, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements.
      }
      \sstsubsection{
         VALUE = ?( EL ) (Given)
      }{
         Object value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each standard data \htmlref{type}{sect:type}; to call them,
      replace x by C (Character), D (Double), I (Integer), L (Logical),
      R (Real).  See \htmlref{DAT\_PUT}{DAT_PUT} notes on character conversion.
   }
}
\sstroutine{
   DAT\_REF
}{
   Obtain a reference for an HDS object
}{
   \sstdescription{
      The routine returns a \qt{reference name} for an HDS object whose
      \htmlref{locator}{sect:locators} is supplied. This name identifies the object uniquely by
      including both the name of the container file and the \qt{path name}
      which locates the object within this file. If a locator to a cell
      or a slice is supplied, then subscript information will also be
      included.  Appropriate syntax is used to represent file names
      which do not have the standard `.sdf' file extension.
   }
   \sstinvocation{
      CALL DAT\_REF( LOC, REF, LREF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Locator to the HDS object.
      }
      \sstsubsection{
         REF = CHARACTER \astar\ ( \astar\ ) (Returned)
      }{
         The object's reference name.
      }
      \sstsubsection{
         LREF = INTEGER (Returned)
      }{
         Number of significant characters in the reference name.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_REFCT
}{
   Enquire the reference count for a container file
}{
   \sstdescription{
      The routine returns a count of the number of \htmlref{\qt{primary}}{sect:primary}
\htmlref{locators}{sect:locators}
      associated with an HDS container file (its \htmlref{reference count}{sect:refct}). The
      file will remain open for as long as this number is greater than
      zero.
   }
   \sstinvocation{
      CALL DAT\_REFCT( LOC, REFCT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Locator associated with any object in the container file.
      }
      \sstsubsection{
         REFCT = INTEGER (Returned)
      }{
         Number of primary locators currently associated with the file.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine may be used to determine whether \htmlref{annulling}{sect:annul} a primary
      locator will cause a container file to be closed (also see the
      routine \htmlref{DAT\_PRMRY}{DAT_PRMRY}).
   }
}
\sstroutine{
   DAT\_RENAM
}{
   Rename object
}{
   \sstdescription{
      Rename an object.
   }
   \sstinvocation{
      CALL DAT\_RENAM( LOC, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         New object \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_RESET
}{
   Reset object state
}{
   \sstdescription{
      Reset the state of a primitive, ie. \qt{un-define} its value.
      All subsequent read operations will fail until the object is written to
      (re-defined).
   }
   \sstinvocation{
      CALL DAT\_RESET( LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_RETYP
}{
   Change object type
}{
   \sstdescription{
      Change the \htmlref{type}{sect:type} of an object.  A blank type may be specified.
   }
   \sstinvocation{
      CALL DAT\_RETYP( LOC, TYPE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         TYPE = CHARACTER \astar\ ( DAT\_\_SZTYP ) (Given)
      }{
         Data type.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_SHAPE
}{
   Enquire object shape
}{
   \sstdescription{
      Enquire the \htmlref{shape}{sect:shape} of an object.
   }
   \sstinvocation{
      CALL DAT\_SHAPE( LOC, NDIMX, DIM, NDIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NDIMX = INTEGER (Given)
      }{
         Size of dim.
      }
      \sstsubsection{
         DIM = INTEGER( NDIMX ) (Returned)
      }{
         Object dimensions.
      }
      \sstsubsection{
         NDIM = INTEGER (Returned)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_SIZE
}{
   Enquire object size
}{
   \sstdescription{
      Enquire the size of an object.  For an array this will be the
      product of the dimensions; for a scalar, a value of 1 is
      returned.
   }
   \sstinvocation{
      CALL DAT\_SIZE( LOC, SIZE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         Object size.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_SLICE
}{
   Locate slice
}{
   \sstdescription{
      Return a \htmlref{locator}{sect:locators} to a \qt{slice} of a vector or an array.
   }
   \sstinvocation{
      CALL DAT\_SLICE( LOC1, NDIM, DIML, DIMU, LOC2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC1 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Array locator.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         DIML = INTEGER( NDIM ) (Given)
      }{
         Lower dimension bounds.
      }
      \sstsubsection{
         DIMU = INTEGER( NDIM ) (Given)
      }{
         Upper dimension bounds.
      }
      \sstsubsection{
         LOC2 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Returned)
      }{
         Slice locator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      If any of the upper bounds are zero or negative, the size of the
      corresponding dimension in the object is used.  Currently, only
      1, 2 or 3-D objects can be sliced.
   }
}
\sstroutine{
   DAT\_STATE
}{
   Enquire object state
}{
   \sstdescription{
      Enquire the state of a primitive, ie. whether its value is
      defined or not.
   }
   \sstinvocation{
      CALL DAT\_STATE( LOC, REPLY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         REPLY = LOGICAL (Returned)
      }{
         .TRUE. if defined, otherwise .FALSE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_STRUC
}{
   Enquire object structure
}{
   \sstdescription{
      Enquire if an object is a structure.
   }
   \sstinvocation{
      CALL DAT\_STRUC( LOC, REPLY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         REPLY = LOGICAL (Returned)
      }{
         .TRUE. if structure, otherwise .FALSE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_TEMP
}{
   Create temporary object
}{
   \sstdescription{
      Create an object that exists only for the lifetime of the program
      run.  This may be used to hold temporary objects -- including
      those mapped to obtain scratch space.
   }
   \sstinvocation{
      CALL DAT\_TEMP( TYPE, NDIM, DIM, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TYPE = CHARACTER \astar\ ( DAT\_\_SZTYP ) (Given)
      }{
         Data \htmlref{type}{sect:type}.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         DIM = INTEGER( NDIM ) (Given)
      }{
         Object dimensions.
      }
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Returned)
      }{
         Object \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      If type matches one of the primitive type names, a primitive of
      appropriate type is created; otherwise the object is assumed to
      be a structure.  If the object is a structure array, loc will be
      associated with the complete array, not the first cell.  Thus,
      new components can only be created through another locator which
      is explicitly associated with an individual cell (see \htmlref{DAT\_CELL}{DAT_CELL}).
   }
}
\sstroutine{
   DAT\_THERE
}{
   Enquire component existence
}{
   \sstdescription{
      Enquire if a component of a structure exists.
   }
   \sstinvocation{
      CALL DAT\_THERE( LOC, NAME, REPLY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         REPLY = LOGICAL (Returned)
      }{
         .TRUE. if exists, otherwise .FALSE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_TYPE
}{
   Enquire object type
}{
   \sstdescription{
      Enquire the \htmlref{type}{sect:type} of an object.
   }
   \sstinvocation{
      CALL DAT\_TYPE( LOC, TYPE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         TYPE = CHARACTER \astar\ ( DAT\_\_SZTYP ) (Returned)
      }{
         Data type.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_UNMAP
}{
   Unmap object
}{
   \sstdescription{
      Unmap an object mapped by another DAT\_ routine.
   }
   \sstinvocation{
      CALL DAT\_UNMAP( LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_VALID
}{
   Enquire locator valid
}{
   \sstdescription{
      Enquire if a \htmlref{locator}{sect:locators} is valid, ie. currently associated with an
      object.
   }
   \sstinvocation{
      CALL DAT\_VALID( LOC, REPLY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Locator.
      }
      \sstsubsection{
         REPLY = LOGICAL (Returned)
      }{
         .TRUE. if valid, otherwise .FALSE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   DAT\_VEC
}{
   Vectorise object
}{
   \sstdescription{
      Address an array as if it were a vector.
   }
   \sstinvocation{
      CALL DAT\_VEC( LOC1, LOC2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC1 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Array \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         LOC2 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Returned)
      }{
         Vector locator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      In general, it is not possible to vectorise an array slice such as
      created by DAT\_SLICE. If LOC1 is a locator for a slice, an error
      will be reported if the elements of the slice are dis-contiguous.
      If the elements of the slice are contiguous, then no error will be
      reported.
   }
}
\sstroutine{
   DAT\_WHERE
}{
   Find position of primitive in HDS file
}{
   \sstdescription{
      The routine returns information describing the position in an HDS
      container file at which the data associated with a primitive
      object are stored.
   }
   \sstinvocation{
      CALL DAT\_WHERE( LOC, BLOCK, OFFSET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive object \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         BLOCK = INTEGER (Returned)
      }{
         Number of the file block in which the object's data start. HDS
         file blocks are 512 bytes long and are numbered from the
         beginning of the file, starting at block 1.
      }
      \sstsubsection{
         OFFSET = INTEGER (Returned)
      }{
         Byte offset (zero based) of the start of data within the file
         block.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The use of this routine is not recommended. It is provided
         solely for use by experienced programmers who are familiar with
         the internal structure of HDS container files and who wish to
         access the file contents directly. Note, however, that changes to
         the format of an HDS file may occur in future.

         \sstitem
         The start of the data associated with a cell or a slice of a
         primitive object may be located with this routine, but the data
         associated with a slice will not, in general, be stored at
         contiguous locations within the file.

         \sstitem
         Care must be taken that no changes are made to adjacent bytes
         within the file which are not part of the requested object's
         data.

         \sstitem
         Note that the data associated with primitive objects may not
         necessarily be stored contiguously in future versions of HDS.
      }
   }
}
\sstroutine{
   HDS\_COPY
}{
   Copy an object to a new container file
}{
   \sstdescription{
      The routine makes a copy of an HDS object, placing the copy in a
      new container file (which is created), as the top-level object.
      The copying operation is recursive; i.e. all sub-components of a
      structure will also be copied.
   }
   \sstinvocation{
      CALL HDS\_COPY( LOC, FILE, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         \htmlref{Locator}{sect:locators} for the object to be copied.
      }
      \sstsubsection{
         FILE = CHARACTER \astar\ ( \astar\ ) (Given)
      }{
         Name of the new container file to be created.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( \astar\ ) (Given)
      }{
         \htmlref{Name}{sect:name} which the new top-level object is to have.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine attempts to eliminate unused space during the
         copying operation and is therefore a useful method of compressing
         a container file from which components have been deleted.

         \sstitem
         The routine may be used to copy both primitive and structured
         objects, but cannot be used to make a copy of a cell or a slice.
      }
   }
}
\sstroutine{
   HDS\_ERASE
}{
   Erase container file
}{
   \sstdescription{
      Mark a container file for deletion and \htmlref{annul}{sect:annul} the \htmlref{locator}{sect:locators}
      associated with the top-level object.  The container file will
      not be physically deleted if other \htmlref{primary}{sect:primary} locators are still
      associated with the file -- this is only done when the \htmlref{reference
      count}{sect:refct} drops to zero.
   }
   \sstinvocation{
      CALL HDS\_ERASE( LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Locator to the container file's top-level object.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   HDS\_EWILD
}{
   End a wild-card search for HDS container files
}{
   \sstdescription{
      The routine ends a wild-card search for HDS container files begun
      by \htmlref{HDS\_WILD}{HDS_WILD}, and annuls the wild-card search context used. It
      should be called after a wild-card search is complete in order to
      release the resources used.
   }
   \sstinvocation{
      CALL HDS\_EWILD( IWLD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWLD = INTEGER (Given and Returned)
      }{
         Identifier for the wild-card search context to be annulled, as
         returned by HDS\_WILD. A value of DAT\_\_NOWLD is returned (as
         defined in the include file DAT\_PAR).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine attempts to execute even if STATUS is set on entry,
      although no further error report will be made if it subsequently
      fails under these circumstances. In particular, it will fail if
      the identifier supplied is not initially valid, but this will
      only be reported if STATUS is set to SAI\_\_OK on entry.
   }
}
\sstroutine{
   HDS\_FLUSH
}{
   Flush locator group
}{
   \sstdescription{
      \htmlref{Annul}{sect:annul} all \htmlref{locators}{sect:locators} currently assigned to a specified locator
      \htmlref{group}{sect:group}.
   }
   \sstinvocation{
      CALL HDS\_FLUSH( GROUP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         GROUP = CHARACTER \astar\ ( DAT\_\_SZGRP ) (Given)
      }{
         Group name.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   HDS\_FREE
}{
   Free container file
}{
   \sstdescription{
      Release all explicit or implicit locks on a container file,
      thereby granting write-access to other processes.
   }
   \sstinvocation{
      CALL HDS\_FREE( LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         \htmlref{Locator}{sect:locators} to the container file's top-level object.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   HDS\_GROUP
}{
   Enquire locator group
}{
   \sstdescription{
      Return the name of the \htmlref{group}{sect:group} to which a \htmlref{locator}{sect:locators} belongs.
   }
   \sstinvocation{
      CALL HDS\_GROUP( LOC, GROUP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object locator.
      }
      \sstsubsection{
         GROUP = CHARACTER \astar\ ( DAT\_\_SZGRP ) (Returned)
      }{
         Group name.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   HDS\_GTUNE
}{
   Obtain tuning parameter value
}{
   \sstdescription{
      The routine returns the current value of an HDS tuning parameter
      (normally this will be its default value, or the value last
      specified using the \htmlref{HDS\_TUNE}{HDS_TUNE} routine).
   }
   \sstinvocation{
      CALL HDS\_GTUNE( PARAM, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER \astar\ ( \astar\ ) (Given)
      }{
         Name of the tuning parameter whose value is required (case
         insensitive).
      }
      \sstsubsection{
         VALUE = INTEGER (Returned)
      }{
         Current value of the parameter.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      Tuning parameter names may be abbreviated to 4 characters.
   }
}
\sstroutine{
   HDS\_LINK
}{
   Link locator group
}{
   \sstdescription{
      Link a \htmlref{locator}{sect:locators} to a \htmlref{group}{sect:group}.
   }
   \sstinvocation{
      CALL HDS\_LINK( LOC, GROUP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object locator.
      }
      \sstsubsection{
         GROUP = CHARACTER \astar\ ( DAT\_\_SZGRP ) (Given)
      }{
         Group name.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   HDS\_LOCK
}{
   Lock container file
}{
   \sstdescription{
      Lock a container file in update mode; this protects the file from
      being accessed by other writers.  The file remains explicitly
      locked until \htmlref{HDS\_FREE}{HDS_FREE} is called or until the file is physically
      closed.
   }
   \sstinvocation{
      CALL HDS\_LOCK( LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         \htmlref{Locator}{sect:locators} to the container file's top-level object.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   HDS\_NEW
}{
   Create container file
}{
   \sstdescription{
      Create a new container file and return a \htmlref{primary}{sect:primary} \htmlref{locator}{sect:locators} to the
      top-level object.
   }
   \sstinvocation{
      CALL HDS\_NEW( FILE, NAME, TYPE, NDIM, DIM, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FILE = CHARACTER \astar\ ( \astar\ ) (Given)
      }{
         Container file name.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Object \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         TYPE = CHARACTER \astar\ ( DAT\_\_SZTYP ) (Given)
      }{
         Data \htmlref{type}{sect:type}.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions.
      }
      \sstsubsection{
         DIM = INTEGER( NDIM ) (Given)
      }{
         Object dimensions (ignored if NDIM is zero).
      }
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Returned)
      }{
         Object locator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      If a file extension is not specified, `.sdf' is used.  If type
      matches one of the HDS primitive type names a primitive of that
      type is created, otherwise the object is assumed to be a
      structure.  If the top-level object is a structure array, loc
      will be associated with the complete array, not the first cell.
      Thus, new components can only be created through another locator
      which is explicitly associated with an individual cell (see
      \htmlref{DAT\_CELL}{DAT_CELL}).
   }
}
\sstroutine{
   HDS\_OPEN
}{
   Open container file
}{
   \sstdescription{
      Open an existing container file for reading, writing or updating
      and return a \htmlref{primary}{sect:primary} \htmlref{locator}{sect:locators} to the top-level object.  If the
      file is currently open in the specified mode, the routine
      increments the \htmlref{reference count}{sect:refct} rather than re-opening the file.
   }
   \sstinvocation{
      CALL HDS\_OPEN( FILE, MODE, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FILE = CHARACTER \astar\ ( \astar\ ) (Given)
      }{
         Container file name.
      }
      \sstsubsection{
         MODE = CHARACTER \astar\ ( DAT\_\_SZMOD ) (Given)
      }{
         Access mode (\hi{'}READ\hi{'}, \hi{'}UPDATE\hi{'} or \hi{'}WRITE\hi{'}).
      }
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Returned)
      }{
         Object locator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      If a file extension is not specified, `.sdf' is used.  If the
      top-level object is a structure array, loc will be associated
      with the complete array, not the first cell.  Thus, access to any
      of the structure's components can only be made through another
      locator which is explicitly associated with an individual cell
      (see \htmlref{DAT\_CELL}{DAT_CELL}).
   }
}
\sstroutine{
   HDS\_SHOW
}{
   Show HDS statistics
}{
   \sstdescription{
      Display statistics about the specified topic on the standard
      output.
   }
   \sstinvocation{
      CALL HDS\_SHOW( TOPIC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TOPIC = CHARACTER \astar\ ( \astar\ ) (Given)
      }{
         Topic name.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This facility is provided as an implementation aid only.  The
      following topics are currently supported:

      \sstitemlist{

         \sstitem
         \hi{'}DATA\hi{'}: display details of the representation of primitive data
         in use by the host machine.

         \sstitem
         \hi{'}FILES\hi{'}: list all open container files and their associated
         attributes in the format:
\begin{quote}
            $<$filename$>$, disp=$<$disp$>$, mode=$<$mode$>$, refcnt=$<$refcnt$>$
\end{quote}
         where $<$disp$>$ denotes the file disposition ([K] for keep or [D]
         for delete); $<$mode$>$ indicates the access mode ([R] for read-only,
         [U] for update or write) and $<$refcnt$>$ specifies the number of
         \htmlref{primary}{sect:primary} \htmlref{locators}{sect:locators} associated with the file.
      }
      \sstitemlist{

         \sstitem
         \hi{'}LOCATORS\hi{'}: display the fully resolved path names of all
         objects currently associated with active locators.
      }
   }
}
\sstroutine{
   HDS\_STATE
}{
   Enquire the current state of HDS
}{
   \sstdescription{
      This routine returns a logical value indicating whether HDS is
      currently active or inactive.
   }
   \sstinvocation{
      CALL HDS\_STATE( STATE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATE = LOGICAL (Returned)
      }{
         The current state of HDS: .TRUE. for active, .FALSE. for
         inactive.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   HDS\_STOP
}{
   Close down HDS
}{
   \sstdescription{
      This routine closes down HDS, \htmlref{annulling}{sect:annul} all active \htmlref{locators}{sect:locators},
      closing all container files and releasing all associated
      resources.  It returns without action if HDS is not active.
   }
   \sstinvocation{
      CALL HDS\_STOP( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine attempts to execute even if STATUS is set on entry,
      although no further error report will be made if it subsequently
      fails under these circumstances.
   }
}
\sstroutine{
   HDS\_TRACE
}{
   Trace object path
}{
   \sstdescription{
      Trace the path of an object and return the fully resolved name as
      a text string.
   }
   \sstinvocation{
      CALL HDS\_TRACE( LOC, NLEV, PATH, FILE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NLEV = INTEGER (Returned)
      }{
         Number of path levels.
      }
      \sstsubsection{
         PATH = CHARACTER \astar\ ( \astar\ ) (Returned)
      }{
         Object path name within container file.
      }
      \sstsubsection{
         FILE = CHARACTER \astar\ ( \astar\ ) (Returned)
      }{
         Container file name.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      The path name is constructed as a sequence of \qt{node}
      specifications thus: node.node......node.object such as:
      NGC1365.SKYPOS.RA.MINUTES where MINUTES is the name of the object
      associated with the specified locator and NGC1365 is the
      top-level object in the structure.  If any of the nodes are
      non-scalar the appropriate subscript expression is included thus:
      AAO.OBS(6).IMAGE\_DATA If the bottom-level object is a slice or
      cell of an array, the appropriate subscript expression is
      appended thus: M87.MAP(100:412,200:312) or CENA(3,2)
   }
}
\sstroutine{
   HDS\_TUNE
}{
   Set HDS tuning parameter
}{
   \sstdescription{
      Alter an HDS control setting.
   }
   \sstinvocation{
      CALL HDS\_TUNE( PARAM, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER \astar\ ( \astar\ ) (Given)
      }{
         Name of the tuning parameter.
      }
      \sstsubsection{
         VALUE = INTEGER (Given)
      }{
         New parameter value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   HDS\_WILD
}{
   Perform a wild-card search for HDS container files
}{
   \sstdescription{
      The routine searches for HDS container files whose names match a
      given wild-card file specification, and which are accessible
      using a specified mode of access. It is normally called
      repeatedly, returning a \htmlref{locator}{sect:locators} for the top-level object in a new
      container file on each occasion, and a null locator value
      (DAT\_\_NOLOC) when no more container files remain to be located.

      In normal use, the IWLD argument should be set to the value
      DAT\_\_NOWLD before the first call to HDS\_WILD. The value returned
      through this argument subsequently identifies the search context,
      which is retained between calls. In this way, several wild-card
      searches may be performed concurrently if required.

      A call to \htmlref{HDS\_EWILD}{HDS_EWILD} should be made to annul the search context
      identifier when the search is complete. This will release any
      resources used.
   }
   \sstinvocation{
      CALL HDS\_WILD( FSPEC, MODE, IWLD, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FSPEC = CHARACTER \astar\ ( \astar\ ) (Given)
      }{
         The wild-card file specification identifying the container
         files required (a default file type extension of `.sdf' is
         assumed, if not specified). The syntax of this specification
         depends on the host operating system (see \S\ref{sect:system_wild}).
      }
      \sstsubsection{
         MODE = CHARACTER \astar\ ( DAT\_\_SZMOD ) (Given)
      }{
         The mode of access required to the container files: \hi{'}READ\hi{'},
         \hi{'}UPDATE\hi{'} or \hi{'}WRITE\hi{'} (case insensitive).
      }
      \sstsubsection{
         IWLD = INTEGER (Given and Returned)
      }{
         If a value of DAT\_\_NOWLD is supplied on input, then a new
         wild-card search context will be started, a new value for IWLD
         will be returned, and the first HDS container file matching
         the file specification given in FSPEC will be located. If an
         IWLD value saved from a previous invocation of HDS\_WILD is
         supplied, then the previous search context will be used and
         the next container file appropriate to that context will be
         located. In this case, the value of FSPEC is not used.
      }
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Returned)
      }{
         A \htmlref{primary}{sect:primary} locator to the top-level object in the next
         container file to satisfy the file specification given in
         FSPEC.  A value of DAT\_\_NOLOC will be returned (without error)
         if no further container files remain to be located.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine does not return locators for files which are not
         valid HDS container files or which are not accessible using the
         specified access mode.

         \sstitem
         The routine takes a \qt{snapshot} of the file system when it is
         first called (with IWLD set to DAT\_\_NOWLD) and subsequently
         returns locators for each of the HDS container files found, one
         at a time. This strategy avoids possible run-away conditions if
         (say) output files created by an application were later to be
         selected by a wild-card search used to identify further input
         files.

         \sstitem
         An error may result if any file matched by an initial call to
         HDS\_WILD (with IWLD set to DAT\_\_NOWLD) cannot be accessed when a
         subsequent call requires that a locator be returned for it. This
         might happen, for instance, if the file has been deleted in the
         intervening time. If the resulting error condition is annulled,
         the offending file may be skipped and subsequent calls to
         HDS\_WILD will continue to locate any remaining files.

         \sstitem
         An error will result and a STATUS value of DAT\_\_FILNF will be
         returned if no HDS container files can be found which match the
         wild-card specification supplied on an initial call to HDS\_WILD.

         \sstitem
         A value of DAT\_\_NOLOC will be returned for the LOC argument if
         this routine is called with STATUS set, or if it should fail for
         any reason. In addition, the value of IWLD will be returned
         unchanged if the routine is called with STATUS set or if failure
         should occur during an initial call (i.e. when IWLD is set to
         DAT\_\_NOWLD on entry).

         \sstitem
         The DAT\_\_NOLOC and DAT\_\_NOWLD constants are defined in the
         include file DAT\_PAR. The DAT\_\_FILNF error code is defined in the
         include file DAT\_ERR.
      }
   }
}
\normalsize

\newpage
\section{\xlabel{obsolete_routines}OBSOLETE ROUTINES}
The routines described below have been rendered obsolete by
developments in HDS and should not be used in new software. They are
included here simply as an aid to understanding existing software
which uses them, and to allow them to be replaced with alternative
techniques as the opportunity arises. These routines will eventually
be removed from the HDS documentation and may, in some cases,
eventually be eliminated from HDS altogether.

The reason for obsolescence is indicated in each case.

\small
\sstroutine{
   DAT\_CONV
}{
   Enquire data conversion
}{
   \sstdescription{
      Compare the data \htmlref{type}{sect:type} of a primitive with the type of data being
      used by the program and determine whether conversion is possible.
   }
   \sstinvocation{
      CALL DAT\_CONV( LOC, TYPE, REPLY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Primitive \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         TYPE = CHARACTER \astar\ ( DAT\_\_SZTYP ) (Given)
      }{
         Data type used by the program.
      }
      \sstsubsection{
         REPLY = LOGICAL (Returned)
      }{
         .TRUE. if conversion possible, otherwise .FALSE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine is obsolete as HDS now permits all conversions
      between primitive types.
   }
}
\sstroutine{
   DAT\_ERDSC
}{
   Report object error
}{
   \sstdescription{
      Report an error in the form \qt{object\_name: message} where message
      is the text associated with error number status.
   }
   \sstinvocation{
      CALL DAT\_ERDSC( LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine is obsolete as HDS now reports its own errors. Any
      additional error reports from applications should be made using
      the ERR\_ routines (\xref{SUN/104}{sun104}{}). Error reports from system code
      should use the EMS\_ routines (\xref{SSN/4}{ssn4}{}).
   }
}
\sstroutine{
   DAT\_ERDSN
}{
   Report component error
}{
   \sstdescription{
      Report an error in the form \qt{structure\_name.component\_name:
      message} where message is the text associated with error number
      status.
   }
   \sstinvocation{
      CALL DAT\_ERDSN( LOC, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine is obsolete as HDS now reports its own errors. Any
      additional error reports from applications should be made using
      the ERR\_ routines (\xref{SUN/104}{sun104}{}). Error reports from system code
      should use the EMS\_ routines (\xref{SSN/4}{ssn4}{}).
   }
}
\sstroutine{
   DAT\_ERTXT
}{
   Report error
}{
   \sstdescription{
      Report an error in the form \qt{text: message} where text is a
      specified character string and message is the text associated
      with error number status.
   }
   \sstinvocation{
      CALL DAT\_ERTXT( TEXT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TEXT = CHARACTER \astar\ ( \astar\ ) (Given)
      }{
         Character string.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine is obsolete as HDS now reports its own errors. Any
      additional error reports from applications should be made using
      the ERR\_ routines (\xref{SUN/104}{sun104}{}). Error reports from system code
      should use the EMS\_ routines (\xref{SSN/4}{ssn4}{}).
   }
}
\sstroutine{
   DAT\_RCERA
}{
   Recursive erase
}{
   \sstdescription{
      Recursively delete a component of a structure.
   }
   \sstinvocation{
      CALL DAT\_RCERA( LOC, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine is obsolete; its action is now performed by
      \htmlref{DAT\_ERASE}{DAT_ERASE}.
   }
}
\sstroutine{
   DAT\_RCOPY
}{
   Recursive copy
}{
   \sstdescription{
      Recursively copy an object into a component of a structure.
   }
   \sstinvocation{
      CALL DAT\_RCOPY( LOC1, LOC2, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC1 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Object \htmlref{locator}{sect:locators}.
      }
      \sstsubsection{
         LOC2 = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Structure locator.
      }
      \sstsubsection{
         NAME = CHARACTER \astar\ ( DAT\_\_SZNAM ) (Given)
      }{
         Component \htmlref{name}{sect:name}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine is obsolete; its action is now performed by
      \htmlref{DAT\_COPY}{DAT_COPY}.
   }
}
\sstroutine{
   DAT\_TUNE
}{
   Set HDS parameter
}{
   \sstdescription{
      Specify a value for an HDS control parameter.
   }
   \sstinvocation{
      CALL DAT\_TUNE( PARAM, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER \astar\ ( \astar\ ) (Given)
      }{
         Parameter name.
      }
      \sstsubsection{
         VALUE = INTEGER (Given)
      }{
         Parameter value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine is obsolete -- \htmlref{HDS\_TUNE}{HDS_TUNE} should be used instead.
   }
}
\sstroutine{
   HDS\_CLOSE
}{
   Close container file
}{
   \sstdescription{
      \htmlref{Annul}{sect:annul} the \htmlref{locator}{sect:locators} associated with the top-level object in a
      container file, decrement the container file \htmlref{reference count}{sect:refct} by
      one and close the file if the reference count reaches zero. If
      the file is closed, all other locators associated with it (both
      \htmlref{primary and secondary}{sect:primary}) will also be annulled.
   }
   \sstinvocation{
      CALL HDS\_CLOSE( LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER \astar\ ( DAT\_\_SZLOC ) (Given)
      }{
         Locator to the container file's top-level object.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine is obsolete -- its behaviour is flawed because it
      does not recognise that some top-level locators are not
      associated with a container file reference count (those created
      with \htmlref{DAT\_CLONE}{DAT_CLONE}, for instance). HDS\_CLOSE will always decrement
      the reference count and, hence, may close a container file while
      it is still in use via other locators. The dependence on
      top-level locators to hold a container file open has been
      superceded by the more general primary/secondary locator
      attribute (see \htmlref{DAT\_PRMRY}{DAT_PRMRY}) and the role previously played by
      HDS\_CLOSE is now incorporated in \htmlref{DAT\_ANNUL}{DAT_ANNUL}.
   }
}
\sstroutine{
   HDS\_RUN
}{
   Run an HDS application subroutine
}{
   \sstdescription{
      This routine starts up HDS, runs an application subroutine which
      uses HDS, and then closes HDS down again.
   }
   \sstinvocation{
      CALL HDS\_RUN( APP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         APP = SUBROUTINE (Given)
      }{
         The subroutine to be executed.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine is obsolete as HDS is now self-starting. The
      application subroutine can therefore be called directly.
   }
}
\sstroutine{
   HDS\_START
}{
   Start up HDS
}{
   \sstdescription{
      This routine should be called to start up HDS prior to making
      calls to other HDS routines. It ensures that HDS is active,
      returning without action if it is already active.
   }
   \sstinvocation{
      CALL HDS\_START( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine is now obsolete, as HDS starts itself up
      automatically when required.
   }
}
\normalsize

\newpage
\section{\xlabel{c_api}\label{appendix:capi}CALLING HDS FROM C}

The C interface for the HDS library is defined within file
\texttt{\$STARLINK\_DIR/include/star/hds.h}. There is a one-to-one
correspondance between each C function and each Fortran routine
described in this document - the Fortran documentation should be consulted
for information about the purpose of each function and the nature of its
arguments.

Within C, each HDS locator is referred to by a pointer to an ``\texttt{
HDSLoc}'', and all such variables \emph{must} be initialised to NULL when
they are declared. Functions that require a locator as input should be
supplied with an ``\texttt{HDSLoc \**}''. Functions that return a locator
as output should be supplied with an ``\texttt{HDSLoc \**\**}'' (i.e. the
address of an ``\texttt{HDSLoc \**}''):

\begin{small}
\begin{terminalv}
#include "star/hds.h"
...
HDSLoc *loc = NULL;
HDSLoc *cloc = NULL;
int status;
...
hdsOpen( "fred.sdf", "READ", &loc, &status );
datFind( loc, "DATA", &cloc, &status );
...
datAnnul( &cloc, status );
datAnnul( &loc, status );
\end{terminalv}
\end{small}

Each C function returns the integer status value as the function value in
addition to returning it in the usual manner via the inherited status
variable. In most cases, the returned function value will be ignored, as
in the above example.

The C API includes the following three extra functions to manage the
locking of HDS Locators by specific threads:

\newpage
\small
\sstroutine{
   datLock
}{
   Lock an object for exclusive use by the current thread
}{
   \sstdescription{
      This function locks an HDS object for use by the current thread.
      An object can be locked for read-only access or read-write access.
      Multiple threads can lock an object simultaneously for read-only
      access, but only one thread can lock an object for read-write access
      at any one time. Use of any HDS function that may modify the object
      will fail with an error unless the thread has locked the object for
      read-write access. Use of an HDS function that cannot modify the
      object will fail with an error unless the thread has locked the
      object (in this case the lock can be either for read-only or
      read-write access).

      If \texttt{"} readonly\texttt{"}  is zero (indicating the current thread wants to
      modify the object), this function will report an error if any
      other thread currently has a lock (read-only or read-write) on
      the object.

      If \texttt{"} readonly\texttt{"}  is non-zero (indicating the current thread wants
      read-only access to the object), this function will report an error
      only if another thread currently has a read-write lock on the object.

      If the object is a structure, each component object will have its
      own lock, which is independent of the lock on the parent object. A
      component object and its parent can be locked by different threads.
      However, as a convenience function this function allows all
      component objects to be locked in addition to the supplied object
      (see \texttt{"} recurs\texttt{"} ).

      The current thread must unlock the object using datUnlock before it
      can be locked for use by another thread. All objects are initially
      locked by the current thread when they are created. The type of
      access available to the object (\texttt{"} Read\texttt{"} , \texttt{"} Write\texttt{"}  or \texttt{"} Update\texttt{"} )
      determines the type of the initial lock. For pre-existing objects,
      this is determined by the access mode specified when calling hdsOpen.
      For new and temporary objects, the initial lock is always a read-write
      lock.
   }
   \sstinvocation{
      datLock( HDSLoc $*$locator, int recurs, int readonly, int $*$status );
   }
   \sstarguments{
      \sstsubsection{
         locator = HDSLoc $*$ (Given)
      }{
         Locator to the object that is to be locked.
      }
      \sstsubsection{
         recurs = int (Given)
      }{
         If the supplied object is locked successfully, and \texttt{"} recurs\texttt{"}  is
         non-zero, then an attempt is made to lock any component objects
         contained within the supplied object. An error is reported if
         any components cannot be locked due to them being locked already
         by a different thread. This operation is recursive - any children
         of the child components are also locked, etc.
      }
      \sstsubsection{
         readonly = int (Given)
      }{
         If non-zero, the object (and child objects if \texttt{"} recurs\texttt{"}  is non-zero)
         is locked for read-only access. Otherwise it is locked for
         read-write access.
      }
      \sstsubsection{
         status = int$*$ (Given and Returned)
      }{
         Pointer to global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
          An error will be reported if the supplied object is currently
         locked by another thread. If \texttt{"} recurs\texttt{"}  is non-zero, an error is
         also reported if any component objects contained within the
         supplied object are locked by other threads.

         \sstitem
          The majority of HDS functions will report an error if the object
         supplied to the function has not been locked for use by the calling
         thread. The exceptions are the functions that manage these locks -
         datLock, datUnlock and datLocked.

         \sstitem
          Attempting to lock an object that is already locked by the
         current thread will change the type of lock (read-only or
         read-write) if the lock types differ, but will otherwise have no
         effect.
      }
   }
}
\sstroutine{
   datLocked
}{
   See if an object is locked
}{
   \sstdescription{
      This function returns a value that indicates if the object
      specified by the supplied locator has been locked for use by one or
      more threads. A thread can lock an object either for read-only
      access or for read-write access. The lock management functions
      (datLock and datUnlock) will ensure that any thread that requests
      and is given a read-write lock will have exclusive access to the
      object - no other locks of either type will be issued to other
      threads until the first thread releases the read-write lock using
      datUnlock. If a thread requests and is given a read-only lock, the
      lock management functions may issue read-only locks to other
      threads, but it will also ensure that no other thread is granted
      a read-write lock until all read-only locks have been released.
   }
   \sstinvocation{
      locked = datLocked( const HDSLoc $*$locator, int recursive, int $*$status );
   }
   \sstarguments{
      \sstsubsection{
         locator = const HDSLoc $*$ (Given)
      }{
         A locator for the object to be checked.
      }
      \sstsubsection{
         recursive = int (Given)
      }{
         If non-zero, then all descendants of the supplied object are
         also checked in the same way.
      }
      \sstsubsection{
         status = int$*$ (Given and Returned)
      }{
         Pointer to global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
          The locking performed by datLock, datUnlock and datLocked is
         based on POSIX threads, and has no connection with the locking
         referred to in hdsLock and hdsFree.

         \sstitem
          Zero is returned as the function value if an error has already
         occurred, or if an error occurs in this function.
      }
   }
   \sstdiytopic{
      Returned function value
   }{
       A value indicating the status of the supplied Object:

      \sstitemlist{

         \sstitem
          1: the application is is linked with a version of HDS that does
             not support object locking.

      }
       0: the supplied object is unlocked. If \texttt{"} recursive\texttt{"}  is non-zero,
          then all descendant objects are also unlocked, and this is then
          the condition that must be met for the current thread to be able
          to lock the supplied object for read-write access using function
          datLock. This condition can be achieved by releasing any existing
          locks using datUnlock.

       1: the supplied object is locked for reading and writing by the
          current thread. This is the condition that must be met for the current
          thread to be able to use the supplied object in any HDS function
          that might modify the object (except for the locking and unlocking
          functions - see below). If \texttt{"} recursive\texttt{"}  is non-zero, then all
          descendant objects are also locked for reading and writing. This
          condition can be achieved by calling datLock.

       2: the supplied object is locked for reading and writing by a different
          thread. An error will be reported if the current thread attempts to
          use the object in any other HDS function. If \texttt{"} recursive\texttt{"}  is non-zero,
          then either the object itself or one of its descendant objects is
          locked for reading and writing.

       3: the supplied object is locked read-only by the current thread
          (and maybe other threads as well). If \texttt{"} recursive\texttt{"}  is non-zero,
          then all descendant objects are also locked read-only by the
          current thread. This is the condition that must be met for the
          current thread to be able to use the supplied object in any HDS
          function that cannot modify the object. An error will be
          reported if the current thread attempts to use the object in any
          HDS function that could modify the object. This condition can be
          achieved by calling datLock.

       4: the supplied object is not locked by the current thread, but is
          locked read-only by one or more other threads. An error will be
          reported if the current thread attempts to use the object in any
          other HDS function. If \texttt{"} recursive\texttt{"}   is non-zero, then all
          descendant objects are also locked read-only by one or more
          other threads.

       5: Some complex mix of locked and unlocked descendants not covered by
          any of the above values.
   }
}
\sstroutine{
   datUnlock
}{
   Unlock an object so that it can be locked by a different thread
}{
   \sstdescription{
      This function removes a lock on the supplied HDS object. An error
      is reported if the object is not locked by the current thread. If
      \texttt{"} recurs\texttt{"}  is non-zero, an error will be reported if any child component
      within the supplied object is not locked by the current thread. See
      datLock.

      The object must be locked again, using datLock, before it can be
      used by any other HDS function. All objects are initially
      locked by the current thread when they are created.
   }
   \sstinvocation{
      datUnlock( HDSLoc $*$locator, int recurs, int $*$status );
   }
   \sstarguments{
      \sstsubsection{
         locator = HDSLoc $*$ (Given)
      }{
         Locator to the object that is to be unlocked.
      }
      \sstsubsection{
         recurs = int (Given)
      }{
         If the supplied object is unlocked successfully, and \texttt{"} recurs\texttt{"}  is
         non-zero, then an attempt is made to unlock any component objects
         contained within the supplied object.
      }
      \sstsubsection{
         status = int$*$ (Given and Returned)
      }{
         Pointer to global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
          The majority of HDS functions will report an error if the object
         supplied to the function has not been locked for use by the calling
         thread. The exceptions are the functions datLock and datLocked.
      }
   }
}
\normalsize


\newpage
\section{\xlabel{error_codes}\label{appendix:errors}ERROR CODES}

\subsection{Error Code Descriptions}

An error status value (not equal to SAI\_\_OK) is returned by any HDS routine
which detects an error condition. If a program is to perform specific tests on
these status values, then the HDS-supplied symbolic names described below
should be used rather than explicit numerical values. These symbolic status
names are prefixed either with `DAT' (for error codes returned by the DAT\_ and
HDS\_ routines) or `CMP' (for error codes returned by the CMP\_ routines) and a
double underscore. The appropriate symbol definitions are contained in the
include files DAT\_ERR (for the DAT\_\_ error codes) and CMP\_ERR (for the
CMP\_\_ error codes). The symbols defined in these two files are shown in the
following tables and described in more detail below.

\small
\begin{center}
\xlabel{table_of_HDS_error_codes}
\begin{tabular}{|l|l|} \hline
\st{Symbolic Name} & \st{Meaning}\\ \hline \hline
\textbf{DAT\_\_ACCON} & Access conflict\\
\textbf{DAT\_\_BOUND} & Outside bounds of object\\
\textbf{DAT\_\_COMEX} & Component already exists\\
\textbf{DAT\_\_CONER} & Conversion error\\
\textbf{DAT\_\_DELIN} & Deletion invalid\\
\textbf{DAT\_\_DIMIN} & Dimensions invalid\\
\textbf{DAT\_\_FATAL} & Fatal internal error\\
\textbf{DAT\_\_FILCK} & File locking error\\
\textbf{DAT\_\_FILCL} & File close error\\
\textbf{DAT\_\_FILCR} & File create error\\
\textbf{DAT\_\_FILIN} & File invalid\\
\textbf{DAT\_\_FILMP} & File mapping error\\
\textbf{DAT\_\_FILND} & File not deleted\\
\textbf{DAT\_\_FILNF} & File not found\\
\textbf{DAT\_\_FILNX} & File not extended\\
\textbf{DAT\_\_FILPR} & File protected\\
\textbf{DAT\_\_FILRD} & File read error\\
\textbf{DAT\_\_FILWR} & File write error\\
\textbf{DAT\_\_GRPIN} & Group invalid\\
\textbf{DAT\_\_INCHK} & Integrity check\\
\textbf{DAT\_\_ISMAP} & Data currently mapped\\
\textbf{DAT\_\_LOCIN} & Locator invalid\\
\textbf{DAT\_\_MODIN} & Mode invalid\\
\textbf{DAT\_\_NAMIN} & Name invalid\\
\textbf{DAT\_\_NOMEM} & Insufficient memory available\\
\textbf{DAT\_\_OBJIN} & Object invalid\\
\textbf{DAT\_\_OBJNF} & Object not found\\
\textbf{DAT\_\_PRMAP} & Primitive data mapped\\
\textbf{DAT\_\_SUBIN} & Subscripts invalid\\
\textbf{DAT\_\_TRUNC} & Text truncated\\
\textbf{DAT\_\_TYPIN} & Type invalid\\
\textbf{DAT\_\_UNSET} & Primitive data undefined\\
\textbf{DAT\_\_VERMM} & Version mismatch\\
\textbf{DAT\_\_WLDIN} & Wild-card search context invalid \\
\hline
\end{tabular}
\end{center}
\begin{center}
\begin{tabular}{|l|l|} \hline
\st{Symbolic Name} & \st{Meaning}\\ \hline \hline
\textbf{CMP\_\_DIMIN} & Dimensions invalid\\
\textbf{CMP\_\_FATAL} & Fatal internal error\\
\textbf{CMP\_\_ISMAP} & Data currently mapped\\
\textbf{CMP\_\_NOMAP} & Not mapped\\
\textbf{CMP\_\_TYPIN} & Type invalid\\[2ex]
\hline
\end{tabular}
\end{center}
\normalsize

\begin{description}

\item [ACCON:]
A write operation has been rejected because the container file was originally
opened for read-only access.

\item [BOUND:]
An array specification is outside the permitted dimension bounds.

\item [COMEX:]
An attempt to create a new component of a structure has failed because a
component of the same \htmlref{name}{sect:name} already exists.

\item [CONER:]
One of the following primitive data conversion errors occurred during a
GET, PUT, MAP or UNMAP operation:

\begin{itemize}

\item Floating point overflow.

\item Integer overflow.

\item Truncation of non-blank characters in a character string.

\end{itemize}

\item [DELIN:]
The object to be deleted was a non-empty structure.

\item [DIMIN:]
One of the following conditions occurred:

\begin{itemize}

\item When creating an object, the number of dimensions specified exceeds the
system-imposed limit (currently 7) or is negative, or one or more of the
dimension sizes is zero or negative.

\item When slicing an object, the number of dimensions specified exceeds the
system-imposed limit (currently 3) or is negative, or an incorrect number of
lower and upper bounds has been specified.

\item An attempt to read, write, or map primitive data has failed because the
dimensions specified do not match the actual \htmlref{shape}{sect:shape} of the object.

\end{itemize}

\item [FATAL:]
An unrecoverable error has been detected by HDS. This may indicate an internal
programming error within HDS itself, but may also result from the use of a
corrupt container file. The associated error report will contain further
information about the nature of the error.

\item [FILCK:]
An attempt to lock a container file has failed. This is most likely to be
because another process currently has the file locked with a conflicting access
mode.

\item [FILCL:]
An error occurred while closing an HDS file.

\item [FILCR:]
An error occurred while creating an HDS file.

\item [FILMP:]
An error occurred while mapping data in an HDS file.

\item [FILND:]
An error occurred while deleting an HDS file.

\item [FILNX:]
An error occurred while extending the size of an HDS file.

\item [FILIN:]
One of the following conditions occurred:
\begin{itemize}

\item A file to be opened does not conform to the structure of an HDS container
file.

\item The name given for a file to be created matches the name of a file which
is already in use by HDS.

\item The name given for a file to be created matches the name of an existing
file which cannot be removed because it is not a regular file (it may be a
directory, for instance).

\end{itemize}

\item [FILNF:]
The specified file cannot be found, or the syntax of the file name has been
rejected as invalid by the host operating system.

\item [FILPR:]
The file is protected from being accessed in the specified mode (or from being
deleted).

\item [FILRD:]
An error occurred while reading data from an HDS file.

\item [FILWR:]
An error occurred while writing data to an HDS file.

\item [GRPIN:]
The supplied character string does not conform to the syntax of a \htmlref{group}{sect:group}
specification.

\item [INCHK:]
Typically, an attempt to access an object has failed because the object has
been deleted or moved through another \htmlref{locator}{sect:locators}, either in the same program or in
another process. This error may also be produced through the use of a corrupt
container file.

\item [ISMAP:]
An object is currently mapped.

\item [LOCIN:]
One of the following conditions occurred:

\begin{itemize}
\item A non-character variable has been specified as a \htmlref{locator}{sect:locators} (or a character
variable of the wrong length).

\item The specified \htmlref{locator}{sect:locators} is not currently valid, \st{i.e.}\ not associated
with an object.

\item The specified \htmlref{locator}{sect:locators} was generated by an HDS routine which did not run
to successful completion.

\end{itemize}

\item [MODIN:]
The supplied character string is not a valid access mode.

\item [NAMIN:]
The supplied character string does not conform to the syntax of a \htmlref{name}{sect:name}
specification.

\item [NOMEM:]
HDS was unable to dynamically allocate sufficient memory to perform the
requested operation.

\item [OBJIN:]
An input \htmlref{locator}{sect:locators} points to an object which is not suitable for the type of
operation requested. Specifically, when the locator is associated with one of
the following:

\begin{itemize}

\item A structure object where a primitive is required (and vice versa).

\item An n-D object where a scalar (or cell) is required.

\item A slice or cell of an n-D object where the complete array is required.

\item A top-level object where a component object is required (and vice versa).

\end{itemize}

\item [OBJNF:]
A request to locate a component of a structure, by \htmlref{name}{sect:name} or position, has failed
because the object does not exist.

\item [PRMAP:]
A GET, PUT or MAP operation has been rejected because primitive data are
currently mapped to the specified \htmlref{locator}{sect:locators}.

\item [SUBIN:]
An attempt to locate a slice or cell of an n-D object has failed because the
subscript information references an element which is outside the array bounds
of the object (or a lower bound exceeds an upper bound).

\item [TRUNC:]
A character string has been corrupted through the truncation of significant
(non-blank) characters. Typically this indicates that a program has not
supplied a character string of sufficient length as an argument to an HDS
routine.

\item [TYPIN:]
The supplied character string does not conform to the syntax of a
\htmlref{type}{sect:type} specification.

\item [UNSET:]
An attempt to read primitive object data has failed because the values are
currently undefined.

\item [VERMM:]
The HDS file format version number of a container file exceeds the version
number recognised by the HDS software. Typically, this signifies that the file
has been created or modified by a new version of HDS and cannot be handled by a
program linked with an older version.

\item [WLDIN:]
The wild-card search context identifier supplied has not been generated by a
previous successful call to an HDS routine and is not equal to the null value
(DAT\_\_NOWLD).

\end{description}

\subsection{Obsolete Error Codes}
The following error codes are no longer used by HDS, although their values
remain defined:

\begin{center}
\begin{tabular}{l}
\textbf{DAT\_\_ACTIV}\\
\textbf{DAT\_\_CONIN}\\
\textbf{DAT\_\_ERACT}\\
\textbf{DAT\_\_EREXH}\\
\textbf{DAT\_\_EXCPA}\\
\textbf{DAT\_\_ISOPN}\\
\textbf{DAT\_\_RELIN}\\
\textbf{DAT\_\_STKOF}\\
\textbf{DAT\_\_UNKPA}\\
\textbf{DAT\_\_WEIRD}
\end{tabular}
\end{center}

\newpage
\section{\xlabel{machine_dependencies}MACHINE-DEPENDENT FEATURES}

Although the implementations of HDS on different computer systems have
been made as similar as possible, there are necessarily some
differences in behaviour (especially compared to earlier VAX/VMS
implementations) due to the underlying operating system. This appendix
describes the behaviour for the operating systems on which HDS is
currently supported.

\subsection{\xlabel{file_naming}\label{sect:system_files}File Naming}

This section describes the naming rules for files when opening
individual HDS container files. The rules used when searching for
container files using the \qt{wild-carding} facilities provided by
\htmlref{HDS\_WILD}{HDS_WILD} differ slightly (see \S\ref{sect:system_wild}).

File names may contain characters of either case on UNIX systems and
HDS therefore does not perform any case conversion on file names. All
leading and trailing white space on file names is ignored.

If a file name does not have an extension (\st{i.e.}\ does not have a
period in the last field of its UNIX pathname), then HDS provides a
default extension by appending `.sdf' to the name. This occurs both
when searching for existing files and when creating new ones. To make
it possible to create file names without a period if required, HDS
will also remove exactly one period (if present) from the end of a
file name before using it.

If a file name contains any \qt{special} characters\footnote{That is,
anything except alphanumeric characters, slash `/', period `.',
underscore `\_' and minus `$-$'.} and the value of the SHELL tuning
parameter (\S\ref{sect:tuning_parameters}) indicates that a shell is
to be used for interpreting such file names, then the name will be
passed to a process running the required shell for expansion before
use. Thus any shell expression resulting in a valid file name may be
used, such as:

\begin{small}
\begin{terminalv}
$MY_DIR/datafile
/reduce/data
`cat myfilelist`
\end{terminalv}
\end{small}

(the precise syntax and capabilities depending on which shell is
selected). The actual algorithm used for expanding file names is
described in \S\ref{sect:system_wild}. If expansion results in more
than one file name, then only the first one is used.

There are no file version numbers on UNIX systems. If an existing file
name is given as the name of a new output file, then the original file
will be over-written. It is an error to specify a file which has
already been opened by HDS (\st{e.g.}\ for input) as the name of a
new output file.

\subsection{\xlabel{wild_card_file_searching}\label{sect:system_wild}Wild-Card File Searching}

When searching for HDS container files using the \qt{wild-card}
facilities provided by \htmlref{HDS\_WILD}{HDS_WILD} and
\htmlref{HDS\_EWILD}{HDS_EWILD}, the following rules apply.

Since traditional UNIX systems do not generally provide callable
pattern-matching facilities for finding files, nor do they support the
concept of default file type extensions, HDS implements these by
passing wild-card file names to a shell process and expanding them
using the following algorithm:

\begin{enumerate}

\item
The string supplied (which may also be a list of files or file
specifications separated by white space) is first expanded with the
shell's file name expansion facility turned off. This performs
operations such as environment variable substitution and execution of
embedded shell commands, but leaves pattern-matching characters in
place.

\item
The resulting string is then scanned as a list of file specifications
separated by white space.

\item
If any element of this list does not contain a file type extension, as
indicated by the absence of a period in the final field (fields being
separated by slash characters `/'), then an extension of `.sdf' is
appended to it. If an element initially ends in a period, then this is
removed and no extension is added. This stage performs file type
defaulting on all elements of the list consistent with the rules
applied to individual file names (\S\ref{sect:system_files}).

\item
The resulting list of file specifications is then expanded with the
shell's file name expansion facility turned on, resulting in the final
list of files.

\end{enumerate}

HDS will further filter the list of files found to exclude any which
appear not to exist, cannot be accessed, or are not valid HDS
container files.

\subsection{\xlabel{file_mapping}\label{sect:system_map}File Mapping}

The \hi{sun4\_Solaris} and \hi{alpha\_OSF1} implementations of HDS
currently provide a choice between the use of file mapping to perform
I/O operations on primitive objects and the use of direct read/write
operations. This is selectable via the `MAP' tuning parameter (see
\S\ref{sect:tuning_parameters}). The default is to use file mapping on
both systems.

Only read/write operations will be supported on other systems,
regardless of the setting of the `MAP' tuning parameter.

\subsection{\xlabel{scratch_files}Scratch Files}

The environment variable HDS\_SCRATCH is used on UNIX systems to
define the directory in which HDS will create scratch container files
to hold temporary objects created with
\htmlref{DAT\_TEMP}{DAT_TEMP}. When creating a scratch file, HDS will
use the file name:

\begin{quote}
\$HDS\_SCRATCH/$<$filename$>$
\end{quote}

where \$HDS\_SCRATCH is the translation of this environment
variable. If HDS\_SCRATCH is undefined, then the file name will be
used alone, so that scratch files will then be created in the current
directory.

\subsection{\xlabel{file_locking}File Locking}

HDS file locking is not currently implemented on UNIX systems. This
means that any number of processes may access a container file
simultaneously. This should not be allowed to happen, however (apart
from shared read access), because modifications to the file will not
be propagated consistently between the file and the separate
processes. The result will be a corrupted container file and/or hung
or crashed processes.

Note that HDS supports access to container files over the Network File
System (NFS), but does not provide file locking.

\newpage
\section{\xlabel{changes_and_new_features}CHANGES AND NEW FEATURES}

\subsection{Changes in V4.1}

The following describes the most significant changes which occurred in HDS
between versions V4.0 and V4.1 (not the current version).

\begin{enumerate}

\item
The C source code of HDS now complies with the ANSI C standard, and
UNIX implementations of HDS use a new \qt{makefile}. Both of these
changes are designed to make it relatively straightforward to
implement HDS on new platforms.

\item
HDS now contains routines which automatically determine the primitive
data representation used by common types of computer hardware
(\st{e.g.} the floating point number format and byte storage
order). This also makes it easier to implement HDS on new platforms,
since changes to the source code are not normally required.

\item
A DECstation implementation of HDS has been added. An implementation
on Silicon Graphics hardware is also in use, although this is not
currently supported by Starlink.

\item
The SUN Sparcstation implementation of HDS now uses file mapping as
its default mode of file access. This can give appreciable performance
gains, largely, it appears, as a result of reduced memory usage which
may allow better buffering of file contents.

\item
The directory in which HDS resides now contains a file called
\hi{hds\_datestamp} which holds information about how the HDS system
was built. This includes details of the primitive data representation
used by the host machine which may sometimes be of use to programmers.

\item
A bug has been fixed which could cause the length of new \_CHAR
objects to exceed the length actually requested. Typically, an extra
digit was being appended to the length as a result of an un-terminated
internal C string.

\item
A bug has been fixed which caused HDS not to recognise primitive data
values written in big-endian IEEE double precision format
(\st{i.e.}\ typically written on a SUN) which have the \qt{bad} data value
due to
a previous format conversion error. The result of this bug was that a
data conversion error could result if the data were read on a machine
(typically a VAX) with a more restricted double precision number
range. The correct behaviour is for the bad SUN value to be converted
silently to the corresponding bad VAX value. This now occurs.

\item
A bug has been fixed which could corrupt a mapped slice of a primitive
object because only a single byte of data was being transferred for
the final element.  This could happen both when reading and writing
the data, although not in all circumstances.

\item
A problem has been fixed which typically resulted in \qt{bus errors}
on SUN systems when attempting to access primitive data as double
precision values where format conversion was also required. This
resulted from an inability to handle double precision values passed
from Fortran to C, where the value may be badly aligned in memory
(\st{i.e.}\ on a 4-byte rather than an 8-byte boundary).  This problem
was not always repeatable, in the sense that it depended on where the
Fortran compiler placed the relevant variable in memory.

\item
A workaround has been installed for a problem sometimes encountered
when writing to a file served by a VMS machine using the Network File
System (NFS) from a SUN. Depending on the file size and the amount of
data written, a failure to extend the file can sometimes occur. This
seems to happen only when the new file size requested by the SUN lies
between the current end of file and the physical file size allocated
by VMS as a result of clustering of disk blocks. This problem seems to
have arisen since the previous version of HDS due to changes to the
VMS UCX software. The workaround involves repeating the file extend
call if it fails on the first attempt.

\item
A bug has been fixed in the queue handling facility used internally by
HDS. This could cause regions of memory to be over-written. It is not
clear what adverse consequences this may have had.

\item
An error in the documentation concerning the order in which character
arguments should appear when passing mapped character values using the
\%VAL facility has been corrected (see \S\ref{sect:charmapping}).

\item
The description of the \htmlref{DAT\_BASIC}{DAT_BASIC} routine has
been improved to make it clear that this routine accesses bytes of
primitive data \st{as written}, and does not perform conversion
to/from the data representation of the host machine.

\item
Several minor typos in error messages have been corrected.

\item
Use of the routine \htmlref{HDS\_START}{HDS_START} is no longer
necessary in order to start up HDS before using it. The system is now
self-starting, typically when the first routine which accesses a
\htmlref{locator}{sect:locators} is called. HDS\_START has been documented
as obsolete, but its use remains optional.

\item
Use of the routine \htmlref{HDS\_STOP}{HDS_STOP} at the end of a
program is now optional, since its action will be performed
automatically by an exit handler. Examples showing its use have been
modified appropriately. Note that HDS\_STOP is not obsolete, as it
remains the only method of closing down HDS in the middle of a
program. In practice, the need to do this is likely to be limited.

\item
Since \htmlref{HDS\_START}{HDS_START} and
\htmlref{HDS\_STOP}{HDS_STOP} are now both optional, the routine
\htmlref{HDS\_RUN}{HDS_RUN} no longer serves a useful purpose and has
been documented as obsolete.

\item
The method by which HDS determines how long a container file should be
held open has been rationalised. This no longer depends on the
existence of a \qt{top-level}
\htmlref{locator}{sect:locators}. Instead, the concept of \qt{primary}
and \qt{secondary} locators has been introduced (see
\ref{sect:primary}) and a container file remains open for as long as
at least one primary locator is associated with it.  Any locator may
be designated as primary by means of the new routine
\htmlref{DAT\_PRMRY}{DAT_PRMRY}, thus removing the special status of
top-level locators in this context. Routines which previously
incremented the container file \htmlref{\qt{reference
count}}{sect:refct} now issue primary locators (all other locators are
secondary by default), so that existing behaviour is retained.

This change has been introduced to remove the requirement that all
software using HDS maintain its own table of top-level locators in
order to prevent container files being closed. It also opens the way
for future improvements to the programming interface of HDS, which
should allow objects to be identified by their pathname as well as by
locator.

\item
All routines which \htmlref{annul}{sect:annul}
\htmlref{locators}{sect:locators} will now also close the associated
container file if there are no longer any
\htmlref{primary}{sect:primary} locators associated with it. Any
outstanding secondary locators associated with a closed container file
are now correctly annulled (previously they were simply left
\qt{dangling}). The main implication of this is that
\htmlref{DAT\_ANNUL}{DAT_ANNUL} will now close a container file which
is no longer in use, removing the need to do this explicitly.

\item
As a result of the above changes, the \htmlref{HDS\_CLOSE}{HDS_CLOSE}
routine is now redundant, and has been documented as obsolete. Its
continued use is not recommended. Its behaviour has always been
flawed, since it decrements the reference count for a container file
regardless of whether the top-level \htmlref{locator}{sect:locators} it annuls originally
caused this count to be incremented when it was created. Since several
methods exist for generating top-level locators without incrementing
this count, it is possible for a container file to be prematurely
closed if HDS\_CLOSE is used.

HDS\_CLOSE may still be useful as an emergency measure to close a file
in the presence of a programming error which has left it open.

\item
A new routine \htmlref{DAT\_REFCT}{DAT_REFCT} has been introduced to
return the current reference count for a container file. This makes it
possible to predict when a file will actually be closed.

\item
The temporary limit on the number of simultaneously open container
files imposed in V4.0 of HDS has been removed. HDS now imposes no
restrictions on the number of open files beyond those set by the host
operating system.

\item
On UNIX systems, HDS now reports an error if the name of a container
file which is already in use is given as the name of a new container
file to be created.  This avoids the fairly common problem on UNIX,
where the user of an application supplies the same name for both the
input file and the output file, and ends up with no file at all
because the output over-writes the input before it has been read.

\item
When creating new container files on UNIX systems, HDS will now check
before over-writing an existing file to ensure that it is a regular
file and not a directory or FIFO, \st{etc.} An error results if it is
not a regular file.

\item
HDS now consistently ignores all leading and trailing white space on
file names passed to it.

\item
On UNIX systems, HDS now uses the full (absolute) pathnames of all
files when referring to them in messages and when returning file names
\st{via} routine arguments.

\item
On UNIX systems, HDS will now pass file names which contain
\qt{special} characters (anything except alphanumerics, `.', `/', `-'
and `\_') to a shell for interpretation. This means that normal UNIX
shell syntax may be used to construct file names, thus allowing
environment variable expansion, \st{etc.}  In fact, any shell command
can, in principle, be used to construct a file name.  Pattern-matching
characters are also accepted -- if more than one file matches, then
the first match is used.

\item
Two new routines \htmlref{HDS\_WILD}{HDS_WILD} and
\htmlref{HDS\_EWILD}{HDS_EWILD} have been introduced to permit
\qt{wild-card} searching for HDS container files specified using
pattern-matching characters.

\item
A new tuning parameter `SHELL' has been introduced (see
\ref{sect:tuning_parameters}) to allow a choice of which UNIX shell is
used to interpret file names (this includes wild-carding of file names
using \htmlref{HDS\_WILD}{HDS_WILD} and
\htmlref{HDS\_EWILD}{HDS_EWILD}). By default, the \qt{sh} shell is
used but, if available, the \qt{csh} and \qt{tcsh} shells may also be
selected. It is also possible to turn shell expansion of file names
off.

\item
It is now possible to modify the default tuning profile of HDS by
means of environment variables, which are read and interpreted by HDS
at startup (see \S\ref{sect:tuning}). For instance, the definition:

\begin{small}
\begin{terminalv}
setenv HDS_MAP 0
\end{terminalv}
\end{small}

could be used to disable file mapping in favour of I/O in any
application which uses HDS.

\item
A call to \htmlref{HDS\_GTUNE}{HDS_GTUNE} will now only return the
value 1 for the `MAP' tuning parameter (corresponding to file mapping
being used as the file access mode) if this mode has previously been
requested and if it is actually implemented on the host machine. This
makes it possible for the caller to determine whether file mapping is
implemented or not.

\item
Three new special values ($-$1, $-$2 and $-$3) may now be given for
the `MAP' tuning parameter in order to select the file access mode
best suited for a given type of access. These options select (in
order) the file access method which gives fastest sequential access,
fastest random (sparse) access, or minimum usage of memory (see
\ref{sect:tuning_parameters}). The value returned by
\htmlref{HDS\_GTUNE}{HDS_GTUNE} may be used to determine which file
access mode was actually selected, as this will depend on the host
operating system.

\item
Some of the values returned by the routine
\htmlref{DAT\_CLEN}{DAT_CLEN} describing the number of digits required
to format floating point numbers have been changed to reflect the
recommendations of the IEEE floating point standard.

\item
The \htmlref{HDS\_SHOW}{HDS_SHOW} routine now has a new `DATA' option
which displays details of the primitive data representation in use by
the host machine.

\item
Internal changes have been made which allow HDS \qt{container records}
(which contain information about the components which reside within an
HDS structure) to be reduced in size when components are erased. Some
hysteresis is allowed in this process. This typically gives a slight
performance improvement and saves a little file space.

\item
The NBLOCKS tuning parameter is now actually used at several places
within HDS.  Previously its value had no effect.

\item
A new script called \hi{hds\_dev} has been provided on UNIX systems
to create and remove symbolic links to the HDS public include files
within the current directory. This allows the same INCLUDE statements
to be used in Fortran code on both UNIX and VMS systems.

\item
The new error code DAT\_\_WLDIN and the symbolic constant DAT\_\_NOWLD
have been introduced.

\item
This document (SUN/92) has been updated and produced using a larger
font.

\end{enumerate}

\subsection{Changes in V4.2}

The following describes the most significant changes which occurred in HDS
between versions V4.1 and V4.2 (not the current version).

\begin{enumerate}

\item Support for the VAX/VMS operating system has been discontinued
at this version of HDS and all references to VMS usage have been
dropped from this document.

A VAX/VMS implementation of HDS V4.1 remains in operation and
continues to be supported by Starlink on a \qt{care and maintenance}
basis, but as a separate entity. This means that the following and
future additions to HDS will not be applied to the VAX/VMS
version. Users of HDS on VAX/VMS should refer to the documentation
that accompanies it for information, and not to this document.

\item The OSF1 (Digital UNIX) implementation of HDS now supports file
mapping. This should improve the performance of those applications
that can take advantage of it.

\item HDS now allows container files that are marked for deletion to
be re-opened for use, so long as they have not yet been closed (and
therefore deleted). This facility was found to be necessary to support
foreign data file access in the NDF library (\xref{SSN/20}{ssn20}{}).

\item Due to the introduction of various new POSIX facilities on OSF1
(Digital UNIX) and associated compiler flags, some untested code was
being compiled and used on this platform. The result was that file
specifications containing \qt{wild-carding} characters could not be
used and the \htmlref{HDS\_WILD}{HDS_WILD} routine did not function
correctly in recent un-tested distributions of HDS for OSF1. These
problems have now been fixed.

\item A bug has been fixed which meant that the
\htmlref{HDS\_WILD}{HDS_WILD} routine would not function correctly if
it was the first HDS routine to be called in an HDS application. A
call to \htmlref{HDS\_START}{HDS_START} would prevent this problem
occurring, but is now no longer necessary.

\item A bug has been fixed which could result in objects accessed for
modification using file mapping to be written back to their container
files using a \hi{write} call (instead of unmapping the file) if the
`MAP' tuning parameter was changed between calls to
\htmlref{DAT\_MAP}{DAT_MAP} (or equivalent) and
\htmlref{DAT\_ANNUL}{DAT_ANNUL} (or equivalent). This problem did not
occur if \htmlref{DAT\_UNMAP}{DAT_UNMAP} was called to unmap the data
explicitly. Surprisingly, this erroneous behaviour almost always gave
the correct result, but could very occasionally result in a core dump.

\item A bug has been fixed that could corrupt data in the immediate
neighbourhood of a primitive object slice whose value was
updated. This could only happen in rare circumstances and was normally
limited to slices no more than 32 bytes in length.

\item Certain error messages that are often the result of an attempt
to access a corrupt HDS container file have been modified to
explicitly give the affected file name.

\item The HDS makefile has been extensively revised. Amongst other
things, this is to permit automatic distribution \st{via} the
\st{Starlink Software Store} on the World Wide Web.

\item This document (SUN/92) has been revised and is now available in
both Latex and hypertext (HTML) forms.

\item The HDS implementations on SunOS and Ultrix systems have been
superceded by Solaris and OSF1 implementations respectively (the
latter now being called Digital UNIX). The code to support these (and
other) earlier implementations of HDS has been retained, and may be of
use to those wishing to port HDS back to these platforms. However, it
is no longer supported on these systems by Starlink and has not
recently been built or tested on them.  An Open~VMS implementation of
HDS running on Dec Alpha workstations is also known to exist, but is
not supported by Starlink.

Further information about old or unsupported implementations of HDS
may be obtained by contacting Starlink Software Support
(stardev@jiscmail.ac.uk)

\end{enumerate}

\newpage
\subsection{\xlabel{list_of_most_recent_changes}Changes in V4.3}

The following describes the most significant changes which occurred in HDS
between versions V4.2 and V4.3 (the current version).

\begin{enumerate}
\item A change has been made to the way that data pointers are
allocated by HDS, so that the new \xref{CNF\_PVAL}{sun209}{CNF_PVAL}
function (described in \xref{SUN/209}{sun209}{}) may be used when
passing pointers using the \qt{\%VAL} facility (see
\S\ref{sect:mapping}). Use of this function remains optional on
currently-supported platforms, but it may be required if Fortran
software which holds pointers in INTEGER variables is required to run
in circumstances where memory pointers require a longer variable for
storage.

Use of CNF\_PVAL is recommended in all new Fortran software which uses
HDS pointers.

\item The maximum number of objects which may be simultaneously mapped
via CMP\_ routines has been increased to 1024.

\item This document (\xref{SUN/92}{sun92}{}) has been updated to
reflect the above changes.
\end{enumerate}

\newpage
\subsection{\xlabel{list_of_most_recent_changes}Changes in V6.0}

\begin{enumerate}
\item The entire HDS library has been re-implemented to support HDS files that
use the HDF5 data format. The library can read and write both old (V4) and new
(V5) formats. By default, new files are created using the old V4 format,
but this can be changed using the new ``VERSION'' tuning parameter. Note,
the default output format will change to V5 in a future release.

\item New functions (datock, datUnlock and datLocked) have been added to the
C interface to allow an HDS object to be locked for exclusive use by a single
thread. An error is reported if a thread attempts to make a change to an
object that it has not previously locked for its own exclusive use. By
defaults objects are locked by the thread that creates them.
\end{enumerate}

\end{document}
