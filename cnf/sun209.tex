\documentclass[twoside,11pt,nolof]{starlink}

% -----------------------------------------------------------------------------
\stardoccategory    {Starlink User Note}
\stardocinitials    {SUN}
\stardocsource      {sun\stardocnumber}
\stardocnumber      {209.11}
\stardocauthors   {P.M.\ Allan\\
                                A.J.\ Chipperfield\\
                                R.F.\ Warren-Smith\\
                                P.W.\ Draper\\
                                D.S.\ Berry}
\stardocdate        {12 May 2011}
\stardoctitle     {CNF and F77\linebreak Mixed Language Programming -- FORTRAN and C}
\stardocversion     {Version 4.3}
\stardocmanual      {Programmer's Manual}
\stardocabstract  {
The CNF package comprises two sets of software which ease the task of writing
portable programs in a mixture of FORTRAN and C\@.
F77 is a set of C macros for handling the FORTRAN/C subroutine linkage in a
portable way, and CNF is a set of functions to handle the difference between
FORTRAN and C character strings, logical values and pointers to
dynamically allocated memory.}
% -----------------------------------------------------------------------------

\newcounter{examples}

% Define a table for use in examples
\providecommand{\sstexamplestable}[1]{\begin{tabular}{ll}
                              #1
                              \end{tabular}
                             }
\providecommand{\sstexamplestableentry}[2]{#1 & {\texttt{#2}}}

% command to do xlabel and label in the sstroutinenolabel commands
% (These are the commands that put formatting in the title
% of the macro, so it can't be automatically used as a label)
\newcommand{\relabel}[1]{\xlabel{#1}\label{#1}}


% Define layout of brief listing sections.
\providecommand{\routinelist}[1]{\small
                             \begin{description} #1 \end{description}
                             \normalsize
                            }
\providecommand{\listroutine}[2]{\item[\htmlref{#1}{#1}]
                             \hspace*{\fill} \nopagebreak
                             \subitem \emph{#2} \hspace*{\fill}
                            }
\providecommand{\listgenroutine}[3]{\item[\htmlref{#1}{#3}]
                             \hspace*{\fill} \nopagebreak
                             \subitem \emph{#2} \hspace*{\fill}
                            }

% -----------------------------------------------------------------------------

\begin{document}
\scfrontmatter

\section{\xlabel{how_to_read_this_document}\label{how_to}How to read this document}

This document tells a programmer how to mix program segments written in FORTRAN
and C\@ \textit{in a portable way}.
It provides information on several levels from a quick ``how to get
started'' cookbook, down to machine-specific details.
The cookbook will tell you how to
write programs, but without much of the background information of what is
really going on. After you have tried a few programs, you will probably want to
read the rest of the document.

Before you embark upon mixed language programming, it may be worth reading the
\htmlref{Rationale for mixed language programming}{rationale}
\latex{ in Appendix~\ref{rationale}} which discusses the problems and
offers some alternatives.

The current system is supported for Sun systems running Solaris, DEC Alphas
running OSF/1, and PC's running Linux but in the past has run successfully on
SunOS, Ultrix and VAX/VMS.
Reference is made to the VAX/VMS system in this document as it is in
many respects very different from the Unix systems and so provides a useful
comparison. You should consult the VMS Starlink documentation set
about the VAX/VMS version however, as not all the facilities described here are
available in it, \textit{even if a VAX/VMS example is given}.

Full descriptions of the C
\htmlref{macros}{f77_description}
and
\htmlref{functions}{cnf_description}
involved are


\latex{provided in appendices \ref{f77_description} and
\ref{cnf_description}.} The macro names in the text will often include the
legend \texttt{\textit{type}} to indicate a generic macro name. In this case,
\texttt{\textit{type}}\/ may normally be one of \texttt{INTEGER},
\texttt{REAL}, \texttt{DOUBLE}, \texttt{LOGICAL} or \texttt{CHARACTER}.
Types \texttt{BYTE} and \texttt{WORD} and their unsigned versions
\texttt{UBYTE} and \texttt{UWORD} are also available but do not correspond to
standard FORTRAN types so should be avoided.
\texttt{\textit{type}} may also be \texttt{POINTER} -- again this is not a
standard FORTRAN type but it is more commonly
\htmlref{used in Starlink software}
{f77_pointers}\latex{ (see Section~\ref{f77_pointers})}.

For consistency with other Starlink libraries the CNF function names were
changed (at Version 4.0) from the form \texttt{cnf\_name} to the form
\texttt{cnfName}.
The old names are still permitted via macros defined in the \texttt{f77.h}
header file.

There is also a section \latex{(\ref{compiling_and_linking})} on
\htmlref{how to compile and link the programs}{compiling_and_linking}.


\section{\xlabel{cookbook}Cookbook}

This section
introduces mixed language programming. It skips over many of the
details and concentrates on how to get programs going. For a fuller explanation
of mixed language programming, you should read the rest of this document.

\subsection{\xlabel{calling_c_from_fortran}\label{cook_f2c}Calling C from FORTRAN}

Why would you want to call a C function from a FORTRAN program? Typically this
will be to do something in the C function that cannot be done from FORTRAN, at
least not in the way that you would like. On account of this, realistic
examples of calling C from FORTRAN can be rather involved. After all, you can
do most simple things from FORTRAN itself. So as not to obscure how to go about
writing mixed language programs with complex C functions, the examples in this
section concentrate on what to do when mixing C and FORTRAN rather than on
providing realistic examples of this.

Here is an example of a FORTRAN program that calls a C function which sets
various arguments.

\begin{samepage}
\refstepcounter{examples}
\label{cook_argsf2c}
\begin{center}
Example\latex{~\ref{cook_argsf2c}}
-- Calling C from FORTRAN\@.
\end{center}
FORTRAN program:
\begin{small}
\begin{terminalv}
      PROGRAM COOK1
      INTEGER I,J
      REAL A,B
      CHARACTER*(80) LINE
      LOGICAL X

      I = 1
      A = 5.0
      X = .FALSE.
      LINE = ' '
      CALL SILLY1( A, B, I, J, LINE, LEN(LINE), X )
      PRINT *, LINE

      END
\end{terminalv}
\end{small}
\end{samepage}
C function:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
#include "f77.h"

F77_SUBROUTINE(silly1)( REAL(a), REAL(b), INTEGER(i), INTEGER(j),
  CHARACTER(line), INTEGER(line_l), LOGICAL(x) TRAIL(line) )
{
  GENPTR_REAL(a)
  GENPTR_REAL(b)
  GENPTR_INTEGER(i)
  GENPTR_INTEGER(j)
  GENPTR_CHARACTER(line)
  GENPTR_INTEGER(line_l)
  GENPTR_LOGICAL(x)

  char str[] = "This is a string";

  if( F77_ISTRUE(*x) )
  {
     *b = *a;
     *j = *i;
  }
  else
  {
     cnfExprt( str, line, *line_l );
  }
}
\end{terminalv}
\end{small}

This is a rather silly example, but it does illustrate all of the important
points of calling C from FORTRAN\@. The FORTRAN program is completely standard.
The name of the C function is declared using a macro \texttt{F77\_\-SUBROUTINE}.
Do not leave any spaces around the name of the routine as this can cause
problems on some systems.
The dummy arguments of the function are declared using macros
named after the FORTRAN type of the actual argument. The only odd thing is the
macro called \texttt{TRAIL}.
Each argument of type \texttt{CHARACTER} should have a corresponding
\texttt{TRAIL} added to the end of the argument list. N.B. \texttt{TRAIL}
macros must not have a comma in front of them.
All C functions that are to be called from FORTRAN should be declared in a
similar manner.

There then follows a set of \texttt{GENPTR\_\-\textit{type}}\/ macros; one
for each argument of the function. \texttt{TRAIL} arguments are not counted as
being true arguments and so there are no \texttt{GENPTR} statements for them.
Note that there are no semicolons at the end of these lines.

The only other macro used is \texttt{F77\_\-ISTRUE}.
This should be used whenever an argument is treated as a logical value, and
takes into account the different ways that FORTRAN and C may interpret bit
patterns as logical values.

Note that all explicit function arguments are pointer arguments. This is
necessary if their value is to be modified in the function. The consequence of
this is that scalar arguments must be referred to by \texttt{*\textit{arg}}\/
within the function.

FORTRAN and C store character strings in different ways. FORTRAN stores them as
fixed-length, blank-filled strings while C stores them as variable-length,
null-terminated strings.
If a C function needs to work with character strings that
have been passed from a calling FORTRAN routine, then the FORTRAN string must
be copied into an equivalent local copy. Similarly, a C function may need to
return a string to the calling FORTRAN routine. This is a very common
occurrence, so some
\htmlref{``CNF functions''}{cnf}
are provided to do this.
Essentially they are just C functions which copy a FORTRAN string to a C
string and vice versa.
\latex{(They are more fully described in Section~\ref{cnf}.)}

In the above example, the function \texttt{cnfExprt} copies the C string
\texttt{str} into the FORTRAN string \texttt{line}. Function \texttt{cnfImprt}
performs the converse operation in
\htmlref{``Calling FORTRAN from C''
example}{cook_argsc2f}\latex{ in Section \ref{f_from_c}}.

\subsection{\xlabel{calling_fortran_from_c}\label{f_from_c}Calling FORTRAN from C}

Why would you want to call a FORTRAN subprogram from a C routine? Typically
this would be because you want to use a precompiled library of routines that
were written in FORTRAN\@. The NAG library is a prime example.
This can be bought in a C callable version, but this is not available on
Starlink machines.

To see how to call FORTRAN from C, let us consider the above example, but now
with the roles of FORTRAN and C exchanged.

\refstepcounter{examples}
\label{cook_argsc2f}
\begin{center}
Example\latex{~\ref{cook_argsc2f}}
-- Calling FORTRAN from C\@.
\end{center}
\nopagebreak[4]
C program:
\begin{small}
\begin{terminalv}
#include "f77.h"

#define FLINE_LENGTH 80

extern F77_SUBROUTINE(silly2)( REAL(a), REAL(b), INTEGER(i), INTEGER(j),
  CHARACTER(line), INTEGER(line_l), LOGICAL(x) TRAIL(line) );

main()
{
  DECLARE_INTEGER(i);
  DECLARE_INTEGER(j);
  DECLARE_INTEGER(fline_l);
  DECLARE_REAL(a);
  DECLARE_REAL(b);
  DECLARE_LOGICAL(x);
  DECLARE_CHARACTER(fline,FLINE_LENGTH);

  char line[FLINE_LENGTH+1];

  fline_l = FLINE_LENGTH;

  i = 1;
  a = 5.0;
  x = F77_FALSE;

  F77_CALL(silly2)( REAL_ARG(&a), REAL_ARG(&b), INTEGER_ARG(&i),
    INTEGER_ARG(&j), CHARACTER_ARG(fline), INTEGER_ARG(&fline_l),
    LOGICAL_ARG(&x) TRAIL_ARG(fline) );

  cnfImprt( fline, FLINE_LENGTH, line );

  printf( "%s\n", line );
}
\end{terminalv}
\end{small}
\pagebreak[3]
FORTRAN function:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
      SUBROUTINE SILLY2( A, B, I, J, LINE, LINE_L, X )
      REAL A, B
      INTEGER I, J
      CHARACTER * ( * ) LINE
      INTEGER LINE_L
      LOGICAL X

      IF( X ) THEN
        B = A
        J = I
      ELSE
         LINE = 'This is a string'
      END IF

      END
\end{terminalv}
\end{small}

In the above C main program, the variable \texttt{fline\_l} is declared and set
equal to the constant \texttt{FLINE\_LENGTH}. At first sight this is unnecessary.
However, this is not the case, as we need to pass the value of
\texttt{FLINE\_LENGTH} to the subroutine and it is not possible to pass
constants to FORTRAN subroutines. Only variables can be passed.

\subsection{\xlabel{building_the_program}Building the Program}
The final step is compiling and linking the program.

Suppose, on Unix, the main FORTRAN program is in the file \texttt{cook1.f} and
the C function is in the file \texttt{silly1.c}, then the commands might be:

\begin{terminalv}
% cc -c -I/star/include silly1.c
% f77 cook1.f silly1.o -L/star/lib `cnf_link`
\end{terminalv}

Note that the compiling and linking commands are somewhat machine-specific
-- compiling the FORTRAN routine first and then trying to link the routine
using the \texttt{cc} command generally does not work.
More details are given in
\htmlref{Compiling and Linking}
{compiling_and_linking}\latex{ (see Section~\ref{compiling_and_linking})}.

Armed with the above examples, you should be in a position to start
experimenting with mixed language programming. For further information, read
on.

\section{\xlabel{representation_of_data}Representation of Data}

Different languages have differing fundamental data types on which they can
operate. FORTRAN has the types \texttt{INTEGER}, \texttt{REAL},
\texttt{DOUBLE  PRECISION}, \texttt{COMPLEX}, \texttt{LOGICAL} and
\texttt{CHARACTER}\@. The only aggregate data type that it supports is the
array, although a character variable can store many characters. C supports the
fundamental types \texttt{int}, \texttt{float}, \texttt{double}, \texttt{char},
and \texttt{void}. It also allows \texttt{int} to be modified by the type
specifiers \texttt{short} or \texttt{long}, \texttt{signed} or
\texttt{unsigned}, \texttt{char} to be modified
by \texttt{signed} or \texttt{unsigned} and \texttt{double} to be modified by
\texttt{long}. However, on any given machine, some of the \texttt{short},
normal and \texttt{long} types may be represented in the same way.
C also provides a range of pointer types which may, for purposes of
interchange with FORTRAN, all be condensed into the generic pointer
type \texttt{void*}.
Note that, unlike FORTRAN, a C character variable can only store a single
character.
Also unlike FORTRAN, a C
character variable is treated as a type of integer rather than as a separate
type. Finally, ANSI C has the type \texttt{enum}, an enumerated list of values.
The aggregate data types are the array, structure and union. New types can be
defined in terms of the basic types by means of a \texttt{typedef} statement.

When writing mixed language programs, it is clearly important to know which
FORTRAN types map on to which C types; in particular, which similar types use
the same amount of storage. This is discussed more fully in
\htmlref{the machine dependent sections}{implement}
\latex{in appendix~\ref{implement}}; however, there are some general
points to be considered first.

\subsection{\xlabel{numeric_types}Numeric Types}

If data are to be passed between routines that have been written in different
languages, then it is important that those languages represent the data in the
same way. The FORTRAN standard makes no statements about how any of the data
types should be implemented and there is almost nothing in the C standard
either. For example, if a certain bit pattern was interpreted as the integer
$-2$ by FORTRAN, yet the same bit pattern was interpreted by C as $-1$, then
there are going to be serious problems trying to communicate between routines
written in different languages. Fortunately, the hardware on which the program
is running provides a constraint for those data types that are implemented
directly in the  hardware. For example, all reasonable computers have
instructions for operating on integers and it would be a particularly perverse
compiler writer who chose not to use the hardware representation. Something
that is slightly more likely to be a problem is the way that floating point
numbers are represented. If the hardware supports floating point arithmetic,
then you are in the same situation as for integers and all should be well.
However, if the hardware does not support floating point arithmetic, then there
could be problems. Some older PCs do not have floating point hardware, although
modern PCs either support floating point operations directly in hardware, or
there is a recognised way of representing floating point numbers that is
generally adhered to. The bottom line on numerical data types is that it is
most unlikely that different languages will represent the same number in a
different manner on the same hardware.

\subsection{\xlabel{characters}Characters}

When considering character data, things are a bit more complicated in that the
hardware does not impose a meaning on a given bit pattern. It is the operating
system that does that. The character codes that are in common use are the ASCII
collating sequence and the EBCDIC collating sequence. EBCDIC is only used by
IBM mainframe and minicomputers (and their clones), but there are a lot of IBM
computers around. (The IBM PC does \textit{not}\, use EBCDIC\@.) Again it would be
rather perverse if, on a given computer, FORTRAN and C used a different
representation of characters, so that is not really worth worrying about. What
certainly is worth paying attention to is the possibility that any given
program may be run on several different computers, some using ASCII characters
and some using EBCDIC\@. That is not a concern that is particular to mixed
language programming though.

An important point about character data is that they are stored differently in
FORTRAN and C\@. FORTRAN stores character data as a fixed-length string padded
with trailing blanks whereas C stores character data as a variable-length,
null-terminated string.
The difference is standardized, so it does not lead to
problems with portability, but it is something that will involve extra work
when passing character data between routines written in different languages.

\subsection{\xlabel{logical_types}Logical Types}

So far all seems well. However, a place that can certainly cause problems is
the representation of logical values. In principle, it is completely up to the
compiler writer to chose how logical values are represented. What is even worse
as far as C is concerned is that there is no logical type at all! In C, a
numerical value of zero represents false and anything else represents true, but
these are numeric data types, not logical types. On a VAX/VMS system, FORTRAN
represents a logical value of false by an integer zero and true by an integer
minus one; however, only the bottom bit is tested, so if an integer value of 2
were to be treated as a logical value, then it would be taken as false. C, on
the other hand, would treat it as true.

\subsection{\xlabel{pointer_types}Pointer Types}
The main reason for passing pointer information between C and FORTRAN
is to pass references to dynamically allocated memory, which is
especially useful given FORTRAN~77's lack of dynamic memory
allocation. In addition, the referenced memory may contain data values
which are, in effect, also being exchanged and which we must therefore
be able to reference from both languages.

C provides a wide range of pointer types which can be constructed to
refer to any other C type. Each of these pointer types can, at least
in principle, have different storage requirements. Indeed, on some
machines and operating systems there are variations in pointer length
according to the type of data being referenced, and even variations in
the way bit patterns are interpreted according to where the referenced
data are stored in memory. Fortunately, the more arcane of these
schemes are now regarded as historical anomalies and are unlikely to
be met in future.

C provides the generic pointer type \texttt{void*}, to which all
pointer types may be cast, and from which the original pointer may
later be recovered by casting back to the original type. Since the
\texttt{void*} type must therefore cater for the ``lowest common
denominator'' of C pointer types, it is very likely to contain just a
simple memory address for the referenced data (or something
equivalent) on all machines. Therefore, exchanging the \texttt{void*}
type is the key to interchanging pointers between C and FORTRAN.

However, FORTRAN~77 does not have a pointer type, and its
\texttt{INTEGER} data type must be pressed into service in order to
store pointer values passed from C. Unfortunately, on some platforms,
a C pointer is longer than a FORTRAN \texttt{INTEGER}, which means
that there is no suitable standard (and therefore portable) FORTRAN
data type of sufficient length to store an address in memory. To
overcome this limitation, some trickery in required, the upshot of
which is that there are some restrictions on the particular pointer
values which may be passed from C to FORTRAN.

In practice, this means that pointer exchange between C and FORTRAN is
really only safe when referring to dynamically allocated memory (and
not, for example, when referring to static memory allocated in C,
where you have no control over the address used). It also means that
CNF must provide special facilities for allocating dynamic memory from
C which will later be passed to FORTRAN, and for ``registering'' the
associated pointers. It also provides functions for converting between
the C and FORTRAN representations of these pointers.

\subsection{\xlabel{arrays}Arrays}

Although the representation of a single numerical value is unlikely to cause a
problem, the way that arrays of numbers are stored is different between
different languages. One dimensional arrays are the least problem, but even
then there are differences. In C, all arrays subscripts start at zero, and this
cannot be changed. In FORTRAN, subscripts start at one by default, but this can
be modified so that the lower bound of a dimension of an array can be any
integer. What must be remembered is that the array element with the lowest
subscript in a FORTRAN array will map on to the array element with a zero
subscript when treated as a C array. This is not a serious problem as long as
you remember it.

Multi-dimensional arrays are a well known problem since FORTRAN stores
consecutive array elements in column-major order (this \textit{is}\/ specified
in the FORTRAN standard) whereas other languages store them in row-major order.
For example, in FORTRAN, the order of elements in a 2 x 2 array called
\texttt{A} are \texttt{A(1,1), A(2,1), A(1,2), A(2,2)}, whereas in C this would
be \texttt{A[0][0], A[0][1], A[1][0], A[1][1]}.
In practice this is rarely a serious problem as long as you
remember to take account of the reversed order when writing a program. However,
when coupled with the difference in default lower bounds (zero in C, one in
FORTRAN) it is a fruitful source of bugs.

There are additional problems with FORTRAN character arrays.
This is because C handles a one dimensional FORTRAN character array as a two
dimensional array of type \texttt{char}, \textit{i.e.}\ the FORTRAN statement:

\begin{terminalv}
CHARACTER * ( NCHAR ) NAMES(DIM)
\end{terminalv}

is equivalent to the C statement:

\begin{terminalv}
char names[dim][nchar]
\end{terminalv}

\subsection{\xlabel{same_language_dash_different_compiler}Same Language -- Different Compiler}

In the preceding sections, reference is often made to ``the way that FORTRAN
does something'' or ``the way that C does something''. However, even different
compilers for the same language can do things in a different way if the
standard does not specify how that something should be done. A reasonable
example is that one FORTRAN compiler might represent a true logical value by
the integer 1, whereas another might just as reasonably use $-1$. This is not
just a hypothetical problem; the FORTRAN for RISC compiler from MIPS and the
DEC FORTRAN for RISC compiler both work on the DECstation and interpret the
same number as different logical values. I shall continue to refer to ``the way
that FORTRAN does it'', even though it is more correct to refer to ``the way
that FORTRAN compiler XYZ implements it''.
The distinction is rarely important, but should be borne in mind.

\section{\xlabel{communication_between_routines}Communication Between Routines}

There are three ways of passing data between a program and a subprogram:
(i)~the argument list of the subprogram, (ii)~the return value of the
subprogram if it is a function and (iii)~global variables. The concept of
arguments and return values of subprograms are common to many programming
languages including FORTRAN and C\@. The ways in which global variables are
handled are rather different. In FORTRAN there are common blocks whereas in C
there are external variables or structures. Each of these will be considered in
turn.

\subsection{\xlabel{arguments}\label{args}Arguments}

This is the main method for passing data between a calling program and the
called subprogram. The calling program takes the actual arguments of the call
to the  subprogram, constructs an argument list and then passes execution to
that routine. The subprogram then uses the values in the argument list to
access the actual arguments. It may pass data back to the calling program by
modifying the data in some or all of the arguments. As far as passing arguments
between a program and a subprogram is concerned, the principal difference
between FORTRAN and C is the method used for passing the arguments.

Note that the above paragraph refers to modifying arguments.
On all the machines we support, the actual contents of the argument list is
never modified.
What may be modified is the contents of the location pointed to by an element
of the argument list. This is not to say that other computers would not modify
the argument list itself.

There are three commonly used methods for passing subprogram arguments: call by
value, call by reference and call by descriptor. Call by value passes the
actual value of the argument to the called routine, call by reference passes a
pointer to the value of the argument (\textit{i.e.}\ the address of the
argument) and call by descriptor passes a pointer to a structure describing
the argument.

Although these are the basic methods of passing arguments, a particular type of
argument may be passed by a combination of these. For example, some compilers
use a combination of call by reference and call by value to pass character
arguments.
What is common is that all arguments are passed by exchanging data values.
It is how those values are to be interpreted that gives rise to the different
mechanisms.

The FORTRAN standard does not specify how arguments should be passed to
subprograms and indeed different compilers for different machines do use
different methods. It is most usual for numeric data types to be passed by
reference since the subprogram may modify the value of the argument. This is
most easily achieved by passing a pointer to the storage location containing
the data value, rather than a copy of the value itself. On the other hand, the
C standard explicitly states that values cannot be returned to the calling
routine directly through arguments and so call by value is most commonly used.
It is worth recalling that the argument list of a routine is simply a sequence
of computer words. If these are a list of addresses of data values then
everything is simple. However, suppose that an array was passed by value. This
would mean that the compiler would have to arrange for a copy of the entire
array to be placed in the argument list that was passed to the called
subprogram. Consequently, arrays are invariably passed by reference or by
descriptor, never by value.

It may seem tedious to have to think about the actual mechanisms that a
compiler uses to pass data between routines when all you want to do is to get
on with your programming. However, understanding this is the key to mixed
language programming. Fortunately the facilities described in
\htmlref{More on Calling C from FORTRAN}{f77_cfromf}
\latex{(Section~\ref{f77_cfromf})} and
\htmlref{More on Calling FORTRAN from C}{f77_ffromc}
\latex{(Section~\ref{f77_ffromc})} hide much of this from the programmer.

\subsection{\xlabel{function_values}Function Values}

The second mechanism for passing data between routines is the return value of a
function. FORTRAN makes a distinction between subprograms that return a value
(functions) and those that do not (subroutines), whereas C does not. All C
subprograms are functions that return a value (even the main program), although
that value may be \texttt{void}. Since it is simply a value that is being
returned, the mechanisms for returning scalar numeric values tend to be just
that -- a value is returned.
However, things get more complicated in the case of
functions returning things like character variables. This will be discussed
further in \latex{appendix~\ref{implement} on}
\htmlref{machine dependencies.}{implement}

\subsection{\xlabel{global_data}Global Data}

Different languages can have very different ways of dealing with variables that
are not local to a particular routine, but have a more global scope. FORTRAN
has common blocks for global data that are accessed by particular routines. The
data values in a common block can be accessed by different names in different
routines, although this is generally considered bad practice. C functions can
access global data by using variables that are not declared in a particular
routine, but have a scope of all the routines contained in the source file in
which the global variables are defined. If the same variable is needed across
several source files, then it can be declared as \texttt{extern}.

Although these two mechanisms are very different in principle, in practice,
computer manufacturers tend to implement them in a way such that it is possible
to share global data between routines that have been written in different
languages. The details of how this is done are given in the appendix about
specific machines. However, there is an indirect way of accessing FORTRAN
common blocks from C that is also worth considering. The FORTRAN routine that
calls the C function can pass as an argument, the first element of the common
block. As long as FORTRAN passes this argument by reference, then the C
function can use this address to access all of the other elements of the common
block. The elements of the common block must be stored contiguously. Whether
this method, or the use of the
\htmlref{F77 macros}{f77_common}\latex{ (described in
Section~\ref{f77_common})},
achieve a greater degree of portability in this respect is not known at
present. On account of these potential portability problems, you should avoid
passing global data between routines written in different languages, whenever
possible.

\section{\xlabel{more_on_calling_c_from_fortran}\label{f77_cfromf}More on
Calling C from FORTRAN}
As the examples in the appendix on machine specific details show, different
computers handle subroutine interfaces in different ways. This apparently makes
it difficult to write portable programs that are a mixture of FORTRAN and C\@.
However, it is only the C code that differs and fortunately the differences can
be hidden by suitable C macros so that the same code can be compiled on all
types of hardware mentioned in this document. The macros have been constructed
in such a way that they can accommodate other subroutine passing mechanisms;
however, it is not possible to guess all the types of mechanisms that we might
come across.

The macros can be used in a C function by including the file \texttt{f77.h}.
This file will naturally be stored in different places on different types of
system, even if it is only the syntax of the file name that is different.
It would be a
pity if all of the implementation specific details were hidden away in these
macros, only to have to have an implementation specific \texttt{\#include}
statement in each C source file. Fortunately there is a way around this
problem that is described in
\latex{Section~\ref{compiling_and_linking} on} \htmlref{compiling and
linking}{compiling_and_linking}.

Let us now consider an example of using the F77 macros to illustrate
their use.
The following example generates a banner which
consists of some hyphens, followed by some stars and finally the same number
of hyphens again. There are also some blanks between the beginning of the line
and between the hyphens and stars. The work is done in the subroutine BANNER
and the form of the output is governed by the three arguments FIRST, MIDDLE and
GAP\@. For example,
\texttt{CALL BANNER( LINE, 5, 10, 3 )} would return with \texttt{LINE} set to
the following character string.

\begin{terminalv}
-----   **********   -----
\end{terminalv}

\newpage
\refstepcounter{examples}
\label{f77_argsf2c}
\begin{center}
Example\latex{~\ref{f77_argsf2c}}
-- Passing arguments between FORTRAN and C\@.
\end{center}
\begin{samepage}
FORTRAN program:
\begin{small}
\begin{terminalv}
      PROGRAM F1
      INTEGER FIRST, MIDDLE, GAP
      CHARACTER*(80) LINE

      FIRST = 5
      MIDDLE = 10
      GAP = 3
      CALL BANNER( LINE, FIRST, MIDDLE, GAP )
      PRINT *, LINE

      END
\end{terminalv}
\end{small}
\end{samepage}
\pagebreak[3]
C function:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
#include "f77.h"

F77_SUBROUTINE(banner)( CHARACTER(line), INTEGER(first), INTEGER(middle),
                       INTEGER(gap) TRAIL(line) )  {
  GENPTR_CHARACTER(line)
  GENPTR_INTEGER(first)
  GENPTR_INTEGER(middle)
  GENPTR_INTEGER(gap)
  int i, j;       /* Loop counters.  */
  char *cp;       /* Pointer to a character.  */

/* Make cp point to the beginning of the string line.  */
  cp = line;

/* First blanks.  */
  for( i = 0, j = 0 ; (j < line_length) && (i < *gap) ; i++, j++ )
     *cp++ = ' ';

/* First hyphens.  */
  for( i = 0 ; (j < line_length) && (i < *first) ; i++, j++ )
     *cp++ = '-';

/* More blanks.  */
  for( i = 0 ; (j < line_length) && (i < *gap) ; i++, j++ )
     *cp++ = ' ';

/* Middle stars.  */
  for( i = 0 ; (j < line_length) && (i < *middle) ; i++, j++ )
     *cp++ = '*';

/* More blanks.  */
  for( i = 0 ; (j < line_length) && (i < *gap) ; i++, j++ )
     *cp++ = ' ';

/* Last hyphens.  */
  for( i = 0 ; (j < line_length) && (i < *first) ; i++, j++ )
     *cp++ = '-';
}
\end{terminalv}
\end{small}

The FORTRAN part of this example is completely standard; it is the C code that
need further explanation. Firstly there is the declaration of the subroutine
with the macro \texttt{F77\_SUBROUTINE}\@.
This handles the fact that some computer
systems require a trailing underscore to be added to the name of the C function
if it is to be called from FORTRAN\@. In the same statement there are the
function's dummy arguments, declared using the macros \texttt{CHARACTER},
\texttt{INTEGER} and \texttt{TRAIL}\@.
The \texttt{INTEGER} macro declares the appropriate dummy argument to handle an
incoming argument passed from FORTRAN\@. This will usually be declared to be
``pointer to \texttt{int}''. The \texttt{CHARACTER} and \texttt{TRAIL} macros
come in pairs.
The \texttt{CHARACTER} macro declares the appropriate argument to handle the
incoming character variable and \texttt{TRAIL} may declare an extra argument
to handle those
cases where an extra hidden argument is added to specify the length of a
character argument. On some machines, \texttt{TRAIL} will be null and on
account of this
\emph{there should not be a comma before any \texttt{TRAIL} macros}.
When \texttt{TRAIL} is not
null, then it will add the comma itself. If there are several \texttt{TRAIL}
macros then there must not be a comma directly in front of any of them.

The next set of macros are the \texttt{GENPTR\_\textit{type}}\/ macros, one
for each argument of the FORTRAN subroutine (\texttt{TRAIL} arguments are not
counted as separate arguments for this purpose).
These handle the ways that subprogram arguments
may be passed on different machines. They ensure that a pointer to the argument
exists. On most systems, this is exactly what is passed from the FORTRAN
program and so the macros for numeric arguments are null. If a particular
system passed the value of an argument, rather than its address, then these
macros would generate the appropriate pointers.

The \texttt{CHARACTER}, \texttt{TRAIL} and \texttt{GENPTR\_CHARACTER} macros
have to cope with the different ways that systems deal with passing character
variables. Although the
way that these macros are implemented can be a bit complex, what the programmer
sees is essentially simple. For each character argument, the macros generate a
pointer to a character variable and an integer holding the length of that
character variable. The above example will create the variable \texttt{line} of
type \texttt{char *} and variable \texttt{line\_length} of type \texttt{int}.
If these are available directly as function arguments, then the macro
\texttt{GENPTR\_CHARACTER} will be null, otherwise it will generate these two
variables from the arguments.
The best way of seeing what is going on is to compile a
function with macro expansion turned on and list the output.

There is an important difference between this example and the one in the
cookbook. In this case, an \texttt{int} variable containing the length of the
character argument is generated automatically whereas in the example in the
cookbook the length was passed explicitly.
In fact, the \texttt{int} variable was
also generated in the example in the cookbook, but it was not used. It is more
portable to explicitly pass the length of \texttt{CHARACTER} variables and to
ignore the automatically generated length as this will cope with the situation
where the length cannot be generated automatically.
No such machines are known to the
author at present, but Murphy's Law would indicate that the next machine that
we desperately need to use will have this problem.

Although the use of these macros does seems a bit strange at first, once any
pointers have been generated, the rest of the code is standard C\@.

Something that has not yet been considered is whether to write the code in
upper or lower case. All of the examples in this document have the FORTRAN code
in upper case and the C code in lower case, thereby following common practice.
Normally it makes no difference whether code is written in upper case or lower
case. Where it does matter is in declaring external symbols. External symbols
are names of routines and names of common blocks (FORTRAN) or variables
declared \texttt{extern} (C). The linker must be able to recognise that the
external symbols in the FORTRAN routines are the same external symbols in the C
functions. On a VMS system, the VAX~C compiler will fold all external symbols
to upper case by default, although there is a compiler option to fold them all
to lower case or leave them as written in the source code. The VAX FORTRAN
compiler will generate all external symbols in upper case. On Unix systems, the
FORTRAN compiler will typically fold external names to lower case (and add a
trailing underscore), whereas the C compiler will leave the case unchanged.
Consequently, all external symbols in C functions that might be referenced from
FORTRAN should be coded in lower case.

\subsection{\xlabel{general_description}General Description}

Having considered an example of using the macros to write a C function that is
to be called from FORTRAN, let us look at all of the macros in more details.
You will notice that some of the macros are prefixed by F77 while others are
not. Those that do not have the F77 prefix are those that occur in standard
places in the source code and so are unlikely to be confused with other macros.
The macros that do have the F77 prefix are those that declare a C function and
others that are less commonly used, and when they are, they can occur anywhere
within the body of the C routine.
A
\htmlref{full description of each macro}{f77_description} is
available\latex{ in appendix~\ref{f77_description}}.

The whole ethos of the F77 macros is to try to isolate the FORTRAN/C
interface to the beginning of the C function. Within the body of the C
function, the programmer should not need to be aware of the fact that this
function is designed to be called from FORTRAN\@. It is not possible to achieve
this completely and at the same time retain portability of code, but the
intention is there none the less.

\subsection{\xlabel{declaration_of_a_function}Declaration of a Function}

There are two types of macros involved in declaring a C function that is to be
called from FORTRAN; the function name and the function arguments. If the C
function is to be treated as a FORTRAN subroutine, then it should be declared
with the macro
\htmlref{\texttt{F77\_SUBROUTINE}}{F77_SUBROUTINE}.
This will declare the C function to be of type \texttt{void} and will generate
the correct form of the of the routine name, handling such things as appending
a trailing underscore where required.

If the C function is to be treated as a FORTRAN numerical or logical function,
then it should be declared with one of the macros
\htmlref{\texttt{F77\_\textit{type}\_FUNCTION}}{F77_type_FUNCTION}.
These macros will declare the function to be of the appropriate type,
\textit{e.g.}\ a function declared with
\texttt{F77\_\-INTEGER\_\-FUNCTION} is
likely to be of type \texttt{int}.

The declaration of a C function that is to be treated as a FORTRAN character
function is more complex than one that returns a scalar numeric or logical
value. The first argument of the function should be
\htmlref{\texttt{CHARACTER\_\-RETURN\_\-VALUE}}
{CHARACTER_RETURN_VALUE}(return\_value),
where
\texttt{return\_value} is a variable of type ``pointer to \texttt{char}''.
Although character functions work
perfectly well on all current Starlink hardware, it is one of the more
difficult things to guess how other manufacturer might implement them.
Consequently, it is recommended that character functions be avoided where
possible and that a subroutine that returns a character argument be used
instead.

\subsection{\xlabel{declaration_of_arguments}Declaration of Arguments}

Scalar arguments are declared with the macros \texttt{INTEGER}, \texttt{REAL},
\texttt{DOUBLE}, \texttt{LOGICAL}, \texttt{CHARACTER} and \texttt{TRAIL}.
(Or the non-standard \texttt{BYTE}, \texttt{WORD}, \texttt{UBYTE},
\texttt{UWORD} or \texttt{POINTER}.)
The macros that declare numeric and logical arguments take account of the fact
that a FORTRAN integer variable may correspond to a C type of \texttt{int} on
one machine, but to \texttt{long int} on another.
They also handle the mechanism that is used to pass the arguments.

Character arguments are more complex as different computers use differing
mechanisms for passing the arguments. To take account of this, for every
argument that is declared using the
\htmlref{\texttt{CHARACTER}}{CHARACTER}
(or
\htmlref{\texttt{CHARACTER\_ARRAY}}{CHARACTER_ARRAY})
macro, there should be a corresponding
\htmlref{\texttt{TRAIL}}{TRAIL}
macro at the end of the list of dummy arguments.
As mentioned in a preceding example, \textit{there should not be a comma before
any \texttt{TRAIL} macros}.

C differs from FORTRAN in that it has pointer variables. These are often used to
manipulate arrays, rather than by using array subscripts. The macros that are
used to declare array arguments do in fact declare them to be arrays.
If programmers wish to manipulate these arrays by means of pointer arithmetic,
then for maximum portability they should declare separate pointers within the C
function that point to the array argument.

Array arguments are declared by one of the macros
\htmlref{\texttt{\textit{type}\_ARRAY}}{type_ARRAY}.
The macros that declare numeric or
logical array arguments declare the arrays to be pointers to \textit{type}.
To enable the C function to process the array correctly,
the dimensions of the array should be passed as additional arguments.

The F77 macros do not allow you to declare fixed sized dimensions for an array
that is a dummy argument. Normally, it is necessary to pass the dimensions as
arguments of the routine anyway, but there are circumstances where the
dimensions of the array will be fixed, \textit{e.g.}\ an array might specify a
rotation in space and hence is always 3 \texttt{x} 3.
What is gained by declaring the
fixed dimensions of the array is that subscript calculations can be done on
arrays of more than one dimension. Unfortunately, such declarations cannot be
made portable as some FORTRAN systems pass arrays by descriptor. If you really
must declare arrays with fixed dimensions, you can do so as follows:

\begin{small}
\begin{terminalv}
F77_SUBROUTINE(subname)( F77_INTEGER_TYPE array[3][3] )
{
  ...
  elem = array[i][j]
  ...
}
\end{terminalv}
\end{small}

This example declares the dummy argument to be an INTEGER array of fixed size.
Although the subscript calculation can be performed as the routine knows the
size of the array, the \texttt{sizeof} operator does not return the full size of
the array as the complier casts \texttt{array[3][3]} to \texttt{*array}. All
things considered, it is better to have the dimensions of arrays passed as
separate arguments and to do the subscript arithmetic yourself with pointers.
Here is an example of initializing an array of arbitrary size and arbitrary
number of dimensions.
\newpage
\refstepcounter{examples}
\label{f77_arbary}
\begin{center}
Example\latex{~\ref{f77_arbary}}
-- Passing an array of arbitrary size from FORTRAN
to C\@.
\end{center}
\nopagebreak[4]
FORTRAN program:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
      PROGRAM ARY

      INTEGER NDIMS, DIM1, DIM2, DIM3
      PARAMETER( NDIMS = 3, DIM1 = 5, DIM2 = 10, DIM3 = 2 )

      INTEGER DIMS( NDIMS )
      INTEGER A( DIM1, DIM2, DIM3 )

      DIMS( 1 ) = DIM1
      DIMS( 2 ) = DIM2
      DIMS( 3 ) = DIM3
      CALL INIT( A, NDIMS, DIMS )

      END
\end{terminalv}
\end{small}
\pagebreak[1]
C function:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
#include "f77.h"

F77_SUBROUTINE(init)( INTEGER_ARRAY(a), INTEGER(ndims), INTEGER_ARRAY(dims) )
{
  GENPTR_INTEGER_ARRAY(a)
  GENPTR_INTEGER(ndims)
  GENPTR_INTEGER_ARRAY(dims)

  int *ptr = &a[0];  /* ptr now points to the first element of a.  */
  int size = 1;      /* Declare and initialize size.  */
  int i;             /* A loop counter.  */

  /* Find the number of elements in a.  */

  for( i = 0; i < *ndims ; i++ )
     size = size * dims[i];

  /* Set each element of a to zero.  */

  for( i = 0 ; i < size ; i++ )
     *ptr++ = 0;
}
\end{terminalv}
\end{small}

In this example, each element of the array \texttt{a} is accessed via the
pointer \texttt{ptr}, which is incremented each time around the last loop.

\subsection{\xlabel{arguments_dash_and_pointers_to_them}Arguments -- and Pointers to Them}

When a FORTRAN program calls a subprogram, it is possible for the value of any
of its arguments to be altered by that subprogram. In the case of C, a function
cannot return modified values of arguments to the calling routine if what is
passed is the value of the argument. If a C function is to modify one of its
argument, then the address must be a pointer to the value to be modified rather
than the actual value. Consequently in C functions that are designed to be
called from FORTRAN, all function arguments should be treated as though the
address of the actual argument had been passed, not its value. This means that
the arguments should be referenced as \texttt{*\textit{arg}}\/ from within the C
function and not directly as \textit{arg}. This may seem odd to a FORTRAN
programmer, but is natural to a C programmer.

To ensure that there always exists a pointer to each dummy argument,
the first lines of code in the body of any C function that is to be called from
FORTRAN should be \texttt{GENPTR} macros for each of the function arguments.
The macros
\htmlref{\texttt{GENPTR\_\textit{type}}}{GENPTR_type}
always result in there being a C variable of type ``pointer to type'' for
all non-character variables.
For example, \texttt{GENPTR\_\-INTEGER(first)} ensures that there will be
a variable declared as \texttt{int *first}. On all current types of system,
this macro will actually be null since the pointer is available directly as an
argument. However, the macro should be present to guard against future
computers working in a different way. For example, if a particular system
passed FORTRAN variables by value rather than by reference, then this macro
would construct the appropriate pointer.

Character arguments are different in that the \texttt{GENPTR} macro ensures that
there are two variables available, one of type ``pointer to char'' that points
to the actual character data, and one of type \texttt{int} that is the length
of the character variable.
The name of the variable that holds the length of the
character string is constructed by appending ``\texttt{\_length}'' to the name
of the character variable.
For example, if a function is declared to have a dummy
argument with the macro \texttt{CHARACTER(ch)} and a corresponding
\texttt{TRAIL(ch)}, then after the execution of whatever the macro
\texttt{GENPTR\_CHARACTER(ch)} expands into, there will be a ``pointer to
character'' variable called \texttt{ch} and an integer variable called
\texttt{ch\_length}.
Although the length of a character variable is directly accessible through the
\texttt{int} variable \texttt{ch\_length}, it is better to pass the length of
the character variable explicitly if maximum portability is sought. This is
because, although it works on all currently supported platforms, it may not be
possible to gain access to the length on some machines.

It is important to remember that what is available after the execution of what
a \texttt{GENPTR} macro expands into will be a pointer to the dummy argument,
not a variable of numeric or character type. Consequently the body of the code
should refer to it as \texttt{*\texttt{arg}}\/ and not as
\texttt{\textit{arg}}.
In a long C function, it
may be worth copying scalar arguments into local variables to avoid having to
remember to put the \texttt{*} on each reference to an argument. If the variable
is changed in the function, then it should of course be copied back into the
argument at the end of the function. Alternatively you could define C macros to
refer to the pointers, such as

\begin{terminalv}
#define STATUS *status
\end{terminalv}

Note that although ANSI C will allow the above as \texttt{status} and
\texttt{STATUS}
are distinct names, you should beware of the possibility of a computer that
does not have lower case characters. Such machines used to exist in abundance,
but at present, this does seem a remote possibility.

Array arguments should have pointers generated (if necessary) by using the
\htmlref{\texttt{GENPTR\_\-\textit{type}\_\-ARRAY}}{GENPTR_type_ARRAY}
macros. All arrays are handled by these macros.

\subsection{\xlabel{type_specifiers}Type Specifiers}

There are macros \texttt{F77\_\textit{type}\_TYPE}
which expand to the C data type that corresponds to the FORTRAN data type of
the macro name, \textit{e.g.}\ on a particular computer
\htmlref{\texttt{F77\_\-INTEGER\_\-TYPE}}{F77_INTEGER_TYPE} may expand to
\texttt{int}.
These are usually not needed explicitly within user written code, but can be
required when declaring common blocks, casting values from a variable of one
type to one of a different type and when using the \texttt{sizeof} operator.

\subsection{\xlabel{logical_values}Logical Values}

The macros
\htmlref{\texttt{F77\_\-FALSE}}{F77_FALSE}
and
\htmlref{\texttt{F77\_\-TRUE}}{F77_TRUE}
expand to the
numerical values that FORTRAN treats as false and true ({\em{e.g.}}\ 0 and 1).
They should be used when setting logical values to be returned to the calling
FORTRAN routine.
There are also macros
\htmlref{\texttt{F77\_\-ISFALSE}}{F77_ISFALSE}
and
\htmlref{\texttt{F77\_\-ISTRUE}}{F77_ISTRUE}
that should be used when testing a function argument for truth or falsehood.

\subsection{\xlabel{external_names}External Names}

The macro
\htmlref{\texttt{F77\_\-EXTERNAL\_\-NAME}}{F77_EXTERNAL_NAME}
handles the difference between the
actual external name of a function called from FORTRAN and a function that
apparently has the same name when called from C\@. Typically this involves
appending an underscore character to a name. This macro is not normally needed
directly by the programmer, but is called by other macros.

\subsection{\xlabel{common_blocks}\label{f77_common}Common Blocks}

There are two macros that deal with common blocks,
\htmlref{\texttt{F77\_\-NAMED\_\-COMMON}}{F77_NAMED_COMMON}
and
\htmlref{\texttt{F77\_\-BLANK\_\-COMMON}}{F77_BLANK_COMMON}\@.
They are used when declaring external
structures that corresponds to FORTRAN common blocks and when referring to
components of those structures in the C code. The following declares a common
block named ``block'' that contains three \texttt{INTEGER} variables and three
\texttt{REAL} variables.

\begin{small}
\begin{terminalv}
extern struct
{
 F77_INTEGER_TYPE i,j,k;
 F77_REAL_TYPE a,b,c;
} F77_NAMED_COMMON(block);
\end{terminalv}
\end{small}

The corresponding FORTRAN statements are

\begin{small}
\begin{terminalv}
      INTEGER I,J,K
      REAL A,B,C
      COMMON /BLOCK/ I,J,K,A,B,C
\end{terminalv}
\end{small}

Within the C function the variables would be referred to as:

\texttt{F77\_\-NAMED\_\-COMMON(block).i},
\texttt{F77\_\-NAMED\_\-COMMON(block).j},
\textit{etc.}

Note that all that these macros do is to hide the actual name of the external
structure from the programmer. If a computer implemented the correspondence
between FORTRAN common blocks and C global data in a completely different way,
then these macros would not provide portability to such an environment.

On account of this, it is best to avoid using common blocks where possible, but
of course, if you need to interface to existing FORTRAN programs, this may not
be practical.

\section{\xlabel{converting_between_fortran_and_c_strings}Converting Between FORTRAN and C Strings}

\subsection{\xlabel{the_cnf_functions}\label{cnf}The CNF Functions}
FORTRAN stores \texttt{CHARACTER} strings as fixed-length strings
filled with trailing blanks, whereas C stores them as a variable-length strings
each terminated by the null character.
Although C strings are of variable length,
there must of course be enough space reserved to store the maximum length that
the string ever reaches \textit{plus one more character for the trailing null}.

To aid the programmer in converting between the two forms of character strings,
a number of C functions are provided in the CNF library.
These handle all aspects of converting between the two types of string and
provide options such as creating temporary strings, including the trailing
blanks in the C version of a string and only copying a maximum number of
characters.
The process of converting from FORTRAN to C strings is known as ``importing''
and from C to FORTRAN as ``exporting''.

None of the functions are very complicated and some of them are just a tidier
way of achieving what could be done with a few lines of C in the calling
program. Consequently in a time critical application it may be appropriate to
include the source of a CNF function in your code, rather than incur the
overheads of a making a function call.

\htmlref{Full descriptions}{cnf_description}
of the CNF functions are
provided\latex{ in Appendix~\ref{cnf_description}}.

Here is an
example of how to use them. This is the same as an example from the machine
specific section of this document. The use of the F77 macros and the CNF
functions have made the C code easier to write and completely portable to all
Starlink systems.

\refstepcounter{examples}
\label{f77_char}
\begin{center}
Example\latex{~\ref{f77_char}}
-- Converting character arguments between FORTRAN and C\@.
\end{center}
\nopagebreak[4]
FORTRAN program:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
      PROGRAM STRING
      CHARACTER STR*20

      CALL GETSTR( STR )
      PRINT *,STR

      END
\end{terminalv}
\end{small}
\pagebreak[1]
C function:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
#include "f77.h"

F77_SUBROUTINE(getstr)( CHARACTER(fortchar) TRAIL(fortchar) )
{
  GENPTR_CHARACTER(fortchar)           /* Generate pointer to fortchar */

  char  *string = "This is a string";  /* A string to be printed */

/* Copy the string to the function argument */
  cnfExprt( string, fortchar, fortchar_length );
}
\end{terminalv}
\end{small}
Other examples in this document illustrate the use of CNF functions for
importing strings and calling FORTRAN from C.

\subsection{\xlabel{handling_byte_strings_hds_locators}\label{locators}Handling Byte Strings (HDS Locators)}
Sometimes FORTRAN \texttt{CHARACTER} variables are used to contain strings of
bytes rather than normal, printable character strings -- a particular case
of this is
\xref{HDS locators}{sun92}{using_locators}\latex{ (see SUN/92)}.
In this case, special characters, such as NULL, cease to have their normal
meaning and this could confuse the standard CNF import and export functions.
For this reason, functions
\htmlref{\texttt{cnfImpch}}{cnfImpch}
and
\htmlref{\texttt{cnfExpch}}{cnfExpch}
are provided.
These functions just import and export a given number of characters.

\subsection{\xlabel{using_dynamic_fortran_character_strings}\label{f77_chardyn}Using Dynamic FORTRAN Character Strings}
The
\htmlref{\texttt{DECLARE\_CHARACTER}}{DECLARE_CHARACTER}
macro used in
\htmlref{an earlier example}{cook_argsc2f} \latex{(\ref{cook_argsc2f})}
assumes that the length of the required FORTRAN character string is a constant,
known at compile time.
This is not always the case -- for example, the character argument to be
passed to the FORTRAN subroutine may be derived from an argument of the
calling C function as in the case of a C wrap-around for a FORTRAN subroutine.
To cater for this situation, macros are provided which will allocate and free
space for the FORTRAN character string at run time.
They make use of the CNF functions
\htmlref{\texttt{cnfCref}}{cnfCref}
and
\htmlref{\texttt{cnfFreef}}{cnfFreef}.

The following example illustrates their use for both
input and output of strings from a FORTRAN subroutine which takes a given
string, modifies it and returns the result.

\refstepcounter{examples}
\label{f77_exchardyn}
\begin{center}
Example\latex{~\ref{f77_exchardyn}}
-- Dynamic CHARACTER Arguments.
\end{center}

C main program
\begin{small}
\begin{terminalv}
void strStrip( char *in, char *out, int maxout );

main(){
char in[20]="Hello  there  !";
char out[20];

printf( "Input string is: %s\n", in );
strStrip( in, out, 20 );
printf( "Output string is: %s.\n", out );
}
\end{terminalv}
\end{small}
C wrap-around for a FORTRAN subroutine
\begin{small}
\begin{terminalv}
/* strStrip - A C wrap-around for FORTRAN subroutine STR_STRIP */
#include "f77.h"

extern F77_SUBROUTINE(str_strip)
  ( CHARACTER(fin), CHARACTER(fout) TRAIL(fin) TRAIL(fout) );

void strStrip( char *in, char *out, int maxout ){
  DECLARE_CHARACTER_DYN(fin);
  DECLARE_CHARACTER_DYN(fout);

  F77_CREATE_CHARACTER(fin,strlen(in));
  F77_CREATE_CHARACTER(fout,maxout-1);

  cnfExprt( in, fin, fin_length );

  F77_CALL(str_strip)
     ( CHARACTER_ARG(fin), CHARACTER_ARG(fout)
       TRAIL_ARG(fin) TRAIL_ARG(fout) );

  cnfImprt( fout, fout_length, out );

  F77_FREE_CHARACTER(fin);
  F77_FREE_CHARACTER(fout);
}
\end{terminalv}
\end{small}

which is a C wrapper for the FORTRAN subroutine:
\begin{small}
\begin{terminalv}
      SUBROUTINE STR_STRIP( FIN, FOUT )
* Remove multiple spaces from a string
      IMPLICIT NONE
      INTEGER I, J
      CHARACTER*(*) FIN
      CHARACTER*(*) FOUT

      FOUT = FIN(1:1)
      I = 2
      J = 1

      DOWHILE ( I .LE. LEN(FIN) )
         IF ( FIN(I:I) .NE. ' ' ) THEN
            J = J + 1
            FOUT(J:J) = FIN(I:I)
         ELSE IF ( FOUT(J:J) .NE. ' ' )
            J = J + 1
            FOUT(J:J) = FIN(I:I)
         END IF

         I = I + 1

      ENDDO

      END
\end{terminalv}
\end{small}
Here,
\htmlref{\texttt{DECLARE\_CHARACTER\_DYN}}{DECLARE_CHARACTER_DYN}
is used in place of
\htmlref{\texttt{DECLARE\_CHARACTER}}{DECLARE_CHARACTER}\@.
It declares pointers rather than allocating space for the FORTRAN character
strings to be passed to the FORTRAN subroutine. A variable to hold the string
length is also declared.

The
\htmlref{\texttt{F77\_CREATE\_CHARACTER}}{F77_CREATE_CHARACTER}
expands to executable statements which allocate space and set the pointers and
string length. The
\htmlref{\texttt{F77\_\-FREE\_\-CHARACTER}}{F77_FREE_type}
macro expands to executable statements which free the previously allocated
space.

\section{\xlabel{pointers}\label{f77_pointers}Pointers}

FORTRAN~77 does not have the concept of a pointer. However, FORTRAN
\texttt{INTEGER}s are widely used in Starlink software as a
replacement for pointers when passing the address of a data array from
one routine to another. Typically, a FORTRAN program calls a
subroutine that returns a value in an \texttt{INTEGER} variable that
represents the address of an array, which will usually have been
dynamically allocated. The value of this variable (as opposed to its
address) is then passed on to another routine where the contents of
the array are accessed.

C, of course, does provide pointers -- in fact you can hardly avoid
using them -- and they are distinct from C integers (\texttt{int}s). To
take account of this, a macro
\htmlref{\texttt{POINTER}}{type}
is defined to declare C
function arguments that the calling FORTRAN program declares as an
\texttt{INTEGER} but will actually treat as a pointer. The FORTRAN
routine should not process a \texttt{POINTER} variable in any way.
The only valid operations it may perform are to copy it, to pass it to
a subprogram using the normal parameter passing mechanism, or to pass
its value to a subprogram using the
\htmlref{\texttt{\%VAL} facility}{percentval}\latex{ (as
described in Section~\ref{percentval})} in order to access the contents
of the array to which it points.

Unfortunately, this scheme of using FORTRAN \texttt{INTEGER}s to hold
pointer values only works cleanly if the length of an \texttt{INTEGER}
is the same as the length of the C generic pointer type
\texttt{void*}.  Where this is not the case (on DEC Alphas for
instance), some way around the problem has to be found.

On some systems, the linker may have flags to control the size of the
address space in which a program runs, and this can provide a simple
solution. For example, although addresses on DEC Alphas are normally
64~bits long (the length of a C pointer), it is possible to force
programs to use addresses in which only the lowest 32 bits have
non-zero values. It then becomes a simple matter to convert C pointers
into FORTRAN \texttt{INTEGER}s (which are 32 bits long) because
discarding the most significant bits has no effect. The standard
Starlink link scripts on DEC Alpha systems supply the necessary
command-line flags to produce this behaviour automatically.

However, this simple solution is not always applicable. Apart from the
possibility that future 64-bit operating systems (of which there are
likely to be an increasing number) may not provide this option of
running programs in ``lower memory'', even on those that do the option
cannot always be exercised. For example, some software packages make
use of ``dynamic loading'' of routines stored in shareable libraries
as a way of allowing their capabilities to be extended. This is a very
flexible facility, but it means that the loaded routines must execute
in the address space of the main program, which means that the writer
of the shareable library no longer has any control over the number of
bits used in pointers. The only option is then to re-build the main
software package with the required linker options. This is at best
inconvenient, but in the case of commercial software packages it may
be impossible.

There is also an increasing likelihood that programs may need to
access data arrays of such size that 32 bits of address space (the
usual length of FORTRAN \texttt{INTEGER}s) is insufficient.

\subsection{\xlabel{pointer_registration_and_conversion}Pointer
Registration and Conversion}

To overcome these problems, some method is needed of converting
between (say) 64-bit C pointers and the typical 32 bits of a FORTRAN
\texttt{INTEGER}. The same method must also work if the two pointer
representations are actually of equal length.  To allow this, CNF
maintains an internal table which contains all the C pointers which
will be exported and used from FORTRAN. The pointers stored in this
table are said to have been ``registered'' for use from both C and
FORTRAN.

When converting a C pointer into a FORTRAN pointer, it is sufficient
simply to mask out all bits except those that will fit into a FORTRAN
\texttt{INTEGER}. This is performed by the function
\htmlref{\texttt{cnfFptr}}{cnfFptr}.
When converting in the opposite direction, the
internal table must be searched to locate a pointer which has the same
value stored in the set of masked bits (e.g.\ the lowest 32 bits) as
the FORTRAN pointer value. The full value of the C pointer can then be
read from the table. This conversion is performed by
\htmlref{\texttt{cnfCptr}}{cnfCptr}.

Apart from the requirement that all pointers which will be used from
both C and FORTRAN must be registered by entering them in the internal
table, this scheme also requires that all registered pointers should
be unique in their lowest 32 bits (or whatever length a FORTRAN
\texttt{INTEGER} has) in order for the conversion from FORTRAN to C to
select a unique pointer from the table. In practice, these
requirements are most easily fulfilled by providing a set of memory
allocation functions in CNF which mirror the standard C run time
library functions \texttt{malloc}, \texttt{calloc} and \texttt{free}.

\subsection{\xlabel{allocating_exportable_dynamic_memory}Allocating
Exportable Dynamic Memory}

The CNF functions
\htmlref{\texttt{cnfMalloc}}{cnfMalloc}
and
\htmlref{\texttt{cnfCalloc}}{cnfCalloc}
should be used whenever you wish to dynamically allocate memory in a C
function and export the resulting pointer for use from FORTRAN. You
might also want to use them if you are writing a subroutine library
that returns pointers to dynamic memory through its public interface,
since the caller might then decide to pass these pointers on to a
FORTRAN routine.

For example, here is how you should allocate space for an array of
\texttt{N} FORTRAN \texttt{REAL} values in a C function and pass back
the resulting pointer to FORTRAN:

\begin{small}
\begin{terminalv}
F77_POINTER_FUNCTION(ralloc)( INTEGER(N) )
{
   GENPTR_INTEGER(N)

/* Allocate the memory and return the converted pointer. */
   return cnfFptr(cnfMalloc(*N*sizeof(F77_REAL_TYPE)));
}
\end{terminalv}
\end{small}

When the allocated memory is no longer required, it should be freed
using
\htmlref{\texttt{cnfFree}}{cnfFree}.
This is how you might import the FORTRAN
pointer value allocated above back into C in order to free it:

\begin{small}
\begin{terminalv}
F77_SUBROUTINE(rfree)( POINTER(FPNTR) )
{
   GENPTR_POINTER(FPNTR)

/* Convert back to a C pointer and then free it. */
   cnfFree(cnfCptr(*FPNTR));
}
\end{terminalv}
\end{small}

Externally, these CNF memory allocation functions behave exactly like
their standard C equivalents \texttt{malloc}, \texttt{calloc} and
\texttt{free}. Internally, however, they perform two important
additional functions:
\begin{itemize}

\item They maintain the internal table of ``registered'' pointers, so
that the conversion functions
\htmlref{\texttt{cnfFptr}}{cnfFptr}
and
\htmlref{\texttt{cnfCptr}}{cnfCptr}
can operate (if you use \texttt{malloc} to obtain a
pointer, for instance, then these conversion functions will fail and
return zero).

\item They ensure that all memory allocation results in pointers whose
lowest 32 bits (or the length of a FORTRAN \texttt{INTEGER}) are
unique, so that conversion between FORTRAN and C pointer values is a
well-defined operation.
\end{itemize}

For convenience,
\htmlref{\texttt{cnfFree}}{cnfFree}
is also able to free pointers
which have not been registered, in which case it behaves exactly like
\texttt{free}.

\subsection{\xlabel{accessing_dynamic_memory_from_c_and_fortran}\label{percentval}Accessing
Dynamic Memory from C and FORTRAN}

Of course, exchanging pointers to dynamic memory between C and FORTRAN
is only part of the story. We must also be able to access the memory
from both languages.

When importing a FORTRAN pointer into C, the first step is to use
\htmlref{\texttt{cnfCptr}}{cnfCptr}
to convert it to a C pointer of type
\texttt{void*}. You can then use a cast to convert to the appropriate
C pointer type (which you must know in advance) in order to access the
values stored in the memory. For example, to print out the contents of
a dynamically allocated array of FORTRAN \texttt{REAL} data from a C
function, you might use the following:

\begin{small}
\begin{terminalv}
F77_SUBROUTINE(rprint)( INTEGER(N), POINTER(FPNTR) )
{
   GENPTR_INTEGER(N)
   GENPTR_POINTER(FPNTR)
   F77_REAL_TYPE *cpntr;

/* Convert to a C pointer of the required type. */
   cpntr=(F77_REAL_TYPE)cnfCptr(*FPNTR);

/* Access the data. */
   for(i=0;i<*N;i++) printf("%g\n",cpntr[i]);
}
\end{terminalv}
\end{small}

Accessing dynamically allocated memory via a pointer from FORTRAN
requires two steps. First, the pointer value stored in a
FORTRAN \texttt{INTEGER} must be expanded to its full value (if
necessary), equivalent to the full equivalent C pointer. This value
must then be turned into a FORTRAN array which can be accessed. This
requires that the pointer be passed to a separate FORTRAN routine
using the \texttt{\%VAL} facility.\footnote{This is a non-standard
facility which originated in VAX FORTRAN but is now available on most
FORTRAN compilers. It is a compiler directive, rather than a function,
and works by instructing the compiler to pass the argument by value
rather than by address. The routine receiving this argument is then
tricked into thinking that it has received an array starting at the
address given by the pointer value. There are other ways of achieving
this effect, such as by addressing an array outside of its bounds, but
the \texttt{\%VAL} method is the one most widely used in Starlink
software.}  For example, to convert a pointer into a \texttt{REAL}
array, you might call an auxiliary routine \texttt{RWRITE} as
follows:
\begin{small}
\begin{terminalv}
      INCLUDE 'CNF_PAR'

      ...

      CALL RWRITE(N,%VAL(CNF_PVAL(PNTR)))
\end{terminalv}
\end{small}
and the \texttt{RWRITE} routine could then access the array of values as
follows:
\begin{small}
\begin{terminalv}
      SUBROUTINE RWRITE( N, RDATA )
      INTEGER I, N
      REAL RDATA( N )
      DO 1 I = 1, N
         WRITE(*,*) RDATA(I)
    1 CONTINUE
      END
\end{terminalv}
\end{small}

Note how the argument of the \texttt{\%VAL} directive is
\texttt{CNF\_PVAL(PNTR)}. The FORTRAN-callable
\htmlref{\texttt{CNF\_PVAL}}{CNF_PVAL}
function serves to expand the pointer value out to its full length
(equivalent to calling
\htmlref{\texttt{cnfCptr}}{cnfCptr}
from C).
The data type returned by this function will depend on the length of C pointers
on the machine being used and may not be a standard FORTRAN type (for
instance, on DEC Alphas it is an \texttt{INTEGER*8}
function). However, the data type declaration for this function is
encapsulated in the \texttt{CNF\_PAR} include file, so you need not
include non-standard type declarations directly in your own software.

\subsection{\xlabel{registering_your_own_pointers}Registering Your Own
Pointers}

CNF also provides two functions,
\htmlref{\texttt{cnfRegp}}{cnfRegp}
and
\htmlref{\texttt{cnfUregp}}{cnfUregp},
for registering and un-registering pointers --
\textit{i.e.}\ for entering and removing them from the internal table which is
used for pointer conversion between C and FORTRAN. You will probably
never need to use these, since pointer registration is normally
managed completely automatically by the memory allocation functions
which CNF provides.

The reason for providing them is that there may be ways of
creating new memory, for which \texttt{cnfMalloc} or \texttt{cnfCalloc} cannot
be used.
For example, mapping data files directly into memory.
If the resulting C pointers are to be exported to FORTRAN,
they must be accessible to CNF for conversion purposes, so they must
be registered in CNF's internal table.

If you should ever need to use this facility, then the main point to
note is that attempting to register a C pointer can potentially fail
(\htmlref{\texttt{cnfRegp}}{cnfRegp} returns -1 to indicate this).
This will occur if, when the C pointer is converted to a FORTRAN
\texttt{INTEGER}, it
clashes with a FORTRAN pointer value which is already in use. In such
a case you cannot safely export your pointer to FORTRAN, so you must
obtain a new pointer and re-register it. Typically, this may involve
allocating a new block of memory at a different location and freeing
the original. The consolation is that such clashes are extremely rare.

\section{\xlabel{more_on_calling_fortran_from_c}\label{f77_ffromc}More on
Calling FORTRAN from C}

The operations needed to write a C routine that can call a FORTRAN subroutine
or function are fairly similar to those needed when calling C from FORTRAN\@.
Many of the macros that are used are the same, so you should read


\latex{Section~\ref{f77_cfromf} before reading this.}

A typical reason to call FORTRAN from C is to use a pre-existing subroutine
library. Here is an example of calling PGPLOT from a C main program.

\refstepcounter{examples}
\label{f77_ccallsf}
\begin{center}
Example\latex{~\ref{f77_ccallsf}}
-- Passing arguments from C to FORTRAN\@.
\end{center}
\nopagebreak[4]
C main program:
\begin{small}
\begin{terminalv}
#include "f77.h"

extern F77_SUBROUTINE(pgbegin)
  ( INTEGER(unit), CHARACTER(file), INTEGER(nxsub), INTEGER(nysub)
    TRAIL(file) );

extern F77_SUBROUTINE(pgenv)
  ( REAL(xmin), REAL(xmax), REAL(ymin), REAL(ymax), INTEGER(just),
    INTEGER(axis) );

extern F77_SUBROUTINE(pglabel)
  ( CHARACTER(xlab), CHARACTER(ylab), CHARACTER(toplab)
    TRAIL(xlab) TRAIL(ylab) TRAIL(toplab) );

extern F77_SUBROUTINE(pgpoint)
  ( INTEGER(n), REAL_ARRAY(xs), REAL_ARRAY(ys), INTEGER(symbol) );

extern F77_SUBROUTINE(pgend) ( );

extern F77_SUBROUTINE(pgline)
  ( INTEGER(n), REAL_ARRAY(xpnts), REAL_ARRAY(ypnts) );

main()
{
  int i;
  float xs[] = {1.,2.,3.,4.,5.};
  float ys[] = {1.,4.,9.,16.,25.};

  DECLARE_INTEGER(unit);
  DECLARE_CHARACTER(file,10);
  DECLARE_INTEGER(nxsub);
  DECLARE_INTEGER(nysub);
  DECLARE_REAL(xmin);
  DECLARE_REAL(xmax);
  DECLARE_REAL(ymin);
  DECLARE_REAL(ymax);
  DECLARE_INTEGER(just);
  DECLARE_INTEGER(axis);
  DECLARE_CHARACTER(xlab,50);
  DECLARE_CHARACTER(ylab,50);
  DECLARE_CHARACTER(toplab,50);
  DECLARE_INTEGER(n);
  DECLARE_REAL_ARRAY(xpnts,60);
  DECLARE_REAL_ARRAY(ypnts,60);
  DECLARE_INTEGER(symbol);


  unit = 0; cnfExprt( "?", file, file_length); nxsub = 1; nysub = 1;
  F77_CALL(pgbegin) ( INTEGER_ARG(&unit), CHARACTER_ARG(file),
                      INTEGER_ARG(&nxsub), INTEGER_ARG(&nysub)
                      TRAIL_ARG(file) );

  xmin = 0.0; xmax = 10.0; ymin = 0.0; ymax = 20.0; just = 0; axis = 1;
  F77_CALL(pgenv) ( REAL_ARG(&xmin), REAL_ARG(&xmax), REAL_ARG(&ymin),
                    REAL_ARG(&ymax), INTEGER_ARG(&just), INTEGER_ARG(&axis) );

  cnfExprt( "(x)", xlab, xlab_length );
  cnfExprt( "(y)", ylab, ylab_length );
  cnfExprt( "PGPLOT Example 1 - y = x\\u2", toplab, toplab_length );
  F77_CALL(pglabel) ( CHARACTER_ARG(xlab), CHARACTER_ARG(ylab),
                      CHARACTER_ARG(toplab)
                      TRAIL_ARG(xlab) TRAIL_ARG(ylab) TRAIL_ARG(toplab) );

  n = 5;
  for( i=0 ; i<n ; i++ )
  {
     xpnts[i] = xs[i];
     ypnts[i] = ys[i];
  }
  symbol = 9;
  F77_CALL(pgpoint) ( INTEGER_ARG(&n), REAL_ARRAY_ARG(xpnts),
                      REAL_ARRAY_ARG(ypnts), INTEGER_ARG(&symbol) );

  n = 60;
  for( i=0 ; i<n ; i++ )
  {
     xpnts[i] = 0.1 * i;
     ypnts[i] = xpnts[i]*xpnts[i];
  }
  F77_CALL(pgline) ( INTEGER_ARG(&n), REAL_ARRAY_ARG(xpnts),
                     REAL_ARRAY_ARG(ypnts) );

  F77_CALL(pgend)();

}
\end{terminalv}
\end{small}

This is a realistic example of calling PGPLOT routines from C\@. The module
begins with a set of function prototypes for the FORTRAN routines that will be
called in the C main program. All variables that need to be passed to FORTRAN
subroutines are declared using
\htmlref{\texttt{DECLARE\_\-\textit{type}}}{DECLARE_type}\/
macros.
These macros ensure that the variables are declared to be of the correct type
and storage size expected by the FORTRAN subroutine.
There then follow the calls to the subroutines that do the actual plotting.
The most notable things about these calls is that the actual arguments are
explicitly passed by address.
This seems strange to a FORTRAN programmer, but is natural to a C programmer.
Arguments that may be modified must always have their addresses passed, not
their values.
It may be thought that the
\htmlref{\texttt{\textit{type}\_ARG}}{type_ARG}
macros should add the \texttt{\&} character where it is needed.
However, this gives rise to problems when calling
FORTRAN from C from FORTRAN, as well as being rather misleading. Note that
scalar arguments need the ampersand character adding, whereas array arguments
do not. This is exactly what would be typed if the called routine were a C
function.

What is clear from this example is that the inability to put arguments that are
constant expressions directly in the call to the routine makes the program a
lot more verbose than the equivalent FORTRAN program. Unfortunately, the
obvious solution of writing an actual argument as something like
\texttt{INTEGER\_ARG(\&5)} does not work as you cannot take the address of a
constant.
This is not a failing of the F77 macros, but is inherent in the C language. For
routines that are called in many places, it will be more convenient to write a
wrap-up function in C that is to be called from the C main program and to put
all of the F77 macros required into that function. This produces less efficient
code, since there is an extra level of subroutine call. However, in many
situations, the extra cost will be outweighed by the benefits of more
transparent code.

The macro
\htmlref{\texttt{F77\_CALL}}{F77_CALL}
actually expands to the same thing as the macro
\htmlref{\texttt{F77\_\-EXTERNAL\_\-NAME}}{F77_EXTERNAL_NAME},
but is included as it is more descriptive of
what is being done when calling a FORTRAN routine from C\@.

\subsection{Thread Safety}
Fortran code is not thread-safe, and therefore any C code that calls
Fortran code will not be thread-safe unless extra work is done to make it
so. The \htmlref{\texttt{F77\_LOCK}}{F77_LOCK} macro is provided for this
purpose. The argument to the macro is a block of code to be run. CNF
defines a single global pthread mutex. The F77\_LOCK macro firsts locks this
mutex, then executes the code specified in its argument, then unlocks the
mutex. If another thread already has the mutex locked, then the calling
thread will block until the mutex is unlocked.

So any C code that may potentially need to be executed in a threaded
context (for instance, C wrappers for Fortran subroutine libraries)
should use the F77\_LOCK macro to invoke each Fortran call:

\begin{small}
\begin{terminalv}
F77_LOCK ( F77_CALL(silly2)( REAL_ARG(&a), REAL_ARG(&b),
                            INTEGER_ARG(&i), INTEGER_ARG(&j),
                            CHARACTER_ARG(fline), INTEGER_ARG(&fline_l),
                            LOGICAL_ARG(&x) TRAIL_ARG(fline) ); )
\end{terminalv}
\end{small}

If this is done consistently, then it ensures that no two threads will
attempt to run any Fortran code simultaneously.

\section{\xlabel{more_on_arrays}More on Arrays}
For most data types arrays are handled simply, using pointers as already
demonstrated. However, for arrays of some types the data in the arrays
must be converted back and forth between C and FORTRAN representations.
Macros and functions are provided to facilitate the conversions.

Very often, the actual size of the FORTRAN array required will not be known
until runtime so space for it must be allocated dynamically in a similar way
to
\htmlref{dynamic character strings}{f77_chardyn}.

Macros
\htmlref{\texttt{DECLARE\_\-\textit{type}\_\-ARRAY\_\-DYN}}
        {DECLARE_type_ARRAY_DYN}
and
\htmlref{\texttt{F77\_CREATE\_type\_ARRAY}}
        {F77_CREATE_type_ARRAY}
are defined to do this.
They are designed for 1-dimensional arrays, having just the name and the number
of elements as parameters, but for Unix systems, at least, will work for
multi-dimensional arrays.

For most types on all current systems, the \texttt{CREATE\_ARRAY} macros
will not actually allocate space as no conversion of data is necessary, but
they are provided for contingency and completeness.

\subsection{\xlabel{character_and_logical_arrays}\label{char_arrays}CHARACTER and LOGICAL Arrays}
There are two versions of the macros for creating dynamic \texttt{CHARACTER}
and \texttt{LOGICAL} arrays:
\htmlref{\texttt{F77\_CREATE\_CHARACTER\_ARRAY}}{F77_CREATE_CHARACTER_ARRAY}
will create a 1-dimensional array with the given number of elements, and
\htmlref{\texttt{F77\_CREATE\_CHARACTER\_ARRAY\_M}}
        {F77_CREATE_CHARACTER_ARRAY\_M}
will create an array whose size is defined by an integer specifying the number
of dimensions and an array of integers specifying each dimension.
Similarly
\htmlref{\texttt{F77\_CREATE\_LOGICAL\_ARRAY}}{F77_CREATE_type_ARRAY}
and
\htmlref{\texttt{F77\_CREATE\_LOGICAL\_ARRAY\_M}}
        {F77_CREATE_LOGICAL_ARRAY\_M}

Consider the following example of a C program which calls a FORTRAN subroutine
which returns a \texttt{CHARACTER} array produced by setting to blank every
non-blank element of a given array for which the corresponding element of a
given \texttt{LOGICAL} array is TRUE. A \texttt{LOGICAL} output array is
produced with \texttt{TRUE} in the element corresponding with each element of
the \texttt{CHARACTER} array which has been reset, and \texttt{FALSE} elsewhere.

\refstepcounter{examples}
\label{cook_reset}
\begin{center}
Example\latex{~\ref{cook_reset}}
-- Import and export of arrays.\@.
\end{center}
\begin{small}
\begin{terminalv}
#include <stdio.h>
#include "f77.h"
F77_SUBROUTINE(str_reset)(CHARACTER_ARRAY(in), LOGICAL_ARRAY(lin),
                          INTEGER(dim1), INTEGER(dim2),
                          CHARACTER_ARRAY(out), LOGICAL_ARRAY(lout)
                          TRAIL(in) TRAIL(out) );

void main(){
char inarr[3][2][4]={{"Yes","No "},{"   ","   "},{"No ","Yes"}};
int inarr_length=4;
char outarr[3][2][4];
int outarr_length=4;
int lin[3][2]={{1,0},{1,1},{0,1}};
int lout[3][2];
DECLARE_CHARACTER_ARRAY(fin,3,2][4);
DECLARE_CHARACTER_ARRAY_DYN(fout);
DECLARE_LOGICAL_ARRAY(flin,3][2);
DECLARE_LOGICAL_ARRAY_DYN(flout);
DECLARE_INTEGER(dim1);
DECLARE_INTEGER(dim2);
int ndims=2;
int dims[2]={3,2};
int i,j;

   F77_CREATE_CHARACTER_ARRAY_M(fout,3,ndims,dims);
   F77_CREATE_LOGICAL_ARRAY_M(flout,ndims,dims);

   (void) cnfExprta(
      (char *)inarr, inarr_length, (char *)fin, fin_length, ndims, dims );
   (void) cnfExpla( (int *)lin, (F77_LOGICAL_TYPE *)flin, ndims, dims );

   dim1 = dims[0];
   dim2 = dims[1];

   F77_CALL(str_reset)( CHARACTER_ARRAY_ARG(fin), LOGICAL_ARRAY_ARG(flin),
                     INTEGER_ARG(&dim1), INTEGER_ARG(&dim2),
                     CHARACTER_ARRAY_ARG(fout), LOGICAL_ARRAY_ARG(flout)
                     TRAIL_ARG(fin) TRAIL_ARG(fout) );

   (void) cnfImprta
           ( fout, fout_length, outarr[0][0], outarr_length, ndims, dims );
   (void) cnfImpla( (F77_LOGICAL_TYPE *)flout, (int *)lout, ndims, dims );

   F77_FREE_CHARACTER(fout);
   F77_FREE_LOGICAL(flout);

   printf("i j in  lin out lout\n");
   for (j=0;j<3;j++){
      for (i=0;i<2;i++){
         printf("%d %d %c  %s  %c  %s\n",
            i, j, lin[j][i]?'T':'F', inarr[j][i],
                  lout[j][i]?'T':'F', outarr[j][i] );
      }
   }
}
\end{terminalv}
\end{small}

\begin{small}
\begin{terminalv}
      SUBROUTINE STR_RESET( ARRAY, LIN, DIM1, DIM2, OUT, LOUT )
*  Purpose:
*     Reset elements of an array

*  Arguments:
*     ARRAY(2,3)=CHARACTER*(*) (Given)
*        The array to be altered
*     LIN(2,3)=LOGICAL (Given)
*        The given LOGICAL array
*     DIM1=INTEGER (Given)
*        The first dimension of the arrays
*     DIM2=INTEGER (Given)
*        The second dimension of the arrays
*     OUT(2,3)=CHARACTER*(*) (Returned)
*     LOUT(2,3)=LOGICAL (Returned)

      IMPLICIT NONE
      INTEGER I, J
      INTEGER DIM1, DIM2
      CHARACTER*(*) ARRAY(2,3)
      CHARACTER*(*) OUT(2,3)
      LOGICAL LIN(2,3)
      LOGICAL LOUT(2,3)

      DO 20, J = 1, 3
         DO 10, I = 1, 2
            IF( LIN(I,J) .AND. (ARRAY(I,J) .NE. ' ') )THEN
               OUT(I,J) = ' '
               LOUT(I,J) = .TRUE.
            ELSE
               OUT(I,J) = ARRAY(I,J)
               LOUT(I,J) = .FALSE.
            END IF
10       ENDDO
20    ENDDO

      END
\end{terminalv}
\end{small}

As an example of how to write a C function to be called from FORTRAN with array
arguments, the above subroutine could be re-written in C as follows:

\begin{small}
\begin{terminalv}
#include "f77.h"

F77_SUBROUTINE(str_reset)(CHARACTER_ARRAY(in_f), LOGICAL_ARRAY(lin_f),
                          INTEGER(dim1), INTEGER(dim2),
                          CHARACTER_ARRAY(out_f), LOGICAL_ARRAY(lout_f)
                          TRAIL(in_f) TRAIL(out_f) )
{
GENPTR_CHARACTER_ARRAY(in_f)
GENPTR_LOGICAL_ARRAY(lin_f)
GENPTR_INTEGER(dim1)
GENPTR_INTEGER(dim2)
GENPTR_CHARACTER_ARRAY(out_f)
GENPTR_LOGICAL_ARRAY(lout_f)

int i, j, nels, cpt;
char *in_c, *out_c;
int *lin_c, *lout_c;
int ndims=2;
int dims[2];

   dims[0] = *dim1;
   dims[1] = *dim2;
   nels = *dim1 * *dim2;

   in_c = cnfCreat( nels*(in_f_length+1) );
   out_c = cnfCreat( nels*(out_f_length+1) );
   lin_c = (int *)malloc( nels*sizeof(int) );
   lout_c = (int *)malloc( nels*sizeof(int) );
   cnfImprta( in_f, in_f_length, in_c, in_f_length+1, ndims, dims );
   cnfImpla( lin_f, lin_c, ndims, dims );

   cpt = 0;
   for(i=0;i<nels;i++){
      if( *(lin_c+i) && strlen( in_c+cpt ) ) {
          strcpy(out_c+cpt,"");
          *(lout_c+i) = 1;
      } else {
          strcpy( out_c+cpt, in_c+cpt );
          *(lout_c+i) = 0;
      }
      cpt += in_f_length+1;
   }

   cnfExprta( out_c, out_f_length+1, out_f, out_f_length, ndims, dims );
   cnfExpla( lout_c, lout_f, ndims, dims );

   cnfFree( in_c );
   cnfFree( out_c );
   free( lin_c );
   free( lout_c );
}
\end{terminalv}
\end{small}

\subsection{\xlabel{arrays_of_pointer_to_char}\label{char_ptrs}Arrays of \texttt{pointer to char}}
In C, arrays of character strings are often held as arrays of
\texttt{pointer to char}.
This allows strings of varying length and not necessarily in contiguous
memory.
CNF functions
\htmlref{\texttt{cnfImprtap}}{cnfImprtap}
and
\htmlref{\texttt{cnfExprtap}}{cnfExprtap}
can be used to import/export arrays of pointer to char from/to
FORTRAN \texttt{CHARACTER} arrays.
The following example shows how to do this. The FORTRAN subroutine, PRARR,
prints the given \texttt{CHARACTER} array and returns it set to blank strings.
The C program prints the strings before and after the call to PRARR.

\refstepcounter{examples}
\label{cook_exprtap}
\begin{center}
Example\latex{~\ref{cook_exprtap}}
-- IMPORT/EXPORT with arrays of pointers to char.
\end{center}
\begin{small}
\begin{terminalv}
rlsaxp_101% more temp.c
#include "f77.h"
F77_SUBROUTINE(prarr)(CHARACTER_ARRAY(arr) TRAIL(arr));
main() {
DECLARE_CHARACTER_ARRAY(arr,12,3);
char *ptr[3]={"ajc","hello there","TEXT"};
int dims[1]=3;
int i;

for (i=0;i<3;i++) printf("%d:%s:\n",i,ptr[i]);
cnfExprtap(ptr,arr[0],12,1,dims);
F77_CALL(prarr)(CHARACTER_ARRAY_ARG(arr) TRAIL_ARG(arr));
cnfImprtap(arr[0],12,ptr,1,1,dims);
for(i=0;i<3;i++) printf("%d:%s:\n",i,ptr[i]);
}
\end{terminalv}
\end{small}
\begin{small}
\begin{terminalv}
      SUBROUTINE PRARR( ARR )
      CHARACTER*(*) ARR(3)
      INTEGER I

      DO 10
         PRINT *, ':', ARR(I), ':'
         ARR( I ) = ' '
10    CONTINUE
      END
\end{terminalv}
\end{small}

\subsection{\xlabel{pointer_arrays}POINTER Arrays}
An array of pointers would need to be converted back and forth between
the C and FORTRAN representations to cope with the possibility that
the length of a C pointer is not the same as the length of a FORTRAN
\texttt{INTEGER}. This can be done by declaring a suitably-sized
FORTRAN array and converting each element using either
\htmlref{\texttt{cnfCptr}}{cnfCptr}
or
\htmlref{\texttt{cnfFptr}}{cnfFptr},
according to the direction of conversion.

For example, to call a FORTRAN subroutine which returns an array of three
pointers to real, the C code would need to be something like:
\begin{small}
\begin{terminalv}
F77_REAL_TYPE * pntr[3]
DECLARE_POINTER_ARRAY(fpntr,3)

F77_CALL(getptr)(POINTER_ARRAY_ARG(fpntr))
/* Import the pointers to C */
for (i=0;i<3;i++) pntr[i]=(F77_REAL_TYPE *)cnfCptr(fpntr[i]);
\end{terminalv}
\end{small}

See also
\htmlref{The IMPORT and EXPORT macros}{import_export}\latex{ (Section
\ref{import_export})}.

\section{\xlabel{the_import_and_export_macros}\label{import_export}The IMPORT and EXPORT Macros}
We have already seen that character strings and \texttt{LOGICAL} and
\texttt{POINTER} variables
have to be converted between the different forms used by FORTRAN and C, and
the idea of ``importing'' a FORTRAN value to a C value, and ``exporting'' a C
value to a FORTRAN value has been introduced with the CNF routines..

Potentially all the other types could differ so macros
\htmlref{\texttt{F77\_\-IMPORT\_\-\textit{type}}}{F77_IMPORT_type},
\htmlref{\texttt{F77\_\-IMPORT\_\-\textit{type}\_\-ARRAY}}
{F77_IMPORT_type_ARRAY},
\htmlref{\texttt{F77\_\-EXPORT\_\-\textit{type}}}{F77_EXPORT_type}
and
\htmlref{\texttt{F77\_\-EXPORT\_\-\textit{type}\_\-ARRAY}}
{F77_EXPORT_type_ARRAY}
are defined to copy the data as required -- they will use CNF routines
where appropriate. An additional \texttt{\textit{type}} of \texttt{LOCATOR}
is allowed for the \texttt{IMPORT/EXPORT} macros to handle character strings
used as
\htmlref{HDS locators}{locators}.
There are also macros
\htmlref{\texttt{F77\_\-IMPORT\_\-CHARACTER\_\-ARRAY\_P}}
        {F77_IMPORT_CHARACTER_ARRAY_P}
and
\htmlref{\texttt{F77\_\-EXPORT\_\-CHARACTER\_\-ARRAY\_P}}
        {F77_EXPORT_CHARACTER_ARRAY_P}
to handle the CHARACTER conversion if the C array is an
\htmlref{array of pointers to char}{char_ptrs}.

The \texttt{IMPORT/EXPORT\_ARRAY} macros have arguments giving pointers to
the data and the number of elements to be converted. This is assumed to be
sufficient for both single and multi-dimensional arrays.

These macros impose a slight overhead in that they require both the FORTRAN and
C variables to be set up and some copying done, even when this is not strictly
necessary.
However, they do protect against possible future problems and ease the
problem of deciding whether and how the import/export should be done.

In the case of arrays, only pointers are copied unless a conversion really is
required (as in the case of \texttt{CHARACTER} and \texttt{LOGICAL} arrays, for
example).

A complication arises where the actual argument for a FORTRAN subroutine to be
called from C is an array which is only returned.
In that case, no exporting is
required but the FORTRAN array must still be associated with the C array so
that the FORTRAN subroutine knows where to store the results.
For those types which require genuine conversion, a pointer to the FORTRAN
array will have been set when the space was allocated but for others the
pointer must be set to point to the actual C array.
Macros
\htmlref{\texttt{F77\_\-ASSOC\_\-\textit{type}\_\-ARRAY}}
{F77_ASSOC_type_ARRAY}
are defined to do this where necessary.
They are complementary to the
\htmlref{\texttt{F77\_\-CREATE\_\-\textit{type}\_\-ARRAY}}
{F77_CREATE_type_ARRAY}
macros so you can include both to ensure that the pointer to the FORTRAN array
is set correctly.

After use, the memory holding the FORTRAN array should be returned using an
\htmlref{\texttt{F77\_\-FREE\_\-\textit{type}}}{F77_FREE_type}
macro (which will do nothing if the \texttt{CREATE} macros for the type do not
allocate space).

So, a C wrapper for the FORTRAN routine \texttt{str\_reset} in the section on
\htmlref{Handling \texttt{CHARACTER} and \texttt{LOGICAL} arrays}{char_arrays}
could be written as follows:

\refstepcounter{examples}
\label{cook_resetwrap}
\begin{center}
Example\latex{~\ref{cook_resetwrap}}
-- Use of \texttt{IMPORT/EXPORT} macros\@.
\end{center}
\begin{small}
\begin{terminalv}
#include "f77.h"
F77_SUBROUTINE(str_reset)( CHARACTER_ARRAY(array),
                           LOGICAL_ARRAY(lin),
                           INTEGER(dim1),
                           INTEGER(dim2),
                           CHARACTER_ARRAY(out),
                           LOGICAL_ARRAY(lout)
                           TRAIL(array)
                           TRAIL(out) );

void strReset( char *array,
               int array_length,
               int *lin,
               int dim1,
               int dim2,
               char *out,
               int out_length,
               int *lout ) {

DECLARE_CHARACTER_ARRAY_DYN(farray);
DECLARE_LOGICAL_ARRAY_DYN(flin);
DECLARE_INTEGER(fdim1);
DECLARE_INTEGER(fdim2);
DECLARE_CHARACTER_ARRAY_DYN(fout);
DECLARE_LOGICAL_ARRAY_DYN(flout);
int nels;

/* The dimensions of the arrays are being lied about */
/* calculate the number of elements */
   nels = dim1 * dim2;

/* Set up "given" arguments */
   F77_CREATE_CHARACTER_ARRAY( farray, array_length-1, nels );
   F77_EXPORT_CHARACTER_ARRAY(array, array_length, farray, farray_length, nels);
   F77_CREATE_LOGICAL_ARRAY( flin, nels );
   F77_EXPORT_LOGICAL_ARRAY( lin, flin, nels );
   F77_EXPORT_INTEGER( dim1, fdim1 );
   F77_EXPORT_INTEGER( dim2, fdim2 );
/* Set up "returned" arguments */
   F77_CREATE_CHARACTER_ARRAY( fout, out_length-1, nels );
   F77_ASSOC_CHARACTER_ARRAY( fout, out );
   F77_CREATE_LOGICAL_ARRAY( flout, nels );
   F77_ASSOC_LOGICAL_ARRAY( flout, lout );

   F77_CALL(str_reset)( CHARACTER_ARRAY_ARG(farray),
                        LOGICAL_ARRAY_ARG(flin),
                        INTEGER_ARG(&fdim1),
                        INTEGER_ARG(&fdim2),
                        CHARACTER_ARRAY_ARG(fout),
                        LOGICAL_ARRAY_ARG(flout)
                        TRAIL_ARG(farray)
                        TRAIL_ARG(fout) );

   F77_FREE_CHARACTER( farray );
   F77_FREE_LOGICAL( flin );
   F77_IMPORT_CHARACTER_ARRAY( fout, fout_length, out, out_length, nels );
   F77_FREE_CHARACTER( fout );
   F77_IMPORT_LOGICAL_ARRAY( flout, lout, nels );
   F77_FREE_LOGICAL( flout );

   return;
}
\end{terminalv}
\end{small}
and the corresponding main routine would be:
\begin{small}
\begin{terminalv}
#include <stdio.h>
#include "f77.h"
void strReset( char *array,
               int array_length,
               int *lin,
               int dim1,
               int dim2,
               char *out,
               int out_length,
               int *lout );

void main(){
char inarr[3][2][4]={{"Yes","No "},{"   ","   "},{"No ","Yes"}};
int inarr_length=4;
char outarr[3][2][4];
int outarr_length=4;
int lin[3][2]={{1,0},{1,1},{0,1}};
int lout[3][2];
int i,j;

   strReset(&inarr[0][0][0], 4, &lin[0][0], 3, 2,
            &outarr[0][0][0], 4, &lout[0][0] );

   printf("i j in  lin out lout\n");
   for (j=0;j<3;j++){
      for (i=0;i<2;i++){
         printf("%d %d %c  %s  %c  %s\n",
            i, j, lin[j][i]?'T':'F', inarr[j][i],
                  lout[j][i]?'T':'F', outarr[j][i] );
     }
   }
}
\end{terminalv}
\end{small}

\section{\xlabel{subroutines_and_functions_as_arguments}\label{f77_externalargs}Subroutines and Functions as Arguments}

Macros are provided to handle subroutine and function names passed as
arguments. They correspond closely to the macros for handling normal data
type arguments.
The following example shows how to pass the name of an INTEGER function from
a C program to a FORTRAN subroutine.

\refstepcounter{examples}
\label{cook_namectof}
\begin{center}
Example\latex{~\ref{cook_namectof}}
-- Passing names from C to FORTRAN.
\end{center}
A C program which calls a FORTRAN subroutine which needs the name of an INTEGER
function as an argument.
\begin{small}
\begin{terminalv}
#include "f77.h"

extern F77_SUBROUTINE(tst_ifun)( INTEGER_FUNCTION(name),
                                 INTEGER(status) );

extern F77_INTEGER_FUNCTION(ifun)();

main(){
DECLARE_INTEGER(status);

   status = 0;

   F77_CALL(tst_ifun)( INTEGER_FUNCTION_ARG(ifun),
                        INTEGER_ARG(&status) );

   printf( "Status set is: %d\n", status );

}
\end{terminalv}
\end{small}
The FORTRAN subroutine:
\begin{small}
\begin{terminalv}
*+ TST_IFUN - Call an integer function
      SUBROUTINE TST_IFUN( NAME, STATUS )

      INTEGER NAME
      EXTERNAL NAME
      INTEGER STATUS

      INTEGER I

      STATUS = NAME( STATUS )

      END
\end{terminalv}
\end{small}
The INTEGER function:
\begin{small}
\begin{terminalv}
*+ IFUN - A very simple FORTRAN INTEGER FUNCTION
      INTEGER FUNCTION IFUN( STATUS )

      INTEGER STATUS

      IFUN = STATUS + 99

      END
\end{terminalv}
\end{small}
Corresponding macros are defined for other types of function and for
FORTRAN subroutines.

Now suppose in the above example the subroutine TST\_IFUN was written in C to
be called from FORTRAN. The code would be something like:

\refstepcounter{examples}
\label{cook_nameftoc}
\begin{center}
Example\latex{~\ref{cook_nameftoc}}
-- Passing names from FORTRAN to C.
\end{center}

\begin{small}
\begin{terminalv}
*+ TESTIFUN - Call a SUBROUTINE which requires a function name argument.
      PROGRAM TSTIFUN

      EXTERNAL IFUN
      INTEGER STATUS

      CALL TST_IFUN( IFUN, STATUS )
      PRINT *, 'STATUS is: ', STATUS

      END
\end{terminalv}
\end{small}
\begin{small}
\begin{terminalv}
#include "f77.h"

F77_INTEGER_FUNCTION(ifun)();

F77_SUBROUTINE(tst_ifun)(INTEGER_FUNCTION(name), INTEGER(status) ){

GENPTR_INTEGER_FUNCTION(name)
GENPTR_INTEGER(status)

*status = F77_EXTERNAL_NAME(name)( INTEGER_ARG(status) );
\end{terminalv}
\end{small}


\section{\xlabel{other_approaches_to_mixed_language_programming}Other Approaches to Mixed Language Programming}

The F77 macros and CNF functions described in this document provide a
complete way of writing portable programs in a mixture of FORTRAN and C\@.
All of the work necessary to provide the correct interface goes into writing
the C routines. It is relatively painless to call C from FORTRAN, since the
work of writing the interface need only be done once, but it can be annoying to
have to write a lot of extra code every time that a FORTRAN routine is called
from a C one.
As mentioned in
\htmlref{More on Calling FORTRAN from C}{f77_ffromc}
\latex{(Section~\ref{f77_ffromc})}, it may be appropriate to write
wrap-around routines when calling FORTRAN from C\@.

Another package that tackles the problem of mixing C and FORTRAN is one called
CFORTRAN, written by Burkhard Burow of the University of Toronto. This will be
available as part of the CERN library and could be provided on Starlink if
required. This package allows you to write an interface layer between a user's
code and a subroutine package such that neither side need be aware that the
other is written in a foreign language. This is a crucial difference from the
F77 macros, where the C code is written in the full knowledge that the function
is being called from, or is to call, a FORTRAN routine. It is certainly
possible to write a package that can be called either from FORTRAN or C using
the F77 macros, but this does not occur automatically.

When using CFORTRAN, an extra level of subroutine call is always involved over
what is strictly necessary using the macros described in this document. This
results in less efficient code. However, when this is not a serious problem,
there may be situations in which it is more appropriate to use the CFORTRAN
system in preference to F77.

\section{\xlabel{compiling_and_linking}Compiling and Linking\label{compiling_and_linking}}

Unless they are passing pointers to subprograms, FORTRAN programs do not need
to be compiled in any special way when employing mixed language programming
since they are not aware that the subprogram that they are calling is not
written in FORTRAN\@. However, when pointers are passed using the mechanism
described in
\htmlref{Accessing Dynamic Memory from C and
FORTRAN}{percentval}\latex{ (Section~\ref{percentval})},
the FORTRAN code must include the statement:
\begin{terminalv}
INCLUDE 'CNF_PAR'
\end{terminalv}
to define the function \texttt{CNF\_PVAL}.

Type:
\begin{terminalv}
% cnf_dev
\end{terminalv}
to define the link, \texttt{CNF\_PAR}, to the required include file.

When compiling a C function that is
to be called from FORTRAN, it should contain the line:

\begin{terminalv}
#include "f77.h"
\end{terminalv}

to define the F77 macros and CNF functions\footnote{The two CNF header files,
\texttt{cnf.h} and \texttt{f77.h} are now identical. For legacy reasons
it is acceptable to \texttt{\#include} either or both in the code -- just
\texttt{f77.h} is preferred.}.

On a Unix system, you can usually tell the C compiler where to look for
header files with the \texttt{-I} qualifier to the cc command,
\textit{e.g.}:

\begin{terminalv}
% cc -I/star/include -c func.c
\end{terminalv}

All FORTRAN \texttt{INCLUDE} and C header files for Starlink software are
stored in the directory \texttt{/star/include}, and the object files for all
Starlink libraries reside in \texttt{/star/lib}.

To link a FORTRAN program \texttt{prog.f} and a C function \texttt{sub.c} with
the CNF library, first compile the C function and then compile and link the
FORTRAN program:

\begin{terminalv}
% cc -c -I/star/include sub.c
% f77 prog.f sub.o -L/star/lib `cnf_link` -o prog
\end{terminalv}

To link a C program \texttt{prog.c} with a FORTRAN subroutine \texttt{sub.f},
the procedure varies depending upon the system being used.
It is usually best to try to do the link with the \texttt{f77} command as the
correct FORTRAN libraries will then be searched.
However, in some cases there is confusion over the main routine and either
\texttt{cc} or \texttt{ld} must be used specifying all the required libraries.

For example, on Alpha/OSF1 it might be:

\begin{terminalv}
% f77 -c sub.f
% cc prog.c sub.o -L/star/lib `cnf_link` -lfor -lots -o prog
\end{terminalv}

For
\xref{ADAM}{sg4}{}
tasks\latex{ (see SG/4)}, much of the complication is removed by the task
linking scripts
\xref{alink and ilink}{sun144}{ADAM_link_scripts} which will accept a mixture of
FORTRAN and C modules to compile. For example:
\begin{terminalv}
% alink task.f subr.c ...
\end{terminalv}
or
\begin{terminalv}
% alink task.c subr.f ...
\end{terminalv}
The CNF library will be linked automatically and \texttt{/star/include} searched
for any required C header files.

The first program module specified for the ADAM link script must be the main
routine of the ADAM task, which is written as a FORTRAN subroutine or C function
with a single \texttt{INTEGER}, or \texttt{int *}, argument (see
\xref{SUN/144}{sun144}{ADAM_link_scripts}
for details).

\appendix
\newpage

\section{\xlabel{implementation_specific_details}\label{implement}Implementation Specific Details}

As indicated several times earlier, many of the details of mixed language
programming are implementation dependent. This section will deal in turn with
each type of hardware that Starlink possesses. Given that programs can be
written in a portable way, you may wonder if you need to know about the
implementation specific details at all. This is in fact necessary when
debugging programs, since the debugger will be working on the output of any
macros that hide the implementation specific details from the programmer.

There is some duplication between the following subsections, one for each type
of operating system, particularly in the examples. This has been done so that
each section can be read separately from any other.

\subsection{\xlabel{sun}Sun}

\subsubsection{General}

A Sun computer is based on a 32 bit architecture. Data can be addressed in
multiples of 1, 2, 4, 8 or 16 bytes, a byte being 8 bits. References to FORTRAN
and C in this subsection refer to the Sun~FORTRAN and ANSI~C compilers.

\subsubsection{Data Types}

There is a simple correspondence between Sun FORTRAN and C numeric variable
types.
The standard types are given in the upper part of


\latex{Table~\ref{sun_datatypes}} and
non-standard extensions in the lower part. These should generally be avoided
for reasons of portability, however, they are provided since
\xref{HDS}{sun92}{} \latex{(see SUN/92)}
has corresponding data types.

\begin{table}[htb]
\begin{center}
\begin{tabular}{|l|l|l|} \hline
\multicolumn{1}{|c|}{\textit{type}} & \multicolumn{1}{|c|}{Sun~FORTRAN} &
\multicolumn{1}{c|}{Sun C} \\ \hline
INTEGER & INTEGER & int \\
REAL & REAL & float \\
DOUBLE & DOUBLE PRECISION & double \\
LOGICAL & LOGICAL & int \\
 & CHARACTER*1 & char \\
CHARACTER & CHARACTER*n & char[n] \\ \hline
BYTE & BYTE & signed char \\
WORD & INTEGER*2 & short int\\
UBYTE && unsigned char \\
UWORD && unsigned short int\\ \hline
POINTER & INTEGER & unsigned int\\ \hline
\end{tabular}
\end{center}
\caption{Corresponding data types for Sun Solaris}
\label{sun_datatypes}
\end{table}

Although C defines unsigned data types of \texttt{unsigned char}
(range 0 to 255), \texttt{unsigned short} (range 0 to 32767) and
\texttt{unsigned int} (range 0 to $2^{32}-1$), there are no corresponding
unsigned data types in FORTRAN\@.
There is also a C type called \texttt{long int}, however on Suns, this is the
same as an \texttt{int}.

The C language does not specify whether variables of type \texttt{char} should
be stored as signed or unsigned values. On Suns, they are stored as signed
values in the range -128 to 127.

Similarly there is no C data type that corresponds to the FORTRAN data type of
\texttt{COMPLEX}\@. However, since Sun~FORTRAN passes all numeric variable by
reference, a \texttt{COMPLEX} variable could be passed to a C subprogram where
it might be handled as a structure consisting of two variables of type
\texttt{float}.

A Sun~FORTRAN \texttt{LOGICAL} value can be passed to a C \texttt{int}.
Sun~FORTRAN and C both use zero to represent a false value and anything else
to represent a true value, so there is no problem with converting the data
values.

\subsubsection{External Names}

The Sun~FORTRAN compiler appends an underscore character to all external names
that it generates.
This applies to the names of subroutines, functions, labelled common blocks
and block data subprograms.

\subsubsection{\label{sun_arg}Arguments}

To understand how to pass arguments between Sun~FORTRAN and C programs, it is
necessary to understand the possible methods that the operating system can use
for passing arguments and how each language makes use of them. There are three
ways that an actual argument may be passed to a subroutine. What is actually
passed as an argument should always be a four byte word. It is the
interpretation of that word that is where the differences arise.

Sun~FORTRAN passes all data types other than \texttt{CHARACTER} by reference,
\textit{i.e.}\ the address of the variable or array is put in the argument list.
\texttt{CHARACTER} variables are passed by  a mixture of reference and value.
The argument list contains the address of the character variable being passed,
but there is also an extra argument added at the end of the argument list for
each character variable.
This gives the actual length of the FORTRAN \texttt{CHARACTER} variable and so
this datum is being passed by value. These extra arguments are hidden from the
FORTRAN programmer, but must be explicitly included in any C routines.

C uses call by value to pass all variables, constants (except string
constants), expressions, array elements, structures and unions that are actual
arguments of functions. It uses call by reference to pass whole arrays, string
constants and functions. C never uses call by descriptor as a default.

To pass a C variable of type \texttt{double} by value requires the use of two
longwords in the argument list. Similarly, if a C structure is passed by value,
then the number of bytes that it takes up in the argument list can be large.
This is a dangerous practice and all structures should be passed by reference.
Since, by default, Sun~FORTRAN does not pass variables by value anyway, this
should not give rise to any problems.

In Sun~FORTRAN, the default argument passing mechanism can be overridden by use
of the \texttt{\%VAL} and \texttt{\%REF} functions. These functions are not portable
and should be avoided whenever possible. The \texttt{\%DESCR} function provided in
VAX~FORTRAN is \textit{not}\, provided on a Sun. In C there is no similar way of
``cheating'' as there is in FORTRAN; however, this is not necessary as the
language allows more flexibility itself. For example, if you wish to pass a
variable named \texttt{x} by reference rather than by value, you simply put
\texttt{\&x} as the actual argument instead of \texttt{x}.

Since C provides more flexibility in the mechanism of passing arguments than
does FORTRAN, it is C that ought to shoulder the burden of handling the
different mechanisms. All numeric variables and constants, array elements,
whole arrays and function names should be passed into and out of C functions by
reference. Numeric expressions will be passed from FORTRAN to C by reference
and so the corresponding dummy argument in the C function should be declared to
be of type ``pointer to type''. When C has a constant or an expression as an
actual argument in a function call, it can only pass it by value. Sun~FORTRAN
cannot cope with this and so in a C program, all expressions should be assigned
to variables before being passed to a FORTRAN routine.

Here are some examples to illustrate these points.

\refstepcounter{examples}
\label{sun_f2c}
\begin{center}
Example\latex{~\ref{sun_f2c}}
-- Passing arguments from Sun~FORTRAN to C\@.
\end{center}
\nopagebreak[4]
FORTRAN program:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
      PROGRAM FORT1
      INTEGER A
      REAL B
      A = 1
      B = 2.0
      CALL C1( A, B )
      END
\end{terminalv}
\end{small}
\pagebreak[1]
C function:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
void c1_( int *a, float *b)
{
  int x;
  float y;

  x = *a;    /* x is now equal to 1 */
  y = *b;    /* y is now equal to 2.0 */

  printf( "x = %d\n", x );
  printf( "y = %f\n", y );
}
\end{terminalv}
\end{small}

The C function name requires the underscore as the FORTRAN compiler generates
this automatically.

In this first example, a Sun~FORTRAN program passes an \texttt{INTEGER} and
\texttt{REAL} variable to a C function.
The values of these arguments are then assigned to
two local variables. They could just as well have been used directly in the
function by referring to the variables \texttt{*a} and \texttt{*b} instead of
assigning their values to the local variables \texttt{x} and \texttt{y}.
Since the FORTRAN program passes the actual arguments by reference, the dummy
arguments used in the declaration of the C function should be a pointer to the
variable that is being passed.

Now an example of calling a Sun~FORTRAN subroutine from C\@.

\refstepcounter{examples}
\label{sun_c2f}
\begin{center}
Example\latex{~\ref{sun_c2f}}
-- Passing arguments from C to Sun~FORTRAN\@.
\end{center}
\nopagebreak[4]
C main program:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
main()
{
 int  i = 2;             /* Declare i and initialize it.  */
 void fort2_( int *i );  /* Declare function fort2_. */

 fort2_( &i );           /* Call fort2.  */
}
\end{terminalv}
\end{small}
\pagebreak[1]
FORTRAN subroutine:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
      SUBROUTINE FORT2( I )
      INTEGER I

      PRINT *,I

      END
\end{terminalv}
\end{small}

The C main function declares and initializes a variable, \texttt{i}, and declares
a function \texttt{fort2\_} (note the underscore). It calls \texttt{fort2\_}, passing
the address of the variable \texttt{i} rather than its value, as this is what the
FORTRAN subroutine will be expecting.

As we have seen, the case of scalar numeric arguments is fairly
straightforward, however, the passing of character variables between Sun~FORTRAN
and C is more complicated. Sun~FORTRAN passes character variables by passing the
address of the character variable and then adding an extra value to the
argument list that is the size of the character variable.  Furthermore, there
is the point that FORTRAN deals with fixed-length, blank-padded strings,
whereas C deals with variable-length, null-terminated strings. The simplest
possible example of a character argument is given here as an illustration.
Don't worry if it looks complicated, the
\htmlref{F77 macros }{f77_cfromf}
\latex{described in Section~\ref{f77_cfromf}} hide all
of these details from the programmer, and in a portable manner as well!

\refstepcounter{examples}
\label{sun_char}
\begin{center}
Example\latex{~\ref{sun_char}}
-- Passing character arguments from Sun~FORTRAN to C\@.
\end{center}
\nopagebreak[4]
FORTRAN program:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
      PROGRAM FORT3
      CHARACTER STR*20

      CALL C3( STR )
      PRINT *,STR

      END
\end{terminalv}
\end{small}
\pagebreak[1]
C function:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
#include <stdio.h>                      /* Standard I/O functions */

void c3_( char *fortchar, int length )
{
  int  i;                              /* A loop counter */
  char  *string = "This is a string";  /* A string to be printed */

/* Copy the string to the function argument */
  strncpy( fortchar, string, length );

/* Pad the character argument with trailing blanks */
  for( i = strlen( string ) ; i < length ; i++ )
     fortchar[i] = ' ';
}
\end{terminalv}
\end{small}

The second variable declaration in the C subprogram declares a local variable
to be a string and initializes it. This string is then copied to the storage
area that the subprogram argument points to, taking care not to copy more
characters than the argument has room for. Finally any remaining space in the
argument is filled with blanks, the null character being overwritten. You
should always fill any trailing space with blanks in this way.

\subsubsection{Function Values}

The way that the return value of a function is handled is very much like a
simple assignment statement. The value is actually returned in one or two of
the registers of the CPU, depending on the size of the data type. Consequently
there is no problem in handling the value of any function that returns a
numerical value as long as the storage used by the value being returned and the
value expected correspond
(see Table~\ref{sun_datatypes}\latex{ on page~\pageref{sun_datatypes}}).

The case of a function that returns a character string is more complex. The way
that Sun~FORTRAN returns a character variable as a function value is to add two
hidden extra entries to the beginning of the argument list. These are a pointer
to a character variable and the value of the length of this variable. If a C
function wishes to emulate a FORTRAN \texttt{CHARACTER} function, then you must
explicitly add these two extra arguments to the C function. Any value that the
C function returns will be ignored. Here is an example to illustrate this.

\refstepcounter{examples}
\label{sun_charfn}
\begin{center}
Example\latex{~\ref{sun_charfn}}
-- Use of a Sun~FORTRAN character function.
\end{center}
\nopagebreak[4]
FORTRAN program:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
      PROGRAM CFUNC
      CHARACTER*(10) VAR, FUNC

      VAR = FUNC( 6 )
      PRINT *, VAR

      END
\end{terminalv}
\end{small}
\pagebreak[1]
C function:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
void func_( char *retval, int length, int *n )
{
  char *cp;
  int i, max;

/* Find the number of characters to be copied.  */
  if( *n < length )
     max = *n;
  else
     max = length;

/* Set a local character pointer equal to the return address.  */
  cp = retval;

/* Copy some asterisks to the "return value".  */
  for( i = 0 ; i < max ; i++ )
     *cp++ = '*';

/* Fill the rest of the string with blanks.  */
  for( ; i < length ; i++ )
     *cp++ = ' ';
}
\end{terminalv}
\end{small}

The C function copies some asterisks into the location that Sun~FORTRAN will
interpret as the return value of the FORTRAN \texttt{CHARACTER} function.
The number of
such asterisks is specified by the single argument of the FORTRAN function and
the rest of the string is filled with blanks.

\subsubsection{Global Data}

Although FORTRAN and C use different method for representing global data, it is
actually very easy to mix them. If a Sun~FORTRAN common block contains a single
variable or array, then the corresponding C variable simply needs to be
declared as \texttt{extern} and the two variables will use the same storage.

\refstepcounter{examples}
\label{sun_common}
\begin{center}
Example\latex{~\ref{sun_common}}
-- A labelled Sun~FORTRAN common block containing a
single variable.
\end{center}
\nopagebreak[4]
FORTRAN common block:
\begin{small}
\begin{terminalv}
      CHARACTER*(10) STRING
      COMMON /BLOCK/ STRING
\end{terminalv}
\end{small}

C external variable:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
extern char block_[10];
\end{terminalv}
\end{small}

Note that the name of the C variable corresponds to the name of the FORTRAN
common block, not the name of the FORTRAN variable. This example shows that you
can use the same storage area for both Sun~FORTRAN and C strings, however, you
must still beware of the different way in which FORTRAN and C handle the end of
a string.

If the FORTRAN common block contains more than one variable or array, then the
C variables must be contained in a structure.

If you wish to access the Sun~FORTRAN blank common block, then the
corresponding C structure should be called \texttt{\_BLNK\_\_}.

\refstepcounter{examples}
\label{sun_common2}
\begin{center}
Example\latex{~\ref{sun_common2}}
-- A labelled Sun~FORTRAN common block containing several variables.
\end{center}
\nopagebreak[4]
FORTRAN common block:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
      INTEGER I,J,K
      COMMON /NUMS/ I,J,K
\end{terminalv}
\end{small}

C external variable:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
extern struct { int i,j,k; } nums_;
\end{terminalv}
\end{small}

\subsection{\xlabel{dec_unix}DEC Unix}
\subsubsection{General}
This section applies for Alpha OSF/1, Ultrix/RISC and possibly other DEC
Unix systems.

The machine specific details relating to mixed language programming are
almost identical to those for the Sun and so the previous subsection should be
consulted for more details. This is not to say that there are no differences
between the DECstation and Sun compilers, merely that they do not generally
impinge on the question of mixed language programming.

\subsubsection{LOGICAL Values}
One place where the DEC system may differ from the Sun is in how logical
values are handled. The original FORTRAN compiler for the DECstation (FORTRAN
for RISC) used the Sun interpretation of logical values, \textit{i.e.}\ zero is
false, non-zero is true. The more recent DEC~FORTRAN compiler uses the VMS
convention that only checks the lowest bit of a value, so 0 is false, 1 is
true, 2 is false, 3 is true, \textit{etc}.
When DEC~FORTRAN sets a \texttt{LOGICAL} variable to \texttt{TRUE}, all the
bits in the data are set to 1, resulting in a numerical equivalent value of -1.
Unfortunately this means that the correct value of the
macros
\htmlref{\texttt{F77\_ISFALSE}}{F77_ISFALSE}
and
\htmlref{\texttt{F77\_ISTRUE}}{F77_ISTRUE}
used in a C function, depend on which FORTRAN compiler you are using.
It is not possible to handle this
automatically, so you must be sure to use the right values for the macros. The
default assumption is that you are using the newer DEC~FORTRAN compiler.
Fortunately this is unlikely to be a problem in practice,
since a \texttt{TRUE} value will normally be 1 or -1, and these values will be
handled correctly by either compiler.

\subsubsection{POINTERS on Alphas}
The DEC Alpha machines can use addresses up to 64 bits long, but where
FORTRAN \texttt{INTEGER}s are used to hold an address, only 32 bits
can be held.  However, the linker has flags -T and -D which can be
used to ensure that allocated memory addresses will fit into 32
bits. The user generally does not have to worry about these, as they
are inserted automatically if the relevant Starlink library link
script (\textit{e.g.}\ \texttt{hds\_link}) is used.

\subsection{\xlabel{vaxvms}VAX/VMS}

\subsubsection{General}

A VAX computer is based on a 32 bit architecture. Data can be addressed as
bytes (8 bits), words (16 bits), longwords (32 bits), quadwords (64 bits) or
octawords (128 bits). The terminology is a hangover from the PDP-11 series of
computers and the basic unit of storage on a VAX is the longword. References to
FORTRAN and C in this subsection refer to the VAX~FORTRAN and VAX~C compilers
produced by DEC\@.

\subsubsection{Data Types}

There is a simple correspondence between VAX~FORTRAN and VAX~C numeric variable
types. The standard types are given in the upper part of


\latex{Table~\ref{vms_datatypes}} and non-standard extensions in the lower
part.
These should generally be avoided for reasons of portability. However, they are
provided since
\xref{HDS}{sun92}{} \latex{(see SUN/92)}
has corresponding data types.

\begin{table}[htb]
\begin{center}
\begin{tabular}{|l|l|l|} \hline
\multicolumn{1}{|c|}{\textit{type}} & \multicolumn{1}{|c|}{VAX FORTRAN} &
\multicolumn{1}{c|}{VAX~C} \\ \hline
INTEGER & INTEGER & int \\
REAL & REAL & float \\
DOUBLE & DOUBLE PRECISION & double \\
LOGICAL & LOGICAL & int \\
& CHARACTER*1 & char \\
CHARACTER & CHARACTER*n & char[n] \\ \hline
BYTE & BYTE & char \\
WORD & INTEGER*2 & short int\\
UBYTE & & unsigned char\\
UWORD & & unsigned short int\\ \hline
POINTER & INTEGER & unsigned int\\ \hline
\end{tabular}
\end{center}
\caption{Corresponding data types for VAX/VMS}
\label{vms_datatypes}
\end{table}

Although VAX~C defines unsigned data types of \texttt{unsigned char} (range 0
to 255),  \texttt{unsigned short} (range 0 to 32767) and \texttt{unsigned int}
(range 0 to $2^{32}-1$), there are no corresponding unsigned data types in
FORTRAN\@.
There is also a C type called \texttt{long int}; however in VAX~C, this is the
same as an \texttt{int}.

The C language does not specify whether variables of type \texttt{char} should be
stored as signed or unsigned values. On VMS, they are stored as signed
values in the range -128 to 127.

Similarly there is no C data type that corresponds to the FORTRAN data type of
\texttt{COMPLEX}\@.
However, since VAX~FORTRAN passes all numeric variable by reference, a
\texttt{COMPLEX} variable could be passed to a VAX~C subprogram where it might
be handled as a structure consisting of two variables of type \texttt{float}.

A VAX~FORTRAN \texttt{LOGICAL} value can be passed to a VAX~C \texttt{int}, but
care must be taken over the interpretation of the value since VAX~FORTRAN only
considers the lower bit of the longword to be significant (0 is false, 1 is
true) whereas VAX~C treats any numerical value other than 0 as true.
When VAX~FORTRAN sets a
logical value to true, it sets all the bits. This corresponds to a numerical
value of minus one.

\subsubsection{\label{vms_arg}Arguments}

To understand how to pass arguments between VAX~FORTRAN and VAX~C programs, it
is necessary to understand the possible methods that VMS can use for passing
arguments and how each language makes use of them. VMS defines a procedure
calling standard that is used by all compilers written by DEC for the VMS
operating system. This is described in the ``Introduction to the VMS Run-Time
Library'' manual with additional information in the ``Introduction to VMS System
Services'' manual. If you have a third party compiler that does not conform to
this standard then you will not be able to mix the object code that it produces
with that from DEC compilers. There are three ways that an actual argument may
be passed to a subroutine. What is actually passed as an argument should always
be a longword. It is the interpretation of that longword that is where the
differences arise. Note the word \textit{should}\, in the last but one sentence.
VAX~C will occasionally generate an argument that is longer than one longword.
This is a violation of the VAX procedure calling standard. It causes no
problems for pure VAX~C programs, but is a potential source of problems for
mixed language programs.

VAX~FORTRAN passes all data types other than \texttt{CHARACTER} by reference,
\textit{i.e.}\ the address of the variable or array is put in the argument list.
\texttt{CHARACTER} variables are passed by descriptor.
The descriptor contains the type and class of descriptor, the length of the
string and the address where the characters are actually stored.

VAX~C uses call by value to pass all variables, constants (except string
constants), expressions, array elements, structures and unions that are actual
arguments of functions. It uses call by reference to pass whole arrays, string
constants and functions. VAX~C never uses call by descriptor as a default
method of passing arguments.

To pass a VAX~C variable of type \texttt{double} by value requires the use of two
longwords in the argument list and so is a violation of the VAX procedure
calling standard. The passing of a VAX~C structure that is bigger that one
longword is a similar violation. It is always better to pass C structures by
reference, although this should not be a problem in practice since in the case
of a pure VAX~C program, everything is handled consistently and in the case of
a mixture of FORTRAN and C, you would not normally pass variables by value
anyway.

In VAX~FORTRAN, the default argument passing mechanism can be overridden by use
of the \texttt{\%VAL}, \texttt{\%REF} and \texttt{\%DESCR} functions.
These functions are not portable and should be avoided whenever possible.
The only exception is that \texttt{\%VAL} is used in Starlink software for
passing pointer variables.
In VAX~C there is no similar way of ``cheating'' as there is in VAX~FORTRAN;
however, this is not necessary as the language allows more flexibility itself.
For example, if you wish to pass a variable named \texttt{x} by reference rather
than by value, you simply put \texttt{\&x} as the actual argument instead of
\texttt{x}.
To pass something by descriptor, you need to construct the appropriate
structure and pass the address of that. See the DEC manual ``Guide to VAX~C''
for further details.

Since C provides more flexibility in the mechanism of passing arguments than
does FORTRAN, it is C that ought to shoulder the burden of handling the
different mechanisms. All numeric variables and constants, array elements,
whole arrays and function names should be passed into and out of C functions by
reference. Numeric expressions will be passed from VAX~FORTRAN to VAX~C by
reference and so the corresponding dummy argument in the C function should be
declared to be of type ``pointer to type''. When C has a constant or an
expression as an actual argument in a function call, it can only pass it by
value. VAX~FORTRAN cannot cope with this and so in a VAX~C program, all
expressions should be assigned to variables before being passed to a FORTRAN
routine.

Here are some examples to illustrate these points.

\refstepcounter{examples}
\label{vms_f2c}
\begin{center}
Example\latex{~\ref{vms_f2c}}
-- Passing arguments from VAX~FORTRAN to VAX~C\@.
\end{center}
\nopagebreak[4]
FORTRAN program:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
      PROGRAM FORT1
      INTEGER A
      REAL B
      A = 1
      B = 2.0
      CALL C1( A, B )
      END
\end{terminalv}
\end{small}
\pagebreak[1]
C function:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
void c1( int *a, float *b )
{
  int x;
  float y;

  x = *a;    /* x is now equal to 1 */
  y = *b;    /* y is now equal to 2.0 */

  printf( "x = %d\n", x );
  printf( "y = %f\n", y );
}
\end{terminalv}
\end{small}

In this first example, a FORTRAN program passes an \texttt{INTEGER} and
\texttt{REAL} variable to a C function.
The values of these arguments are then assigned to two local
variables. They could just as well have been used directly in the function by
referring to the variables  \texttt{*a} and \texttt{*b} instead of
assigning their values to the local variables \texttt{x} and \texttt{y}.
Since the VAX~FORTRAN program passes the actual arguments by reference, the
dummy arguments used in the declaration of the VAX~C function should be a
pointer to the variable that is being passed.

Now an example of calling a VAX~FORTRAN subroutine from VAX~C\@.

\pagebreak[3]
\refstepcounter{examples}
\label{vms_c2f}
\begin{center}
Example\latex{~\ref{vms_c2f}}
-- Passing arguments from VAX~C to VAX~FORTRAN\@.
\end{center}
\nopagebreak[4]
C main program:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
main()
{
 int  i = 2;            /* Declare i and initialize it.  */
 void fort2( int *i );  /* Declare function fort2. */

 fort2( &i );           /* Call fort2.  */
}
\end{terminalv}
\end{small}
\pagebreak[1]
FORTRAN subroutine:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
      SUBROUTINE FORT2( I )
      INTEGER I

      PRINT *,I

      END
\end{terminalv}
\end{small}

The VAX~C main function declares and initializes a variable, \texttt{i}, and
declares a function \texttt{fort2}.
It calls \texttt{fort2}, passing the address of the variable \texttt{i} rather
than its value, as this is what the VAX~FORTRAN subroutine will be expecting.

As we have seen, the case of scalar numeric arguments is fairly
straightforward.
However, the passing of \texttt{CHARACTER} variables between VAX~FORTRAN
and VAX~C is more complicated. VAX~FORTRAN passes \texttt{CHARACTER} variables
by descriptor and VAX~C must handle these descriptors.
Furthermore, there is the point that FORTRAN deals with fixed-length,
blank-padded strings, whereas C deals with variable-length, null-terminated
strings. It is also worth noting that VAX/VMS machines handle
\texttt{CHARACTER} arguments in a manner which is different from the usual Unix
way.
The simplest possible example of a \texttt{CHARACTER} argument is given here
in all of its gory detail.
You will be pleased to discover that this example is purely for illustration.
The important point is that it is different from the Sun example and, anyway,
the
\htmlref{F77 macros}{f77_cfromf}
\latex{described in Section~\ref{f77_cfromf}} hide all of these
differences from the programmer, thereby making the code portable.

\refstepcounter{examples}
\label{vms_char}
\begin{center}
Example\latex{~\ref{vms_char}}
-- Passing character arguments from VAX~FORTRAN to
VAX~C\@.
\end{center}
\nopagebreak[4]
FORTRAN program:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
      PROGRAM FORT3
      CHARACTER STR*20

      CALL C3( STR )
      PRINT *,STR

      END
\end{terminalv}
\end{small}
\pagebreak[1]
C function:
\nopagebreak[4]
\begin{small}
\begin{terminalv}
#include <descrip.h>                    /* VMS Descriptors */
#include <stdio.h>                      /* Standard I/O functions */

void c3( struct dsc$descriptor_s  *fortchar )
{
  int  i;                              /* A loop counter */
  char  *string = "This is a string";  /* A string to be printed */

/* Copy the string to the function argument */
  strncpy( fortchar->dsc$a_pointer, string, fortchar->dsc$w_length );

/* Pad the character argument with trailing blanks */
  for( i = strlen( string ) ; i < fortchar->dsc$w_length ; i++ )
     fortchar->dsc$a_pointer[i] = ' ';
}
\end{terminalv}
\end{small}

The second variable declaration in the C subprogram declares a local variable
to be a string and initializes it. This string is then copied to the storage
area that the subprogram argument points to, taking care not to copy more
characters than the argument has room for. Finally any remaining space in the
argument is filled with blanks, the null character being overwritten. You
should always fill any trailing space with blanks in this way. What should
definitely not be done is to modify the descriptor to indicate the number of
non blank characters that it now holds. The VAX~FORTRAN compiler will not
expect this to happen and it is likely to cause run-time errors. See the DEC
manual ``Guide to VAX~C'' for more details of handling descriptors in VAX~C\@.

If an actual argument in a VAX~FORTRAN routine is an array of characters, rather
than just a single character variable, the descriptor that describes the data
is different. It is defined by the macro \texttt{dsc\$descriptor\_a} instead of
\texttt{dsc\$descriptor\_s}. This contains extra information about the number of
dimensions and their bounds; however, this can generally be ignored since the
first part of the \texttt{dsc\$descriptor\_a} descriptor is the same as the
\texttt{dsc\$descriptor\_s} descriptor. This extra information can be unpacked from the
descriptor, however, to do so would lead to non-portable code. It is generally
better to use the address of the array that is passed in the descriptor and to
pass any array dimensions as separate arguments. The C subroutine then has all
of the information that it requires and can handle the data as an array or by
using pointers, as the programmer sees fit. See example~\ref{f77_arbary} for
an illustration of this.

\subsubsection{Function Values}

The way that the return value of a function is handled is very much like a
simple assignment statement. In practice, the value is actually returned in one
or two of the registers of the CPU, depending on the size of the data type.
Consequently there is no problem in handling the value of any function that
returns a numerical value as long as the storage used by the value being
returned and the value expected correspond
(see Table~\ref{vms_datatypes}\latex{ on page~\pageref{vms_datatypes}}).
If a VAX~C function is treated as a \texttt{LOGICAL} function by VAX~FORTRAN,
there is no problem as long as the VAX~C function ensures that it returns a
value that will be interpreted correctly.
The best thing to do is to make sure that the C function can only return zero
(for false) or minus one (for true).

The case of a function that returns a character string is more complex. The way
that VAX~FORTRAN returns a \texttt{CHARACTER} variable as a function value is
to add a hidden extra entry to the beginning of the argument list.
This is a pointer to
a character descriptor. If a VAX~C function wishes to return a function value
that VAX~FORTRAN will interpret as a character string, then you must explicitly
add an extra argument to the VAX~C function and build the appropriate structure
in your C function. This may seem rather complicated, but what it boils down to
is that the following two segments of VAX~FORTRAN are equivalent (but only in
VAX~FORTRAN).

\pagebreak[3]
\refstepcounter{examples}
\label{vms_charfn}
\begin{center}
Example\latex{~\ref{vms_charfn}}
-- Equivalence of a VMS character function and a
VMS subroutine.
\end{center}
\nopagebreak[4]
\begin{small}
\begin{terminalv}
      CHARACTER*(10) RETURN
      CALL CHARFN( RETURN, A, B )
\end{terminalv}
\end{small}
   or
\begin{small}
\begin{terminalv}
      CHARACTER*(10) RETURN, CHARFN
      RETURN = CHARFN( A, B )
\end{terminalv}
\end{small}
If written as a function, CHARFN returns a value of type \texttt{CHARACTER}\@.
It is left as an exercise for the reader to demonstrate that the above
assertion is true using just FORTRAN\@.

\subsubsection{Global Data}

Although FORTRAN and C use different methods for representing global data, it is
actually very easy to mix them. If a VAX~FORTRAN common block contains a single
variable or array, then the corresponding VAX~C variable simply needs to be
declared as \texttt{extern} and the two variables will use the same storage.

\refstepcounter{examples}
\label{vms_common}
\begin{center}
Example\latex{~\ref{vms_common}}
-- A VAX~FORTRAN labelled common block containing a single variable
\end{center}
\nopagebreak[4]
FORTRAN common block:
\begin{small}
\begin{terminalv}
      CHARACTER*(10) STRING
      COMMON /BLOCK/ STRING
\end{terminalv}
\end{small}

C external variable:
\begin{small}
\begin{terminalv}
extern char block[10];
\end{terminalv}
\end{small}

Note that the name of the C variable corresponds to the name of the FORTRAN
common block, not the name of the FORTRAN variable. This example shows that you
can use the same storage area for both VAX~FORTRAN and VAX~C strings. However, you must
still beware of the different way in which FORTRAN and C handle the end of
a string.

If the FORTRAN common block contains more than one variable or array, then the
C variables must be contained in a structure.

If you wish to access the VAX~FORTRAN blank common block, then the
corresponding VAX~C structure should be called \$BLANK.

\refstepcounter{examples}
\label{vms_common2}
\begin{center}
Example\latex{~\ref{vms_common2}}
-- A VAX~FORTRAN labelled common block containing several variables.
\end{center}
\nopagebreak[4]
FORTRAN common block:
\begin{small}
\begin{terminalv}
      INTEGER I,J,K
      COMMON /NUMS/ I,J,K
\end{terminalv}
\end{small}

C external variable:
\begin{small}
\begin{terminalv}
extern struct { int i,j,k; } nums;
\end{terminalv}
\end{small}

\subsection{\xlabel{other_operating_systems}Other Operating Systems}

The F77 macros have been designed to cope with other systems as far as is
possible. It should be possible to modify the include file \texttt{f77.h} to
cope with most computers.
The places where this may prove difficult, or even impossible,
are likely to be due to arguments being passed in an unforeseen way.

The include file also declares the functions used for handling character
strings. The declarations are written as function prototypes and assume that
the C compiler will handle this feature of ANSI C\@. If a particular C compiler
does not support this feature, then the header file could easily be modified to
take this into account.

\newpage

\section{\xlabel{rationale_for_mixed_language_programming}\label{rationale}Rationale for Mixed Language Programming}
Starlink has historically been a ``FORTRAN only'' project. There are several
reasons for this. Primarily it is because scientists have been brought up with
FORTRAN and for most purposes it is perfectly adequate for our needs. However,
there are some tasks for which FORTRAN is not really suitable. In such
situations it may be better to write programs in a language other than FORTRAN,
rather than try to persuade FORTRAN to do something that it is not suited to.
Writing recursive procedures is the classic example, but there are many more.
Starlink has recognised the need for a language other than FORTRAN by providing
C compilers at all Starlink nodes.

There are in fact good reasons to avoid diversifying into trendy new languages
unless it is absolutely necessary. Any substantial piece of software will
require someone to support it long after the original author has moved on to
other things and it is not reasonable to expect that person to have expertise
in a large number of programming languages. However, for some purposes, FORTRAN
77 is simply not adequate. In fact some major parts of Starlink software have
been written in other languages because of this.
\xref{HDS\@.}{sun92}{} \latex{(See SUN/92.)}
is written in C (it was originally written in Bliss, in the days when even C
was impractical because of restrictions in the early compilers).
In the future, FORTRAN~90 will overcome many of the limitations that
FORTRAN~77 has but, until that becomes readily available (and even after),
some things are simply better written in C\@.

It is often the case that most of a program can be written in FORTRAN, leaving
only a few tricky parts that cannot be written using standard (or even non
standard) FORTRAN\@. An example of a task that cannot be performed using
standard FORTRAN is getting some memory for use in your program.
Admittedly, there are often system service subroutines available but these are
virtually guaranteed to be non portable to other computers.
Often a better approach is to write the tricky parts in C\@. This is exactly the
approach that has been adopted for HDS.
The problem then is how to pass data between FORTRAN routines and C functions.
This document will describe  how to do this.
Clearly the details of passing information between program segments
written in different languages will be machine dependent; however, there are
also many important similarities. Despite any problems that may arise, it is
easier to port programs written in a mixture of FORTRAN and C to other computer
systems than to port programs written purely in FORTRAN that make use of
machine-specific routines for system services.

How to mix FORTRAN and C in a way that is portable to all current Starlink
hardware is described in


\latex{Sections \ref{f77_cfromf} and \ref{f77_ffromc}.}

It is quite likely that you will often want to use C to make use of something
that the C run time library provides, such as allocating memory. This
requirement is sufficiently common that a library of FORTRAN callable routines
has already been provided to do exactly that.
It is called PSX and is described in
\xref{SUN/121}{sun121}{}.
In many programs, use of the PSX library will remove the need to write any C
code at all.

You may think that if you want to use C for part of a program then you should
use C for all of the program. This may indeed be the best option; however, if
you also want to call subroutines that are written in FORTRAN ({\em{e.g.}}\
just about any Starlink library), then you are going to be involved in mixed
language programming anyway.
The correct choice will depend on the circumstances.

Writing mixed language programs is not something that should be embarked upon
lightly. There might be a better way of achieving the same result using just
FORTRAN\@.
The source code may not look as pretty, but if it runs effectively and
efficiently then that is all that is required. If you can achieve what you want
using standard FORTRAN then you should do so. If you cannot, then this document
will tell you how to mix FORTRAN and C \textit{in a portable way}.
The programming language manuals of the computer manufacturers tell you how to
mix languages on their own hardware, but achieving portability needs a little
more thought.

Finally, if you are new to C, you should be aware that the way that things are
normally done in C can be rather different from the way that they are normally
done in FORTRAN\@. When I was new to C, I proudly showed someone one of my first
C programs. ``That's not a C program,'' they said,  ``That's a FORTRAN program
that's written in C\@.'' They were, of course, right. A useful book an C
programming is Banahan \cite{Banahan}. This describes how to write programs in
ANSI standard C and is written in an easy-going style. The author is not averse
to criticizing C when he thinks that a feature of the language is not
appropriate.

\newpage

\section{\xlabel{alphabetical_list_of_f77_macros}\label{f77_alphabetical}Alphabetical List of F77 Macros}
The list is alphabetical except that the generic \textit{type} has highest
priority.
{\em{type}} may be one of: CHARACTER, DOUBLE, INTEGER, LOGICAL,
REAL, BYTE, WORD, UBYTE, UWORD or POINTER.
\routinelist{
\listgenroutine{\textit{type}}
   {Declare a C function argument of the specified type}
   {type}
\listgenroutine{\textit{type}\_ARG}
   {Pass an argument of the specified type to a FORTRAN routine}
   {type_ARG}
\listgenroutine{\textit{type}\_ARRAY}
   {Declare a C function argument as an array of the specified type}
   {type_ARRAY}
\listgenroutine{\textit{type}\_ARRAY\_ARG}
   {Pass an array argument of the specified type to a FORTRAN routine}
   {type_ARRAY_ARG}
\listgenroutine{\textit{type}\_FUNCTION}
   {Declare a C function argument as a FORTRAN-callable FUNCTION of the
    specified type}
   {type_FUNCTION}
\listgenroutine{\textit{type}\_FUNCTION\_ARG}
   {Pass a FORTRAN-callable FUNCTION of the specified type as an argument to a
    FORTRAN routine}
   {type_FUNCTION_ARG}
\listroutine{CHARACTER\_RETURN\_ARG}
   {Pass an argument that will be the return value of a CHARACTER FUNCTION}
\listroutine{CHARACTER\_RETURN\_VALUE}
   {Declare an argument that will be the return value of a CHARACTER FUNCTION}
\listgenroutine{DECLARE\_\textit{type}}
   {Declare a variable of the specified type}
   {DECLARE_type}
\listgenroutine{DECLARE\_\textit{type}\_ARRAY}
   {Declare an array of the specified type}
   {DECLARE_type_ARRAY}
\listgenroutine{DECLARE\_\textit{type}\_ARRAY\_DYN}
   {Declare a dynamic array of the specified type}
   {DECLARE_type_ARRAY_DYN}
\listroutine{DECLARE\_CHARACTER\_DYN}
   {Declare a dynamic FORTRAN CHARACTER variable}
\listgenroutine{F77\_\textit{type}\_FUNCTION}
   {Declare a FORTRAN-callable function that returns a value of the specified
    type}
   {F77_type_FUNCTION}
\listroutine{F77\_BLANK\_COMMON}
   {Refer to blank common}
\listroutine{F77\_BYTE\_TYPE}
   {Define the C type corresponding to the FORTRAN type BYTE}
\listroutine{F77\_CALL}
   {Call a FORTRAN routine from C}
\listroutine{F77\_CHARACTER\_ARG\_TYPE}
   {Define the type passed as a CHARACTER argument}
\listroutine{F77\_CHARACTER\_ARRAY\_ARG\_TYPE}
   {Define the type passed as a CHARACTER array argument}
\listroutine{F77\_CHARACTER\_TYPE}
   {Define the C type corresponding to the FORTRAN type CHARACTER}
\listgenroutine{F77\_CREATE\_\textit{type}\_ARRAY}
   {Create a dynamic FORTRAN array of \textit{type}}
   {F77_CREATE_type_ARRAY}
\listroutine{F77\_CREATE\_CHARACTER}
   {Create a dynamic FORTRAN CHARACTER variable}
\listroutine{F77\_CREATE\_CHARACTER\_ARRAY}
   {Create a dynamic FORTRAN CHARACTER 1-D array}
\listroutine{F77\_CREATE\_CHARACTER\_ARRAY\_M}
   {Create a dynamic FORTRAN CHARACTER n-D array}
\listroutine{F77\_CREATE\_LOGICAL\_ARRAY\_M}
   {Create a dynamic FORTRAN LOGICAL n-D array}
\listroutine{F77\_DOUBLE\_TYPE}
   {Define the C type corresponding to the FORTRAN type DOUBLE PRECISION}
\listgenroutine{F77\_EXPORT\_\textit{type}}
   {Export a C variable of the specified type to FORTRAN}
   {F77_EXPORT_type}
\listgenroutine{F77\_EXPORT\_\textit{type}\_ARRAY}
   {Export a C array of the specified type to FORTRAN}
   {F77_EXPORT_type_ARRAY}
\listroutine{F77\_EXPORT\_CHARACTER\_ARRAY\_P}
   {Export an array of pointers to char}
\listroutine{F77\_EXTERNAL\_NAME}
   {The external name of a function}
\listroutine{F77\_FALSE}
   {The FORTRAN logical value FALSE}
\listgenroutine{F77\_FREE\_\textit{type}}
   {Free a dynamic FORTRAN array or CHARACTER variable}
   {F77_FREE_type}
\listgenroutine{F77\_IMPORT\_\textit{type}}
   {Import a FORTRAN variable of the specified type to C}
   {F77_IMPORT_type}
\listgenroutine{F77\_IMPORT\_\textit{type}\_ARRAY}
   {Import a FORTRAN array of the specified type to C}
   {F77_IMPORT_type_ARRAY}
\listroutine{F77\_IMPORT\_CHARACTER\_ARRAY\_P}
   {Import an array of pointers to char}
\listroutine{F77\_INTEGER\_TYPE}
   {Define the C type corresponding to the FORTRAN type INTEGER}
\listroutine{F77\_ISFALSE}
   {Is this the FORTRAN logical value false?}
\listroutine{F77\_ISTRUE}
   {Is this the FORTRAN logical value true?}
\listroutine{F77\_LOCK}
   {Prevents code from being run simultaneously in two separate threads}
\listroutine{F77\_LOGICAL\_TYPE}
   {Define the C type corresponding to the FORTRAN type LOGICAL}
\listroutine{F77\_NAMED\_COMMON}
   {Refer to a named common block}
\listroutine{F77\_REAL\_TYPE}
   {Define the C type corresponding to the FORTRAN type REAL}
\listroutine{F77\_SUBROUTINE}
   {Declare a FORTRAN-callable SUBROUTINE}
\listroutine{F77\_TRUE}
   {The FORTRAN logical value TRUE}
\listgenroutine{GENPTR\_\textit{type}}
   {Generate a pointer to an argument of the specified type}
   {GENPTR_type}
\listgenroutine{GENPTR\_\textit{type}\_ARRAY}
   {Generate a pointer to an array argument of the specified type}
   {GENPTR_type_ARRAY}
\listgenroutine{GENPTR\_\textit{type}\_FUNCTION}
   {Generate a pointer to an argument which is a FORTRAN-callable FUNCTION
    of the specified type}
   {GENPTR_type_FUNCTION}
\listroutine{GENPTR\_SUBROUTINE}
   {Generate a pointer to an argument which is a FORTRAN-callable SUBROUTINE}
\listroutine{SUBROUTINE}
   {Declare a C function argument as a FORTRAN-callable SUBROUTINE name}
\listroutine{SUBROUTINE\_ARG}
   {Pass a FORTRAN-callable SUBROUTINE name as an argument to a FORTRAN routine}
\listroutine{TRAIL}
   {Declare hidden trailing arguments}
\listroutine{TRAIL\_ARG}
   {Pass the length of a CHARACTER argument to a FORTRAN routine}
}

\section{\xlabel{classified_list_of_f77_macros}Classified List of F77 Macros}
This appendix contains a list of the F77 macros, arranged by functionality.

\subsection{\xlabel{declaration_of_a_c_function}Declaration of a C Function}
\textit{type} may be one of: CHARACTER, DOUBLE, INTEGER, LOGICAL,
REAL, BYTE, WORD, UBYTE, UWORD or POINTER.
\routinelist{
\listgenroutine{F77\_\textit{type}\_FUNCTION}
   {Declare a FORTRAN-callable function that returns a value of the specified
    type}
   {F77_type_FUNCTION}
\listroutine{F77\_SUBROUTINE}
   {Declare a FORTRAN-callable SUBROUTINE}
}

\subsection{\xlabel{arguments_of_a_c_function}Arguments of a C Function}
\textit{type} may be one of: CHARACTER, DOUBLE, INTEGER, LOGICAL,
REAL, BYTE, WORD, UBYTE, UWORD or POINTER.
\routinelist{
\listgenroutine{\textit{type}}
   {Declare a C function argument of the specified type}
   {type}
\listgenroutine{\textit{type}\_ARRAY}
   {Declare a C function argument as an array of the specified type}
   {type_ARRAY}
\listgenroutine{\textit{type}\_FUNCTION}
   {Declare a C function argument as a FORTRAN-callable FUNCTION of the
    specified type}
   {type_FUNCTION}
\listroutine{CHARACTER\_RETURN\_VALUE}
   {Declare an argument that will be the return value of a CHARACTER FUNCTION}
\listroutine{SUBROUTINE}
   {Declare a C function argument as a FORTRAN-callable SUBROUTINE name}
\listroutine{TRAIL}
   {Declare hidden trailing arguments}
}

\subsection{\xlabel{generate_pointers_to_arguments}Generate Pointers to Arguments}
\textit{type} may be one of: CHARACTER, DOUBLE, INTEGER, LOGICAL,
REAL, BYTE, WORD, UBYTE, UWORD or POINTER.
\routinelist{
\listgenroutine{GENPTR\_\textit{type}}
   {Generate a pointer to an argument of the specified type}
   {GENPTR_type}
\listgenroutine{GENPTR\_\textit{type}\_ARRAY}
   {Generate a pointer to an array argument of the specified type}
   {GENPTR_type_ARRAY}
\listgenroutine{GENPTR\_\textit{type}\_FUNCTION}
   {Generate a pointer to an argument which is a FORTRAN-callable FUNCTION
    of the specified type}
   {GENPTR_type_FUNCTION}
\listroutine{GENPTR\_SUBROUTINE}
   {Generate a pointer to an argument which is a FORTRAN-callable SUBROUTINE}
}

\subsection{\xlabel{data_type_macros}Data Type Macros}
\routinelist{
\listroutine{F77\_BYTE\_TYPE}
   {Define the C type corresponding to the FORTRAN type BYTE}
\listroutine{F77\_CHARACTER\_TYPE}
   {Define the C type corresponding to the FORTRAN type CHARACTER}
\listroutine{F77\_DOUBLE\_TYPE}
   {Define the C type corresponding to the FORTRAN type DOUBLE PRECISION}
\listroutine{F77\_INTEGER\_TYPE}
   {Define the C type corresponding to the FORTRAN type INTEGER}
\listroutine{F77\_LOGICAL\_TYPE}
   {Define the C type corresponding to the FORTRAN type LOGICAL}
\listroutine{F77\_POINTER\_TYPE}
   {Define the C type corresponding to the type POINTER}
\listroutine{F77\_REAL\_TYPE}
   {Define the C type corresponding to the FORTRAN type REAL}
\listroutine{F77\_UBYTE\_TYPE}
   {Define the C type corresponding to the type UBYTE}
\listroutine{F77\_UWORD\_TYPE}
   {Define the C type corresponding to the type UWORD}
\listroutine{F77\_WORD\_TYPE}
   {Define the C type corresponding to the type WORD}
}

\subsection{\xlabel{logical_value_macros}Logical Value Macros}
\routinelist{
\listroutine{F77\_FALSE}
   {The FORTRAN logical value FALSE}
\listroutine{F77\_ISFALSE}
   {Is this the FORTRAN logical value false?}
\listroutine{F77\_ISTRUE}
   {Is this the FORTRAN logical value true?}
\listroutine{F77\_TRUE}
   {The FORTRAN logical value TRUE}
}

\subsection{\xlabel{external_name_macro}External Name Macro}
\routinelist{
\listroutine{F77\_EXTERNAL\_NAME}
   {The external name of a function}
}

\subsection{\xlabel{common_block_macros}Common Block Macros}
\routinelist{
\listroutine{F77\_BLANK\_COMMON}
   {Refer to blank common}
\listroutine{F77\_NAMED\_COMMON}
   {Refer to a named common block}
}

\subsection{\xlabel{declaring_variables_for_passing_to_a_fortran_routine}Declaring Variables for Passing to a FORTRAN Routine}
\textit{type} may be one of: CHARACTER, DOUBLE, INTEGER, LOGICAL,
REAL, BYTE, WORD, UBYTE, UWORD or POINTER.
\routinelist{
\listgenroutine{DECLARE\_\textit{type}}
   {C declaration of a FORTRAN variable of the specified type}
   {DECLARE_type}
\listgenroutine{DECLARE\_\textit{type}\_ARRAY}
   {C declaration of a FORTRAN array of the specified type}
   {DECLARE_type_ARRAY}
\listgenroutine{DECLARE\_\textit{type}\_ARRAY\_DYN}
   {C declaration of a dynamic FORTRAN array of the specified type}
   {DECLARE_type_ARRAY_DYN}
\listgenroutine{F77\_CREATE\_\textit{type}\_ARRAY}
   {Create a dynamic FORTRAN array of \textit{type}}
   {F77_CREATE_type_ARRAY}
\listroutine{DECLARE\_CHARACTER\_DYN}
   {C declaration of a dynamic FORTRAN CHARACTER variable}
\listroutine{F77\_CREATE\_CHARACTER}
   {Create a dynamic FORTRAN CHARACTER variable}
\listroutine{F77\_CREATE\_CHARACTER\_ARRAY}
   {Create a dynamic FORTRAN CHARACTER 1-D array}
\listroutine{F77\_CREATE\_CHARACTER\_ARRAY\_M}
   {Create a dynamic FORTRAN CHARACTER n-D array}
\listroutine{F77\_CREATE\_LOGICAL\_ARRAY\_M}
   {Create a dynamic FORTRAN LOGICAL n-D array}
\listgenroutine{F77\_FREE\_\textit{type}}
   {Free a dynamic FORTRAN array or CHARACTER variable}
   {F77_FREE_type}
}

\subsection{\xlabel{importing_and_exporting_arguments}Importing and Exporting Arguments}
\textit{type} may be one of: CHARACTER, DOUBLE, INTEGER, LOGICAL,
REAL, BYTE, WORD, UBYTE, UWORD or POINTER.
\routinelist{
\listgenroutine{{F77\_EXPORT\_\textit{type}}}
   {Export a C variable to a FORTRAN variable of \texttt{type}}
   {F77_EXPORT_type}
\listgenroutine{{F77\_EXPORT\_\textit{type}\_ARRAY}}
   {Export a C array to a FORTRAN array of \texttt{type}}
   {F77_EXPORT_type_ARRAY}
\listroutine{F77\_EXPORT\_CHARACTER\_ARRAY\_P}
   {Export an array of pointers to char to a FORTRAN CHARACTER array}
\listgenroutine{{F77\_IMPORT\_\textit{type}}}
   {Import a FORTRAN variable of \texttt{type} to a C variable}
   {F77_IMPORT_type}
\listgenroutine{{F77\_IMPORT\_\textit{type}\_ARRAY}}
   {Import a FORTRAN array of \texttt{type} to a C array}
   {F77_IMPORT_type_ARRAY}
\listroutine{F77\_IMPORT\_CHARACTER\_ARRAY\_P}
   {Import a FORTRAN CHARACTER array to a C array of pointer to char}
\listgenroutine{{F77\_ASSOC\_\textit{type}\_ARRAY}}
   {Associate a FORTRAN array of \texttt{type} with a C array}
   {F77_ASSOC_type_ARRAY}
}
\subsection{\xlabel{passing_arguments_to_a_fortran_routine}Passing Arguments to a FORTRAN Routine}
\textit{type} may be one of: CHARACTER, DOUBLE, INTEGER, LOGICAL,
REAL, BYTE, WORD, UBYTE, UWORD or POINTER.
\routinelist{
\listgenroutine{\textit{type}\_ARG}
   {Pass an argument of the specified type to a FORTRAN routine}
   {type_ARG}
\listgenroutine{\textit{type}\_ARRAY\_ARG}
   {Pass an array argument of the specified type to a FORTRAN routine}
   {type_ARRAY_ARG}
\listgenroutine{\textit{type}\_FUNCTION\_ARG}
   {Pass a FORTRAN-callable FUNCTION of the specified type as an argument to a
    FORTRAN routine}
   {type_FUNCTION_ARG}
\listroutine{CHARACTER\_RETURN\_ARG}
   {Pass an argument that will be the return value of a CHARACTER FUNCTION}
\listroutine{F77\_CALL}
   {Call a FORTRAN routine from C}
\listroutine{SUBROUTINE\_ARG}
   {Pass a FORTRAN-callable SUBROUTINE name as an argument to a FORTRAN routine}
\listroutine{TRAIL\_ARG}
   {Pass the length of a CHARACTER argument to a FORTRAN routine}
}

\subsection{\xlabel{thread_safety}Thread Safety}
\routinelist{
\listroutine{F77\_LOCK}
   {Prevents code from being run simultaneously in two separate threads}
}

\section{\xlabel{full_description_of_f77_macros}\label{f77_description}Full Description of F77 Macros}
This appendix contains a full description of each macro. It is in two sections:
\htmlref{Generic Descriptions}{f77_generic}
containing those macros which may be described generically for the various
types and
\htmlref{Specific Descriptions}{f77_specific}
for those which need a specific description.

The effect of each macro is described and the expansion of the macro on each
of the supported systems is given.
The following classes are defined for the examples:
\begin{center}
\begin{tabular}{|l|l|}
\hline
All systems & All supported systems\\
All Unix & All supported Unix systems\\
\hline
\end{tabular}
\end{center}
\textit{Not all the facilities listed here are available for VAX/VMS even
if a VMS example is given.
In some cases the macro expansions described here will not be correct for
VAX/VMS.
Consult the VMS Starlink documentation set for information on the VMS release.}

N.B.
It is important not to leave spaces around arguments in macros calls
as these spaces are then included in the macro expansion on some systems,
\textit{i.e.}\ write \texttt{F77\_\-SUBROUTINE(fred)}, not
\texttt{F77\_\-SUBROUTINE( fred )}.
This seems to be a bug in the offending compilers, but the problem is there
none the less.

Many macros currently expand to an empty string on all currently supported
systems. Nevertheless, the macros should still be used to guard against them
being necessary on future systems.

\newpage
\subsection{\xlabel{generic_descriptions}\label{f77_generic}Generic Descriptions}
Unless otherwise stated, \textit{type} is one of CHARACTER, INTEGER, REAL,
DOUBLE, LOGICAL, BYTE, WORD, UBYTE, UWORD, LOCATOR or POINTER\@.

\sstroutinenolabel{
   DECLARE\_\textit{type}
}{
   \relabel{DECLARE_type}Declare a FORTRAN variable
}{
   \sstdescription{
      Declare a variable that will be passed to a FORTRAN routine.
      This variable will be the actual argument of a call to a FORTRAN
      routine. (\textit{type} not CHARACTER or LOCATOR\@.)
   }
   \sstinvocation{
      DECLARE\_\textit{type}(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The variable being declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DECLARE\_\textit{type}(arg)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
               {F77\_\textit{type}\_TYPE arg}
          }

         where \texttt{F77\_\textit{type}\_TYPE} expands to the appropriate C
         type.
      }
   }
   \sstdiytopic{Associated macro:}{
        \htmlref{\texttt{DECLARE\_CHARACTER}}{DECLARE_CHARACTER}
   }
}

\sstroutinenolabel{
   DECLARE\_\textit{type}\_ARRAY
}{
   \relabel{DECLARE_type_ARRAY}Declare a FORTRAN array
}{
   \sstdescription{
      Declare an array of the appropriate type that will be passed to a
      FORTRAN routine.
      This array will be the actual argument of a call to a FORTRAN
      routine. (\textit{type} not CHARACTER or LOCATOR\@.)
   }
   \sstinvocation{
      DECLARE\_\textit{type}\_ARRAY(arg,dims)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The array being declared.
      }
      \sstsubsection{
         dims
      }{
         The dimensions of the array.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DECLARE\_\textit{type}\_ARRAY(arg,10)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
              {F77\_\textit{type}\_TYPE arg[10]}
          }
      }
      \sstexamplesubsection{
         DECLARE\_\textit{type}\_ARRAY(arg,2][3][4)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
              {F77\_\textit{type}\_TYPE arg[2][3][4]}
          }
      }

      where \texttt{F77\_\textit{type}\_TYPE} expands to the appropriate
            C type.
   }
   \sstdiytopic{Associated macro:}{
        \htmlref{\texttt{DECLARE\_CHARACTER\_ARRAY}}{DECLARE_CHARACTER_ARRAY}
   }
}

\sstroutinenolabel{
   DECLARE\_\textit{type}\_ARRAY\_DYN
}{
   \relabel{DECLARE_type_ARRAY_DYN}Declare a dynamic \textit{type} array
}{
   \sstdescription{
      Declare a dynamic \textit{type} array that will be passed to a FORTRAN
      routine using the \textit{type}\_ARRAY\_ARG macro. Use this macro, in
      combination with the F77\_\-CREATE\_\-\textit{type}\_\-ARRAY and
      F77\_\-FREE\_\-\textit{type} macros, where the size of the array is not
      known until run time.
      (\textit{type} not LOCATOR\@.)
   }
   \sstinvocation{
      DECLARE\_\textit{type}\_ARRAY\_DYN(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The variable being declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DECLARE\_\textit{type}\_ARRAY\_DYN(farg)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
                    {F77\_\textit{type}\_TYPE *farg}
          }
      \sstexamplesubsection{
         DECLARE\_CHARACTER\_ARRAY\_DYN(fstring)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}
                    {char *fstring; int fstring\_length}\\
            \sstexamplestableentry{VAX/VMS:}
                    {char *fstring; int fstring\_length}\\
            \sstexamplestableentry{}
                    {struct dsc\$descriptor\_a fstring\_arg}\\
          }
      }
   }
   \sstnotes{
         On VMS, for CHARACTER, the expansion of the macro is quite complex.
         A pointer to a descriptor structure is declared in addition to a
         pointer to char (used to point to the actual string of characters)
         and an int variable to  store the length of the array. The address
         of the descriptor is what is actually passed to the called FORTRAN
         routine.
      }
   }
}

\sstroutinenolabel{
   F77\_ASSOC\_\textit{type}\_ARRAY
}{
   \relabel{F77_ASSOC_type_ARRAY}Associate a FORTRAN array with a C array.
}{
   \sstdescription{
      For types which do not require separate memory allocated to hold the
      FORTRAN array, this macro ensures that the pointer to the FORTRAN array
      points to the memory allocated for the C array.
      (\textit{type} not LOCATOR\@.)
   }
   \sstinvocation{
      F77\_ASSOC\_\textit{type}\_ARRAY(farg,carg)
   }
   \sstarguments{
      \sstsubsection{
         farg
      }{
         A pointer to the FORTRAN array
      }
      \sstsubsection{
         carg
      }{
         A pointer to the C array
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_ASSOC\_\textit{type}\_ARRAY(farg,carg)
      }{
         \textit{type} \emph{not} CHARACTER, LOGICAL or POINTER will expand as
         follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
               {farg=carg}
          }

         \textit{type} CHARACTER, LOGICAL or POINTER will expand as
         follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
               {}
          }
      }
   }
}

\sstroutinenolabel{
   F77\_CREATE\_\textit{type}\_ARRAY
}{
   \relabel{F77_CREATE_type_ARRAY}Create an array of \textit{type}.
}{
   \sstdescription{
      These macros ensure that memory is available for arrays to be used as
      actual arguments for FORTRAN subroutines, assuming that space is
      already allocated for a corresponding C array. That is, they
      will only allocate additional memory for those types which
      require a non-null export or import.
      (\textit{type} not CHARACTER or LOCATOR\@.)
   }
   \sstinvocation{
      F77\_CREATE\_\textit{type}\_ARRAY(farg,nels)
   }
   \sstarguments{
      \sstsubsection{
         carg
      }{
         A pointer to the C array
      }
      \sstsubsection{
         farg
      }{
         A pointer to the FORTRAN array
      }
      \sstsubsection{
         nels
      }{
         The number of elements required
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_CREATE\_\textit{type}\_ARRAY(farg,n)
      }{
         \textit{type} LOGICAL will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
               { \{\texttt{int f77dims[1];f77dims[0]=n;}}\\
            \sstexamplestableentry{}
               { farg=cnfCrela(1,f77dims);\} }
          }

         \textit{type} POINTER will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
             { farg=}\\
            \sstexamplestableentry{}
             {(F77\_POINTER\_TYPE *)malloc(n*sizeof(F77\_POINTER\_TYPE)) }
          }

         All other \textit{type}s (except CHARACTER) will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
               {}
          }
      }
   }
   \sstdiytopic{Associated macros:}{
     \htmlref{\texttt{F77\_\-CREATE\_\-CHARACTER\_\-ARRAY}}
             {F77_CREATE_CHARACTER_ARRAY},
     \htmlref{\texttt{F77\_\-ASSOC\_\-\textit{type}\_\-ARRAY}}
             {F77_ASSOC_type_ARRAY},
     \htmlref{\texttt{F77\_\-EXPORT\_\-\textit{type}\_\-ARRAY}}
             {F77_EXPORT_type_ARRAY},\\
     \htmlref{\texttt{F77\_\-IMPORT\_\-\textit{type}\_\-ARRAY}}
             {F77_IMPORT_type_ARRAY}
   }
}

\sstroutinenolabel{
   F77\_EXPORT\_\textit{type}
}{
   \relabel{F77_EXPORT_type}Export a C variable to a FORTRAN variable.
}{
   \sstdescription{
      Copies a C variable to a FORTRAN variable making any required changes
      to the data.
      (\textit{type} not CHARACTER\@.)
   }
   \sstinvocation{
      F77\_EXPORT\_\textit{type}(carg,farg)
   }
   \sstarguments{
      \sstsubsection{
         carg
      }{
         The C value
      }
      \sstsubsection{
         farg
      }{
         The FORTRAN variable
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_EXPORT\_\textit{type}(carg,farg)
      }{
         \textit{type} LOGICAL will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
               {farg=carg?F77\_TRUE:F77\_FALSE}
          }

         \textit{type} POINTER will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
            {farg=cnfFptr(carg)}
          }

         \textit{type} LOCATOR will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
            {cnfExpch(carg,farg,DAT\_\_SZLOC)}
          }

         All other \textit{type}s will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
               {farg=carg}
          }
      }
   }
   \sstdiytopic{Associated macro:}{
      \htmlref{\texttt{F77\_EXPORT\_CHARACTER}}{F77_EXPORT_CHARACTER}
   }
}

\sstroutinenolabel{
   F77\_EXPORT\_\textit{type}\_ARRAY
}{
   \relabel{F77_EXPORT_type_ARRAY}Export an array of \textit{type} from C
   to FORTRAN
}{
   \sstdescription{
      Depending upon the type and system, the C array will be copied to the
      FORTRAN array, making any required changes to the data, or the pointer
      to the FORTRAN array will be set to point to the C array.
      (\textit{type} not CHARACTER\@.)
   }
   \sstinvocation{
      F77\_EXPORT\_\textit{type}\_ARRAY(carg,farg,nels)
   }
   \sstarguments{
      \sstsubsection{
         carg
      }{
         A pointer to the C array
      }
      \sstsubsection{
         farg
      }{
         A pointer to the FORTRAN array
      }
      \sstsubsection{
         nels
      }{
         The number of elements to be exported
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_EXPORT\_\textit{type}\_ARRAY(farg,carg,nels)
      }{
         \textit{type} LOGICAL will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
               { \{\texttt{int f77dims[1];f77dims[0]=nels;}}\\
            \sstexamplestableentry{}
               { cnfExpla(carg,farg,1,f77dims);\} }\\
          }

         \textit{type} POINTER will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
              {\{\texttt{ int f77i; for(f77i=0;nels>f77i;f77i++) \{}}\\
            \sstexamplestableentry{}
              {farg[f77i]=cnfFptr(carg[f77i]);
               \}\} }
          }

         All other \textit{type}s will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
               {farg=carg}
          }
      }
   }
   \sstdiytopic{Associated macro:}{
      \htmlref{\texttt{F77\_EXPORT\_CHARACTER\_ARRAY}}
              {F77_EXPORT_CHARACTER_ARRAY}
   }
}

\sstroutinenolabel{
   F77\_FREE\_\textit{type}
}{
   \relabel{F77_FREE_type}Free a dynamic variable of \textit{type}
}{
   \sstdescription{
      Frees the space obtained by a previous
      F77\_\-CREATE\_\-\textit{type}\_\-ARRAY or F77\_\-CREATE\_\-CHARACTER
      macro). Makes use of cnf functions where appropriate.
      If the associated CREATE macro was null, the FREE macro will be null.
   }
   \sstinvocation{
      F77\_FREE\_\textit{type}(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The variable as passed to the FORTRAN subroutine.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_FREE\_LOGICAL(flog)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
                    {cnfFree((char *)flog)}
          }
      }
   }
}

\sstroutinenolabel{
   F77\_IMPORT\_\textit{type}
}{
   \relabel{F77_IMPORT_type}Import a FORTRAN variable to a C variable.
}{
   \sstdescription{
      Copies a FORTRAN variable to a C variable making any required changes
      to the data.
      (\textit{type} not CHARACTER\@.)
   }
   \sstinvocation{
      F77\_IMPORT\_\textit{type}(farg,carg)
   }
   \sstarguments{
      \sstsubsection{
         farg
      }{
         The C value
      }
      \sstsubsection{
         carg
      }{
         The FORTRAN variable
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_IMPORT\_\textit{type}(farg,carg)
      }{
         \textit{type} LOGICAL will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
               {carg=F77\_ISTRUE(farg)}
          }

         \textit{type} POINTER will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
            {carg=cnfCptr(farg)}
          }

         \textit{type} LOCATOR will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
            {cnfImpch(farg,DAT\_\_SZLOC,carg)}
          }

         All other \textit{type}s will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
               {carg=farg}
          }
      }
   }
   \sstdiytopic{Associated macro:}{
      \htmlref{\texttt{F77\_IMPORT\_CHARACTER}}{F77_EXPORT_CHARACTER}
   }
}

\sstroutinenolabel{
   F77\_IMPORT\_\textit{type}\_ARRAY
}{
   \relabel{F77_IMPORT_type_ARRAY}Import an array of \textit{type} from FORTRAN
   to C
}{
   \sstdescription{
      Depending upon the type and system, the FORTRAN array will be copied to
      the C array, making any required changes to the data, or the pointer
      to the C array will be set to point to the FORTRAN array.
      (\textit{type} not CHARACTER\@.)
   }
   \sstinvocation{
      F77\_IMPORT\_\textit{type}\_ARRAY(farg,carg,nels)
   }
   \sstarguments{
      \sstsubsection{
         farg
      }{
         A pointer to the FORTRAN array
      }
      \sstsubsection{
         carg
      }{
         A pointer to the C array
      }
      \sstsubsection{
         nels
      }{
         The number of elements to be exported
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_IMPORT\_\textit{type}\_ARRAY(carg,farg,nels)
      }{
         \textit{type} LOGICAL will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
               { \{\texttt{ int f77dims[1];f77dims[0]=nels;}}\\
            \sstexamplestableentry{}
               { cnfImpla(farg,carg,1,f77dims);\} }
          }

         \textit{type} POINTER will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
              {\{\texttt{ int f77i;for(f77i=0;nels>f77i;f77i++)\{}}\\
            \sstexamplestableentry{}
              {carg[f77i]=cnfCptr(farg[f77i]);
              \}\} }
          }

         All other \textit{type}s will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
               {carg=farg}
          }
      }
   }
   \sstdiytopic{Associated macro:}{
      \htmlref{\texttt{F77\_IMPORT\_CHARACTER\_ARRAY}}
              {F77_IMPORT_CHARACTER_ARRAY}
   }
}

\sstroutinenolabel{
   F77\_\textit{type}\_FUNCTION
}{
   \relabel{F77_type_FUNCTION}Declare a FORTRAN function
}{
   \sstdescription{
      Declare a C function that will be called from FORTRAN as though it
      were a FORTRAN function of the appropriate type.
      (\textit{type} not LOCATOR\@.)
   }
   \sstinvocation{
      F77\_\textit{type}\_FUNCTION(name)
   }
   \sstarguments{
      \sstsubsection{
         name
      }{
         The name of the function to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_\textit{type}\_FUNCTION(name)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}
              {F77\_\textit{type}\_TYPE name\_}\\
            \sstexamplestableentry{VAX/VMS:}
              {F77\_\textit{type}\_TYPE name}
          }

         where \texttt{F77\_\textit{type}\_TYPE} expands to the appropriate C
         type.
      }
   }
}

\sstroutinenolabel{
   GENPTR\_\textit{type}
}{
   \relabel{GENPTR_type}Generate a pointer to an argument
}{
   \sstdescription{
      Ensure that there exists a pointer of the appropriate type to the
      variable that has been passed as an actual argument from FORTRAN to
      a C routine.
      Since FORTRAN usually passes arguments by reference, the pointer is
      commonly available directly from the argument list, so this macro is
      null.
      (\textit{type} not LOCATOR\@.)
   }
   \sstinvocation{
      GENPTR\_\textit{type}(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GENPTR\_\textit{type}(arg)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}{}
          }
      }
   }
   \sstdiytopic{Associated macro:}{
        \htmlref{\texttt{GENPTR\_CHARACTER}}{GENPTR_CHARACTER}
   }
}

\sstroutinenolabel{
   GENPTR\_\textit{type}\_ARRAY
}{
   \relabel{GENPTR_type_ARRAY}Generate a pointer to an array argument
}{
   \sstdescription{
      Ensure that there exists a pointer of the appropriate type to the array
      that has been passed as an actual argument to the C routine.
      Since FORTRAN usually passes arguments by reference, the pointer is
      commonly available directly from the argument list, so this macro is
      null.
      (\textit{type} not LOCATOR\@.)
   }
   \sstinvocation{
      GENPTR\_\textit{type}\_ARRAY(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GENPTR\_\textit{type}\_ARRAY(arg)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}{}
          }
      }
   }
   \sstdiytopic{Associated macro:}{
        \htmlref{\texttt{GENPTR\_CHARACTER\_ARRAY}}{GENPTR_CHARACTER_ARRAY}
   }
}

\sstroutinenolabel{
   GENPTR\_\textit{type}\_FUNCTION
}{
   \relabel{GENPTR_type_FUNCTION}Generate a pointer to a FUNCTION argument
}{
   \sstdescription{
      Ensure that there exists a pointer of the appropriate type to the
      FORTRAN FUNCTION that has been passed as an actual argument from
      FORTRAN to a C routine.
      Since FORTRAN usually passes arguments by reference, the pointer is
      commonly available directly from the argument list, so this macro is
      null.
      (\textit{type} not LOCATOR\@.)
   }
   \sstinvocation{
      GENPTR\_\textit{type}\_FUNCTION(name)
   }
   \sstarguments{
      \sstsubsection{
         name
      }{
         The dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GENPTR\_\textit{type}\_FUNCTION(name)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
                    {}
          }
      }
   }
   \sstnotes{
      The dummy argument should have been declared with the
      \textit{type}\_FUNCTION macro.
   }
}

\sstroutinenolabel{
   \textit{type}
}{
   \relabel{type}Declare a \textit{type} argument
}{
   \sstdescription{
      Declare a C function argument, given that the actual argument will
      be a variable of the appropriate type, passed from a FORTRAN program.
      (\textit{type} not LOCATOR\@.)
   }
   \sstinvocation{
      \textit{type}(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         \textit{type}(arg)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}
                {F77\_\textit{type}\_TYPE $*$arg}\\
            \sstexamplestableentry{VAX/VMS:}
                {F77\_\textit{type}\_TYPE $*$const arg}
          }

         where \texttt{F77\_\textit{type}\_TYPE} expands to the appropriate C
         type.
      }
   }
   \sstdiytopic{Associated macro:}{
        \htmlref{\texttt{CHARACTER}}{CHARACTER}
   }
}

\sstroutinenolabel{
   \textit{type}\_ARG
}{
   \relabel{type_ARG}Pass a \textit{type} argument to a FORTRAN routine
}{
   \sstdescription{
      Pass an argument of the appropriate type to a FORTRAN routine.
      The argument should be the address of the variable.
      (\textit{type} not LOCATOR\@.)
   }
   \sstinvocation{
      \textit{type}\_ARG(p\_arg)
   }
   \sstarguments{
      \sstsubsection{
         p\_arg
      }{
         A pointer to the actual argument being passed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         \textit{type}\_ARG(\&arg)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:} {\&arg}
          }
      }
   }
   \sstdiytopic{Associated macro:}{
        \htmlref{\texttt{CHARACTER\_ARG}}{CHARACTER_ARG}
   }
}

\sstroutinenolabel{
   \textit{type}\_ARRAY
}{
   \relabel{type_ARRAY}Declare a array argument
}{
   \sstdescription{
      Declare a C function argument, given that the actual argument will
      be an array of the appropriate type, passed from a FORTRAN program.
      (\textit{type} not LOCATOR\@.)
   }
   \sstinvocation{
      \textit{type}\_ARRAY(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         \textit{type}\_ARRAY(arg)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}
               {F77\_\textit{type}\_TYPE $*$arg}\\
            \sstexamplestableentry{VAX/VMS:}
               {F77\_\textit{type}\_TYPE $*$const arg}
          }

         where \texttt{F77\_\textit{type}\_TYPE} expands to the appropriate C
         type.
      }
   }
   \sstdiytopic{Associated macro:}{
        \htmlref{\texttt{CHARACTER\_ARRAY}}{CHARACTER_ARRAY}
   }
}
\sstroutinenolabel{
   \textit{type}\_ARRAY\_ARG
}{
   \relabel{type_ARRAY_ARG}Pass an array argument to a FORTRAN routine
}{
   \sstdescription{
      Pass an array argument of the appropriate type to a FORTRAN routine.
      The argument should be the address of the array.
      (\textit{type} not LOCATOR\@.)
   }
   \sstinvocation{
      \textit{type}\_ARRAY\_ARG(p\_arg)
   }
   \sstarguments{
      \sstsubsection{
         p\_arg
      }{
         A pointer to the actual array being passed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         \textit{type}\_ARRAY\_ARG(arg)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
                                  {(F77\_\textit{type}\_TYPE *)arg}
          }
      }
   }
   \sstnotes{
      The cast in the expansion for Unix ensures that multi-dimensional
      arrays (arrays of arrays), for example as declared by
      DECLARE\_\textit{type}\_ARRAY, may be passed.
   }
   \sstdiytopic{Associated macro:}{
        \htmlref{\texttt{CHARACTER\_ARRAY\_ARG}}{CHARACTER_ARRAY_ARG}
   }
}

\sstroutinenolabel{
   \textit{type}\_FUNCTION
}{
   \relabel{type_FUNCTION}Declare a FUNCTION argument
}{
   \sstdescription{
      Declare a C function argument, to be a FORTRAN-callable FUNCTION of
      the specified type, passed from a FORTRAN program.
      (\textit{type} is one of CHARACTER, INTEGER, REAL, DOUBLE, LOGICAL, BYTE,
      WORD, UBYTE, UWORD or POINTER\@.)
   }
   \sstinvocation{
      \textit{type}\_FUNCTION(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         \textit{type}\_FUNCTION(arg)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Systems:}
               {F77\_\textit{type}\_TYPE ($*$F77\_EXTERNAL\_NAME(arg))()}
          }

         where \texttt{F77\_\textit{type}\_TYPE} and
         \texttt{F77\_EXTERNAL\_NAME} expand appropriately for the platform.
      }
   }
}
\sstroutinenolabel{
   \textit{type}\_FUNCTION\_ARG
}{
   \relabel{type_FUNCTION_ARG}Pass a FUNCTION argument to a FORTRAN routine
}{
   \sstdescription{
      Pass a FORTRAN-callable FUNCTION of the appropriate type to a FORTRAN
      routine.
      The argument should be the address of the function being passed.
      (\textit{type} is one of CHARACTER, INTEGER, REAL, DOUBLE, LOGICAL, BYTE,
       WORD, UBYTE, UWORD or POINTER\@.)
   }
   \sstinvocation{
      \textit{type}\_FUNCTION\_ARG(p\_arg)
   }
   \sstarguments{
      \sstsubsection{
         p\_arg
      }{
         A pointer to the FUNCTION being passed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         \textit{type}\_FUNCTION\_ARG(arg)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
              {F77\_EXTERNAL\_NAME(arg)}
          }

         where \texttt{F77\_EXTERNAL\_NAME} expands appropriately for the
         platform.
      }
   }
}

\newpage
\subsection{\xlabel{specific_descriptions}\label{f77_specific}Specific Descriptions}
\sstroutine{
   CHARACTER
}{
   Declare a CHARACTER argument
}{
   \sstdescription{
      Declare a C function argument, given that the actual argument will
      be a CHARACTER variable passed from a FORTRAN program.
   }
   \sstinvocation{
      CHARACTER(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CHARACTER(x)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}  {char $*$x}\\
            \sstexamplestableentry{VAX/VMS:}
                 {struct dsc\$descriptor\_s $*$x\_arg}
          }
      }
   }
   \sstnotes{
         On a VAX/VMS system, the macro expands to a pointer to a
            descriptor whereas on other systems it expands to a pointer
            to char.
   }
}
\sstroutine{
   CHARACTER\_ARG
}{
   Pass a CHARACTER argument to a FORTRAN routine
}{
   \sstdescription{
      Pass a CHARACTER argument to a FORTRAN routine. The argument
      should be the address of a CHARACTER variable.
   }
   \sstinvocation{
      CHARACTER\_ARG(p\_arg)
   }
   \sstarguments{
      \sstsubsection{
         p\_arg
      }{
         A pointer to the actual argument being passed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CHARACTER\_ARG(charg)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}  {charg}\\
            \sstexamplestableentry{VAX/VMS:}{charg\_arg}
          }
      }
   }
}

\sstroutine{
   CHARACTER\_ARRAY
}{
   Declare a CHARACTER array argument
}{
   \sstdescription{
      Declare a C function argument, given that the actual argument will
      be a CHARACTER array passed from a FORTRAN program.
   }
   \sstinvocation{
      CHARACTER\_ARRAY(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CHARACTER\_ARRAY(x)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}  {char $*$x}\\
            \sstexamplestableentry{VAX/VMS:}
                    {struct dsc\$descriptor\_a $*$x\_arg}
          }
      }
   }
}
\sstroutine{
   CHARACTER\_ARRAY\_ARG
}{
   Pass a CHARACTER array argument to a FORTRAN routine
}{
   \sstdescription{
      Pass a CHARACTER array argument to a FORTRAN routine. The
      argument should be the address of a CHARACTER array.
   }
   \sstinvocation{
      CHARACTER\_ARRAY\_ARG(p\_arg)
   }
   \sstarguments{
      \sstsubsection{
         p\_arg
      }{
         A pointer to the actual array being passed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CHARACTER\_ARRAY\_ARG(charg)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}
               {(char *)charg}\\
            \sstexamplestableentry{VAX/VMS:}{charg\_arg}
          }
      }
   }
   \sstnotes{
      The cast in the expansion for Unix ensures that multi-dimensional
      arrays (arrays of arrays), for example as declared by
      DECLARE\_\textit{type}\_ARRAY, may be passed.
   }
}

\sstroutine{
   CHARACTER\_RETURN\_ARG
}{
   Pass argument(s) that will be the return value of a FORTRAN CHARACTER
   FUNCTION
}{
   \sstdescription{
      Pass the function return value argument(s) to a FORTRAN CHARACTER
      FUNCTION. There is no corresponding dummy argument in the FORTRAN
      FUNCTION, but the compiler generates an extra argument specifying
      the address and possibly another one, specifying the length of the
      value to be returned.
      The argument should be the address of a FORTRAN CHARACTER variable.
   }
   \sstinvocation{
      CHARACTER\_RETURN\_ARG(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The hidden dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CHARACTER\_RETURN\_ARG(x)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}  {x ,int x\_length}\\
            \sstexamplestableentry{VAX/VMS:}
                    {x\_arg}
          }
      }
   }
}

\sstroutine{
   CHARACTER\_RETURN\_VALUE
}{
   Declare argument(s) that will be the return value of a FORTRAN CHARACTER
   FUNCTION
}{
   \sstdescription{
      Declare the C function argument(s) to return the value of a FORTRAN
      CHARACTER FUNCTION. There is no corresponding actual argument in the
      FORTRAN call but the compiler generates an extra argument specifying
      the address and possibly another one, specifying the length of the
      value to be returned.
   }
   \sstinvocation{
      CHARACTER\_RETURN\_VALUE(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The hidden dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CHARACTER\_RETURN\_VALUE(x)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}  {char $*$x ,int x\_length}\\
            \sstexamplestableentry{VAX/VMS:}
                    {struct dsc\$descriptor\_s $*$x\_arg}
          }
      }
   }
}

\sstroutine{
   DECLARE\_CHARACTER
}{
   Declare a CHARACTER variable
}{
   \sstdescription{
      Declare a CHARACTER variable that will be passed to a FORTRAN routine.
      This variable will be the actual argument of a call to a FORTRAN
      routine.
   }
   \sstinvocation{
      DECLARE\_CHARACTER(arg,length)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The variable being declared.
      }
      \sstsubsection{
         length
      }{
         The length of the character string.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DECLARE\_CHARACTER(C,50)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}
                    {char C[50]; const int C\_length = 50}\\
            \sstexamplestableentry{VAX/VMS:}
                    {char C[50]; const int C\_length = 50;}\\
            \sstexamplestableentry{}
                    {struct dsc\$descriptor\_s C\_descr =}\\
            \sstexamplestableentry{}
                    {\{\texttt{50, DSC\$K\_DTYPE\_T, DSC\$K\_CLASS\_S, C \};}}\\
            \sstexamplestableentry{}
                    {struct dsc\$descriptor\_s $*$C\_arg =\&C\_descr}
          }
      }
   }
   \sstnotes{
         On VMS, the expansion of the macro is quite complex. A char
            array is declared as well as an int variable to store the
            length of the array. There is also a descriptor and a pointer
            to that descriptor. The address of the descriptor is what is
            actually passed to the called FORTRAN routine.
   }
}
\sstroutine{
   DECLARE\_CHARACTER\_ARRAY
}{
   Declare a CHARACTER array
}{
   \sstdescription{
      Declare a CHARACTER array that will be passed to a FORTRAN routine.
      This array will be the actual argument of a call to a FORTRAN
      routine.
   }
   \sstinvocation{
      DECLARE\_CHARACTER\_ARRAY(arg,length,dims)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The array being declared.
      }
      \sstsubsection{
         length
      }{
         The length of the character string.
      }
      \sstsubsection{
         dims
      }{
         The dimensions of the array.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DECLARE\_CHARACTER\_ARRAY(C,50,10)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}
                    {char C[10][50]; const int C\_length}\\
            \sstexamplestableentry{VAX/VMS:}
                    {char C[10][50]; const int C\_length = 50;}\\
            \sstexamplestableentry{}
                    {struct dsc\$descriptor\_s C\_descr =}\\
            \sstexamplestableentry{}
                    {\{\texttt{50, DSC\$K\_DTYPE\_T, DSC\$K\_CLASS\_S, C \};}}\\
            \sstexamplestableentry{}
                    {struct dsc\$descriptor\_s $*$C\_arg =\&C\_descr}
          }
      }
   }
   \sstnotes{
         On VMS, the expansion of the macro is quite complex. A char
            array is declared as well as an int variable to store the
            length of the array. There is also a descriptor and a pointer
            to that descriptor. The address of the descriptor is what is
            actually passed to the called FORTRAN routine.
   }
}

\sstroutine{
   DECLARE\_CHARACTER\_DYN
}{
   Declare a CHARACTER variable
}{
   \sstdescription{
      Declare a CHARACTER variable that will be passed to a FORTRAN routine
      using the CHARACTER\_ARG macro. Use this macro, in combination with
      the F77\_\-CREATE\_\-CHARACTER\ and F77\_\-FREE\_\-CHARACTER
      macros, where the length of the CHARACTER string is not known until
      run time.
   }
   \sstinvocation{
      DECLARE\_CHARACTER\_DYN(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The variable being declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         DECLARE\_CHARACTER\_DYN(fstring)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}
                    {char *fstring; int fstring\_length}\\
            \sstexamplestableentry{VAX/VMS:}
                    {char *fstring; int fstring\_length}\\
            \sstexamplestableentry{}
                    {struct dsc\$descriptor\_s *fstring\_arg}\\
          }
      }
   }
   \sstnotes{
         On VMS, the expansion of the macro is quite complex.
         A pointer to a descriptor structure is declared in addition to a
         pointer to char (used to point to the actual string of characters)
         and an int variable to  store the length of the array. The address
         of the descriptor is what is actually passed to the called FORTRAN
         routine.
   }
}

\sstroutine{
   F77\_BLANK\_COMMON
}{
   Refer to blank common
}{
   \sstdescription{
      Expands to the external name of blank common on the computer in
      use. This is used in declaring an external structure in C that
      overlays the FORTRAN blank common block.
   }
   \sstinvocation{
      F77\_BLANK\_COMMON
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_BLANK\_COMMON
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix}  {\_BLNK\_\_}\\
            \sstexamplestableentry{VAX/VMS:}{\$BLANK}
          }
      }
      \sstexamplesubsection{
         extern struct \{\texttt{ int i,j,k;\} F77\_BLANK\_COMMON;}
      }{
         declares an external structure to use the same storage as the
         FORTRAN blank common.
      }
      \sstexamplesubsection{
         F77\_BLANK\_COMMON.i
      }{
         refers to component i of the above structure.
      }
   }
}
\sstroutine{
   F77\_BYTE\_TYPE
}{
   Define the type BYTE
}{
   \sstdescription{
      Define the C type that corresponds to the FORTRAN type BYTE.
   }
   \sstinvocation{
      F77\_BYTE\_TYPE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_BYTE\_TYPE
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}{signed char}\\
            \sstexamplestableentry{VAX/VMS:}{char}
          }
      }
   }
}
\sstroutine{
   F77\_CALL
}{
   Call a FORTRAN routine from C
}{
   \sstdescription{
      Call a FORTRAN subroutine or function from a C routine.
   }
   \sstinvocation{
      F77\_CALL(name)
   }
   \sstarguments{
      \sstsubsection{
         name
      }{
         The name of the FORTRAN routine being called.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_CALL(suba)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}  {suba\_}\\
            \sstexamplestableentry{VAX/VMS:}{suba}
          }
      }
   }
   \sstnotes{
      This macro is just a shorthand for F77\_EXTERNAL\_NAME. It is more
      expressive to use F77\_CALL rather than F77\_EXTERNAL\_NAME when
      calling a routine.
   }
}

\sstroutine{
   F77\_CHARACTER\_ARG\_TYPE
}{
   Define the type of a FORTRAN CHARACTER argument
}{
   \sstdescription{
      Defines the C type that corresponds to the type of a FORTRAN CHARACTER
      argument.
   }
   \sstinvocation{
      F77\_CHARACTER\_ARG\_TYPE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_CHARACTER\_ARG\_TYPE
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}
                    {char}\\
            \sstexamplestableentry{VAX/VMS:}
                    {struct dsc\$descriptor\_s}\\
          }
      }
   }
   \sstnotes{
      The type of the CHARACTER argument passed to a FORTRAN subroutine is
      not the same as the CHARACTER\_TYPE on VMS so this macro is provided.
      It is unlikely to be used directly.
   }
}

\sstroutine{
   F77\_CHARACTER\_ARRAY\_ARG\_TYPE
}{
   Define the type of a FORTRAN CHARACTER array argument
}{
   \sstdescription{
      Defines the C type that corresponds to the type of a FORTRAN CHARACTER
      array argument.
   }
   \sstinvocation{
      F77\_CHARACTER\_ARRAY\_ARG\_TYPE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_CHARACTER\_ARRAY\_ARG\_TYPE
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}
                    {char}\\
            \sstexamplestableentry{VAX/VMS:}
                    {struct dsc\$descriptor\_a}\\
          }
      }
   }
   \sstnotes{
      The type of the CHARACTER array argument passed to a FORTRAN subroutine
      is not the same as the CHARACTER\_TYPE on VMS so this macro is provided.
      It is unlikely to be used directly.
   }
}

\sstroutine{
   F77\_CHARACTER\_TYPE
}{
   Define the type CHARACTER
}{
   \sstdescription{
      Define the C type that corresponds to the FORTRAN type CHARACTER.
   }
   \sstinvocation{
      F77\_CHARACTER\_TYPE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_CHARACTER\_TYPE
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}  {char}
          }
      }
   }
}

\sstroutine{
   F77\_CREATE\_CHARACTER
}{
   Create a FORTRAN CHARACTER variable
}{
   \sstdescription{
      Create a CHARACTER variable that will be passed to a FORTRAN routine
      using the CHARACTER\_\-ARG macro. Use this macro, in combination with
      the DECLARE\-\_\-CHARACTER\_\-DYN and F77\_\-FREE\_\-\-CHARACTER
      macros, where the length of the CHARACTER string is not known until
      run time. A pointer to the actual string of characters and an integer
      variable giving the length of the string are set.
   }
   \sstinvocation{
      F77\_CREATE\_CHARACTER(arg,length)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The variable being created.
      }
      \sstsubsection{
         length
      }{
         The length of the character string. This will usually be a variable
         name or expression of type int.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_CREATE\_CHARACTER(fstring,strlen(cstring))
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}
                    {fstring\_length = strlen(cstring);}\\
            \sstexamplestableentry{}
                    {fstring = cnfCref(fstring\_length)}\\
            \sstexamplestableentry{VAX/VMS:}
                    {fstring\_arg = cnfCref(strlen(cstring));}\\
            \sstexamplestableentry{}
                    {fstring = fstring\_arg->pointer;}\\
            \sstexamplestableentry{}
                    {fstring\_length = fstring\_arg->length}
          }
      }
   }
   \sstnotes{
         On VMS, the expansion of the macro is quite complex.
         A descriptor structure and a pointer to it are set up in
         addition to the pointer to the actual string of characters and
         the length of the string. (The address of the descriptor is what
         is actually passed to the called FORTRAN routine.)
   }
}

\sstroutine{
   F77\_CREATE\_CHARACTER\_ARRAY
}{
   Create a FORTRAN CHARACTER array
}{
   \sstdescription{
      Create a CHARACTER array that will be passed to a FORTRAN routine
      using the CHARACTER\_\-ARRAY\_\-ARG macro. Use this macro, in combination
      with
      the DECLARE\_\-CHARACTER\_\-ARRAY\_\-DYN and F77\_\-FREE\_\-CHARACTER
      macros, where the size of the CHARACTER array is not known until
      run time. A pointer to the actual string of characters and an integer
      variable giving the length of the string are set.
   }
   \sstinvocation{
      F77\_CREATE\_CHARACTER\_ARRAY(arg,length,nels)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The variable being created.
      }
      \sstsubsection{
         length
      }{
         The length of the character string. This will usually be a variable
         name or expression of type int.
      }
      \sstsubsection{
         nels
      }{
         The number of elements.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_CREATE\_CHARACTER\_ARRAY(fstring,strlen(cstring),nels)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}
               {\{\texttt{ int f77dims[1];f77dims[0]=nels;}}\\
            \sstexamplestableentry{}
               {fstring=cnfCrefa(strlen(cstring),1,f77dims);}\\
            \sstexamplestableentry{}
               {fstring\_length=strlen(cstring);\}}\\
            \sstexamplestableentry{VAX/VMS:}
                    {\{\texttt{ int f77dims[1];f77dims[0]=nels;}}\\
            \sstexamplestableentry{}
                    {fstring\_arg = cnfCrefa(strlen(cstring),1,f77dims);}\\
            \sstexamplestableentry{}
                    {fstring = fstring\_arg->pointer;}\\
            \sstexamplestableentry{}
                    {fstring\_length = fstring\_arg->length;\}}
          }
      }
   }
   \sstnotes{
         On VMS, the expansion of the macro is quite complex.
         A descriptor structure and a pointer to it are set up in
         addition to the pointer to the actual array of strings and
         the length of the strings. (The address of the descriptor is what
         is actually passed to the called FORTRAN routine.)
   }
}

\sstroutine{
   F77\_CREATE\_CHARACTER\_ARRAY\_M
}{
   Create a FORTRAN CHARACTER array (n-D)
}{
   \sstdescription{
      Create an n-D CHARACTER array that will be passed to a FORTRAN routine
      using the CHARACTER\_\-ARRAY\_\-ARG macro. Use this macro, in combination
      with
      the DECLARE\_\-CHARACTER\_\-ARRAY\_\-DYN and F77\_\-FREE\_\-CHARACTER
      macros, where the size of the CHARACTER array is not known until
      run time. A pointer to the actual string of characters and an integer
      variable giving the length of the string are set.
   }
   \sstinvocation{
      F77\_CREATE\_CHARACTER\_ARRAY\_M(arg,length,ndims,dims)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The variable being created.
      }
      \sstsubsection{
         length
      }{
         The length of the character string. This will usually be a variable
         name or expression of type int.
      }
      \sstsubsection{
         ndims
      }{
         The number of dimensions.
      }
      \sstsubsection{
         dims
      }{
         A 1-D array holding the ndims dimensions.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_CREATE\_CHARACTER\_ARRAY\_M(fstring,strlen(cstring),ndims,dims)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}
               {fstring=cnfCrefa(strlen(cstring),ndims,dims);}\\
            \sstexamplestableentry{}
               {fstring\_length=strlen(cstring)}\\
            \sstexamplestableentry{VAX/VMS:}
                    {fstring\_arg = cnfCrefa(strlen(cstring),ndims,dims);}\\
            \sstexamplestableentry{}
                    {fstring = fstring\_arg->pointer;}\\
            \sstexamplestableentry{}
                    {fstring\_length = fstring\_arg->length}
          }
      }
   }
   \sstnotes{
         On VMS, the expansion of the macro is quite complex.
         A descriptor structure and a pointer to it are set up in
         addition to the pointer to the actual array of strings and
         the length of the strings. (The address of the descriptor is what
         is actually passed to the called FORTRAN routine.)
   }
}

\sstroutine{
   F77\_CREATE\_LOGICAL\_ARRAY\_M
}{
   Create a FORTRAN LOGICAL array (n-D)
}{
   \sstdescription{
      Create a LOGICAL array that will be passed to a FORTRAN routine
      using the LOGICAL\_\-ARRAY\_\-ARG macro. Use this macro, in combination
      with
      the DECLARE\_\-LOGICAL\_\-ARRAY\_\-DYN and F77\_\-FREE\_\-LOGICAL
      macros, where the size of the LOGICAL array is not known until
      run time.
   }
   \sstinvocation{
      F77\_CREATE\_LOGICAL\_ARRAY\_M(arg,ndims,dims)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The array being created.
      }
      \sstsubsection{
         ndims
      }{
         The number of dimensions.
      }
      \sstsubsection{
         dims
      }{
         A 1-D array holding the ndims dimensions.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_CREATE\_LOGICAL\_ARRAY\_M(flog,ndims,dims)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
               {flog=cnfCrela(ndims,dims);}\\
          }
      }
   }
}

\sstroutine{
   F77\_DOUBLE\_TYPE
}{
   Define the type DOUBLE PRECISION
}{
   \sstdescription{
      Define the C type that corresponds to the FORTRAN type DOUBLE
      PRECISION.
   }
   \sstinvocation{
      F77\_DOUBLE\_TYPE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_DOUBLE\_TYPE
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}{double}
          }
      }
   }
}

\sstroutine{
   F77\_EXPORT\_CHARACTER
}{
   Export a C variable to a FORTRAN variable.
}{
   \sstdescription{
      Copies a C variable to a FORTRAN variable making any required changes
      to the data.
   }
   \sstinvocation{
      F77\_EXPORT\_CHARACTER(carg,farg,len)
   }
   \sstarguments{
      \sstsubsection{
         carg
      }{
         The C value
      }
      \sstsubsection{
         farg
      }{
         The FORTRAN variable
      }
      \sstsubsection{
         len
      }{
         The length of the FORTRAN string
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_EXPORT\_CHARACTER(carg,farg,len)
      }{
         will expand as follows:

         \sstexamplestable{
            \sstexamplestableentry{All systems:}
            {cnfExprt(carg,farg,len)}
         }
      }
   }
   \sstdiytopic{Associated macro:}{
      \htmlref{\texttt{F77\_IMPORT\_CHARACTER}}{F77_IMPORT_CHARACTER}
   }
}

\sstroutine{
   F77\_EXPORT\_CHARACTER\_ARRAY
}{
   Export a CHARACTER array from C to FORTRAN
}{
   \sstdescription{
      The C array will be copied to the FORTRAN array, making any required
      changes to the data
   }
   \sstinvocation{
      F77\_EXPORT\_CHARACTER\_ARRAY(carg,lc,farg,lf,nels)
   }
   \sstarguments{
      \sstsubsection{
         carg
      }{
         A pointer to the C array
      }
      \sstsubsection{
         lc
      }{
         The length of the C strings
      }
      \sstsubsection{
         farg
      }{
         A pointer to the FORTRAN array
      }
      \sstsubsection{
         lf
      }{
         The length of the FORTRAN strings
      }
      \sstsubsection{
         nels
      }{
         The number of elements to be exported
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_EXPORT\_CHARACTER\_ARRAY(farg,lf,carg,lc,nels)
      }{
         will expand as follows:

         \sstexamplestable{
            \sstexamplestableentry{}
               {\{\texttt{ int f77dims[1];f77dims[0]=nels;}}\\
            \sstexamplestableentry{}
               {cnfExprta(carg,lc,farg,lf,1,f77dims);\} }
         }
      }
   }
   \sstdiytopic{Associated macro:}{
      \htmlref{\texttt{F77\_IMPORT\_CHARACTER\_ARRAY}}
              {F77_IMPORT_CHARACTER_ARRAY}
   }
}

\sstroutine{
   F77\_EXPORT\_CHARACTER\_ARRAY\_P
}{
   Export an array of pointers to char from C to a FORTRAN CHARACTER array.
}{
   \sstdescription{
      The strings pointed to by the specified number of elements of the C
      array will be copied to the FORTRAN array, making any required changes
      to the data.
   }
   \sstinvocation{
      F77\_EXPORT\_CHARACTER\_ARRAY\_P(carg,farg,lf,nels)
   }
   \sstarguments{
      \sstsubsection{
         carg
      }{
         A pointer to the C array
      }
      \sstsubsection{
         farg
      }{
         A pointer to the FORTRAN array
      }
      \sstsubsection{
         lf
      }{
         The length of the FORTRAN strings
      }
      \sstsubsection{
         nels
      }{
         The number of elements to be exported
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_EXPORT\_CHARACTER\_ARRAY\_P(carg,farg,lc,nels)
      }{
         will expand as follows:

         \sstexamplestable{
            \sstexamplestableentry{All systems:}
               { \{\texttt{ int f77dims[1];f77dims[0]=nels;}}\\
            \sstexamplestableentry{}
               {cnfExprtap(carg,farg,lf,1,f77dims);\}}
         }
      }
   }
   \sstdiytopic{Associated macro:}{
      \htmlref{\texttt{F77\_IMPORT\_CHARACTER\_ARRAY\_P}}
              {F77_IMPORT_CHARACTER_ARRAY_P}
   }
}

\sstroutine{
   F77\_EXTERNAL\_NAME
}{
   The external name of a function
}{
   \sstdescription{
      Define the external name of a C function. This may have such
      things as trailing underscores.
   }
   \sstinvocation{
      F77\_EXTERNAL\_NAME
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_EXTERNAL\_NAME(name)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}  {name\_}\\
            \sstexamplestableentry{VAX/VMS:}{name}
          }
      }
   }
}
\sstroutine{
   F77\_FALSE
}{
   The logical value FALSE
}{
   \sstdescription{
      Expand to the number that FORTRAN treats as a logical value of
      FALSE.
   }
   \sstinvocation{
      F77\_FALSE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_FALSE
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}{0}
          }
      }
   }
   \sstnotes{
         FORTRAN and C might not interpret the same numerical value as
            the same logical value.
   }
}

\sstroutine{
   F77\_IMPORT\_CHARACTER
}{
   Import a FORTRAN variable to a C variable.
}{
   \sstdescription{
      Copies a FORTRAN CHARACTER string to a C string, making any necessary
      changes to the data
   }
   \sstinvocation{
      F77\_IMPORT\_CHARACTER(farg,len,carg)
   }
   \sstarguments{
      \sstsubsection{
         farg
      }{
         The FORTRAN string
      }
      \sstsubsection{
         len
      }{
         The length of the FORTRAN string
      }
      \sstsubsection{
         carg
      }{
         The C string
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_IMPORT\_CHARACTER(farg,len,carg)
      }{
         will expand as follows:

         \sstexamplestable{
            \sstexamplestableentry{All systems:}
            {cnfImprt(farg,len,carg)}
         }
      }
   }
   \sstdiytopic{Associated macro:}{
      \htmlref{\texttt{F77\_EXPORT\_CHARACTER}}{F77_EXPORT_CHARACTER}
   }
}

\sstroutine{
   F77\_IMPORT\_CHARACTER\_ARRAY
}{
   Import a CHARACTER array from FORTRAN to C.
}{
   \sstdescription{
      The FORTRAN array will be copied to the the C array, making any
      required changes to the data.
   }
   \sstinvocation{
      F77\_IMPORT\_CHARACTER\_ARRAY(farg,len\_f,carg,len\_c,nels)
   }
   \sstarguments{
      \sstsubsection{
         farg
      }{
         A pointer to the FORTRAN array
      }
      \sstsubsection{
         len\_f
      }{
         The length of each element of the FORTRAN array
      }
      \sstsubsection{
         carg
      }{
         A pointer to the C array
      }
      \sstsubsection{
         len\_c
      }{
         The length of each element of the C array
      }
      \sstsubsection{
         nels
      }{
         The number of elements to be exported
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_IMPORT\_CHARACTER\_ARRAY(farg,lf,carg,lc,nels)
      }{
         will expand as follows:

         \sstexamplestable{
            \sstexamplestableentry{All systems:}
               {\{\texttt{ int f77dims[1];f77dims[0]=nels;}}\\
            \sstexamplestableentry{}
               {cnfImprta(farg,lf,carg,lc,1,f77dims);\}}
         }
      }
   }
   \sstdiytopic{Associated macro:}{
      \htmlref{\texttt{F77\_EXPORT\_CHARACTER\_ARRAY}}
              {F77_EXPORT_CHARACTER_ARRAY}
   }
}

\sstroutine{
   F77\_IMPORT\_CHARACTER\_ARRAY\_P
}{
   Import a FORTRAN CHARACTER array to a C array of pointers to char.
}{
   \sstdescription{
      The FORTRAN array will be copied to the series of C strings pointed
      at by the elements of the C array of pointers. If there is room
      (determined by the given maximum string length) strings will be
      null-terminated. Any required changes to the data will be made.
   }
   \sstinvocation{
      F77\_IMPORT\_CHARACTER\_ARRAY\_P(farg,len\_f,carg,len\_c,nels)
   }
   \sstarguments{
      \sstsubsection{
         farg
      }{
         A pointer to the FORTRAN array
      }
      \sstsubsection{
         len\_f
      }{
         The length of each element of the FORTRAN array
      }
      \sstsubsection{
         carg
      }{
         A pointer to the C array
      }
      \sstsubsection{
         len\_c
      }{
         The maximum length of the C strings, including terminating null
         if required.
      }
      \sstsubsection{
         nels
      }{
         The number of elements to be exported
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_IMPORT\_CHARACTER\_ARRAY\_P(farg,lf,carg,lc,nels)
      }{
         will expand as follows:

         \sstexamplestable{
            \sstexamplestableentry{All systems:}
               {\{\texttt{ int f77dims[1];f77dims[0]=nels;}}\\
            \sstexamplestableentry{}
               {cnfImprtap(farg,lf,carg,lc,f77dims);\}}
         }
      }
   }
   \sstdiytopic{Associated macro:}{
      \htmlref{\texttt{F77\_EXPORT\_CHARACTER\_ARRAY\_P}}
              {F77_EXPORT_CHARACTER_ARRAY_P}
   }
}

\sstroutine{
   F77\_INTEGER\_TYPE
}{
   Define the type INTEGER
}{
   \sstdescription{
      Define the C type that corresponds to the FORTRAN type INTEGER.
   }
   \sstinvocation{
      F77\_INTEGER\_TYPE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_INTEGER\_TYPE
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}{int}
          }
      }
   }
}
\sstroutine{
   F77\_ISFALSE
}{
   Is this the FORTRAN logical value false?
}{
   \sstdescription{
      Does the argument of the macro evaluate to a value that FORTRAN
      would treat as a LOGICAL false?
   }
   \sstinvocation{
      if( F77\_ISFALSE(var) ) ...
   }
   \sstarguments{
      \sstsubsection{
         var
      }{
         The name of the value to be tested.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_ISFALSE(var)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{Solaris:}  {( ! ( var ) )}\\
            \sstexamplestableentry{OSF/1:}{( ! ( (var)\&1 ) )}\\
            \sstexamplestableentry{VAX/VMS:}{( ! ( (var)\&1 ) )}
          }
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The VAX FORTRAN and DEC FORTRAN for RISC compilers only use the
            lowest bit for the logical flag.
            Hence 0 = false, 1 = true, 2 = false, 3 = true, etc.

         \sstitem
         The Sun FORTRAN compiler uses zero = false, non zero = true.

         \sstitem
         The FORTRAN for RISC compiler (from MIPS) on the DECstation
            uses zero = false, non zero = true. This means that the correct
            value of this C macro depends on which FORTRAN compiler is
            being used.
      }
   }
}
\sstroutine{
   F77\_LOCK
}{
   Prevents code from being run simultaneously in two separate threads
}{
   \sstdescription{
      Any C code that may need to be used in a threaded context
      should use this macro should to prevent Fortran code being run
      simultaneously in two separate threads, with consequent danger of
      unsynchronised memory access. The macro locks the global CNF mutex,
      then executes the code specified in the argument, and then unlocks
      the mutex. If the mutex is currently locked by another thread (e.g.
      due to the use of F77\_LOCK in the other thread), then the calling
      thread blocks until the other thread releases the mutex.
   }
   \sstinvocation{
      F77\_LOCK(code)
   }
   \sstarguments{
      \sstsubsection{
         code
      }{
         Any arbitrary C code. Typically, this will be an invocation of a
         Fortran subroutine.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_LOCK( result = F77\_CALL(sim)( nel, data, status ); )
      }{
      }
   }
   \sstnotes{
      This macro invokes the cnfLock and cnfUnlock functions to lock and
      unlock the global mutex.
   }
}
\sstroutine{
   F77\_ISTRUE
}{
   Is this the FORTRAN logical value true?
}{
   \sstdescription{
      Does the argument of the macro evaluate to a value that FORTRAN
      would treat as a LOGICAL true?
   }
   \sstinvocation{
      if( F77\_ISTRUE(var) ) ...
   }
   \sstarguments{
      \sstsubsection{
         var
      }{
         The name of the value to be tested.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_ISTRUE(var)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{Solaris:}  {( var )}\\
            \sstexamplestableentry{OSF/1:}{( (var)\&1 )}\\
            \sstexamplestableentry{VAX/VMS:}{( (var)\&1 )}
          }
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The VAX FORTRAN and DEC FORTRAN for RISC compilers only use the
            lowest bit for the logical flag.
            Hence 0 = false, 1 = true, 2 = false, 3 = true, etc.

         \sstitem
         The Sun FORTRAN compiler uses zero = false, non zero = true.

         \sstitem
         The FORTRAN for RISC compiler (from MIPS) on the DECstation
            uses zero = false, non zero = true. This means that the correct
            value of this C macro depends on which FORTRAN compiler is
            being used.
      }
   }
}

\sstroutine{
   F77\_LOGICAL\_TYPE
}{
   Define the type LOGICAL
}{
   \sstdescription{
      Define the C type that corresponds to the FORTRAN type LOGICAL.
   }
   \sstinvocation{
      F77\_LOGICAL\_TYPE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_LOGICAL\_TYPE
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}{int}
          }
      }
   }
}
\sstroutine{
   F77\_NAMED\_COMMON
}{
   Refer to a named common block
}{
   \sstdescription{
      Expand to the external name of a named common block on the
      computer in use. This is used in declaring an external structure
      in C that overlays a FORTRAN named common block.
   }
   \sstinvocation{
      F77\_NAMED\_COMMON(name)
   }
   \sstarguments{
      \sstsubsection{
         name
      }{
         The name of the common block.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_NAMED\_COMMON(name)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}  {name\_}\\
            \sstexamplestableentry{VAX/VMS:}{name}
          }
      }
      \sstexamplesubsection{
         extern struct \{int i,j,k;\} F77\_NAMED\_COMMON(block);
      }{
         declares an external structure to use the same storage as the
         FORTRAN named common block.
      }
      \sstexamplesubsection{
         F77\_NAMED\_COMMON(block).i
      }{
         refers to component i of the above structure.
      }
   }
}

\sstroutine{
   F77\_POINTER\_TYPE
}{
   Define the type POINTER
}{
   \sstdescription{
      Define the C type that corresponds to a FORTRAN integer used as a
      pointer.
   }
   \sstinvocation{
      F77\_POINTER\_TYPE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_POINTER\_TYPE
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}  {unsigned int}
          }
      }
   }
}

\sstroutine{
   F77\_REAL\_TYPE
}{
   Define the type REAL
}{
   \sstdescription{
      Define the C type that corresponds to the FORTRAN type REAL.
   }
   \sstinvocation{
      F77\_REAL\_TYPE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_REAL\_TYPE
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}{float}
          }
      }
   }
}
\sstroutine{
   F77\_SUBROUTINE
}{
   Declare a SUBROUTINE
}{
   \sstdescription{
      Declare a C function that will be called from FORTRAN as though it
      were a subroutine.
   }
   \sstinvocation{
      F77\_SUBROUTINE(name)
   }
   \sstarguments{
      \sstsubsection{
         name
      }{
         The name of the function to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_SUBROUTINE(name)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}  {void name\_}\\
            \sstexamplestableentry{VAX/VMS:}{void name}
          }
      }
   }
}
\sstroutine{
   F77\_TRUE
}{
   The logical value TRUE
}{
   \sstdescription{
      Expand to the number that FORTRAN treats as a logical value of
      TRUE.
   }
   \sstinvocation{
      F77\_TRUE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_TRUE
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{Solaris:}  {1}\\
            \sstexamplestableentry{OSF/1:}{-1}\\
            \sstexamplestableentry{VAX/VMS:}{-1}
          }
      }
   }
   \sstnotes{
         FORTRAN and C might not interpret the same numerical value as
            the same logical value.
   }
}

\sstroutine{
   F77\_UBYTE\_TYPE
}{
   Define the type UBYTE
}{
   \sstdescription{
      Define the C type that corresponds to the type UBYTE.
   }
   \sstinvocation{
      F77\_UBYTE\_TYPE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_UBYTE\_TYPE
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}  {unsigned char}\\
          }
      }
   }
}

\sstroutine{
   F77\_UWORD\_TYPE
}{
   Define the type UWORD
}{
   \sstdescription{
      Define the C type that corresponds to the type UWORD.
   }
   \sstinvocation{
      F77\_UWORD\_TYPE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_UWORD\_TYPE
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}  {unsigned short int}\\
          }
      }
   }
}

\sstroutine{
   F77\_WORD\_TYPE
}{
   Define the type WORD
}{
   \sstdescription{
      Define the C type that corresponds to the FORTRAN type WORD.
   }
   \sstinvocation{
      F77\_WORD\_TYPE
   }
   \sstexamples{
      \sstexamplesubsection{
         F77\_WORD\_TYPE
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}  {short int}\\
          }
      }
   }
}

\sstroutine{
   GENPTR\_CHARACTER
}{
   Generate a pointer to a CHARACTER argument
}{
   \sstdescription{
      Ensure that there exists a pointer to the character variable that
      has been passed as an actual argument to the C routine. Also
      generate a variable that contains the length of the actual
      character argument and call it `arg\_length'.
   }
   \sstinvocation{
      GENPTR\_CHARACTER(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GENPTR\_CHARACTER(x)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}{}\\
            \sstexamplestableentry{VAX/VMS:}
                   {char $*$x = x\_arg-$>$dsc\$a\_pointer;}\\
            \sstexamplestableentry{}
                   {int x\_length = x\_arg-$>$dsc\$w\_length;}
          }
      }
   }
   \sstnotes{
         On Unix systems, this macro is null, but on a VAX/VMS system,
            this macro actually declares the variables that are the pointer
            to the character string and the integer that contains its
            length.
   }
}
\sstroutine{
   GENPTR\_CHARACTER\_ARRAY
}{
   Generate a pointer to a CHARACTER array argument
}{
   \sstdescription{
      Ensure that there exists a pointer to the character array that
      has been passed as an actual argument to the C routine. Also
      generate a variable that contains the length of the actual
      character argument and call it `arg\_length'.
   }
   \sstinvocation{
      GENPTR\_CHARACTER\_ARRAY(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GENPTR\_CHARACTER\_ARRAY(x)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}{}\\
            \sstexamplestableentry{VAX/VMS:}
                  {char $*$x = x\_arg-$>$dsc\$a\_pointer;}\\
            \sstexamplestableentry{}
                  {int x\_length = x\_arg-$>$dsc\$w\_length;}
          }
      }
   }
   \sstnotes{
         On Unix systems, this macro is null, but on a VAX/VMS system,
            this macro actually declares the variables that are the pointer
            to the character string and the integer that contains its
            length.
   }
}

\sstroutine{
   GENPTR\_SUBROUTINE
}{
   Generate a pointer to a SUBROUTINE argument.
}{
   \sstdescription{
      Ensure that there exists a pointer to the subroutine that has been passed
      as an actual argument from FORTRAN to the C function. Since FORTRAN
      usually passes arguments by reference, the pointer is commonly available
      directly from the argument list, so this macro is null.
   }
   \sstinvocation{
      GENPTR\_SUBROUTINE(name)
   }
   \sstarguments{
      \sstsubsection{
         name
      }{
         The dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         GENPTR\_SUBROUTINE(name)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:} {}
          }
      }
   }
   \sstnotes{
      The dummy argument should have been declared with the SUBROUTINE macro.
   }
}

\sstroutine{
   SUBROUTINE
}{
   Declare a SUBROUTINE argument.
}{
   \sstdescription{
      Declare a C function argument, given that the actual argument will be a
      SUBROUTINE name passed from a FORTRAN program.
   }
   \sstinvocation{
      SUBROUTINE(name)
   }
   \sstarguments{
      \sstsubsection{
         name
      }{
         The dummy argument to be declared.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         SUBROUTINE(name)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
                    {void (*name)()}
          }
      }
   }
}

\sstroutine{
   SUBROUTINE\_ARG
}{
   Pass a SUBROUTINE argument to a FORTRAN routine.
}{
   \sstdescription{
      Pass a SUBROUTINE argument to a FORTRAN routine.
      The argument should be a pointer to a subroutine designed to be called
      from a FORTRAN program.
   }
   \sstinvocation{
      SUBROUTINE\_ARG(p\_name)
   }
   \sstarguments{
      \sstsubsection{
         p\_name
      }{
         A pointer to the actual subroutine to be used.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         SUBROUTINE\_ARG(name)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All systems:}
                    {name}
          }
      }
   }
}

\sstroutine{
   TRAIL
}{
   Declare hidden trailing arguments
}{
   \sstdescription{
      Declare an argument on those machines that put an extra value at
      the end of the argument list to specify the length of a CHARACTER
      variable or array element.
   }
   \sstinvocation{
      TRAIL(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The name of the CHARACTER or CHARACTER array dummy argument.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         TRAIL(arg)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{32bit Unix:}  {,int arg\_length}\\
            \sstexamplestableentry{Some 64bit Unix:}  {,long arg\_length}\\
            \sstexamplestableentry{VAX/VMS:}{}
          }
      }
   }
}
\sstroutine{
   TRAIL\_ARG
}{
   Pass the length of a CHARACTER argument to a FORTRAN routine
}{
   \sstdescription{
      Pass the length of a CHARACTER argument or a CHARACTER array argument
      element length to a FORTRAN routine if the FORTRAN routine expects to
      receive it as a separate argument. The corresponding integer variable is
      handled automatically where it is needed.
   }
   \sstinvocation{
      TRAIL\_ARG(arg)
   }
   \sstarguments{
      \sstsubsection{
         arg
      }{
         The name of the CHARACTER or CHARACTER array actual argument being
         passed.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         TRAIL\_ARG(arg)
      }{
         will expand as follows:

          \sstexamplestable{
            \sstexamplestableentry{All Unix:}  {,arg\_length}\\
            \sstexamplestableentry{VAX/VMS:}{}
          }
      }
   }
}

% CNF functions

\newpage

\section{\xlabel{classified_list_of_cnf_functions}Classified List of CNF Functions}
\subsection{\xlabel{import_a_fortran_string_to_c}Import a FORTRAN String to C}
\routinelist{
\listroutine{cnfCreib}
{   Create a temporary C string and import a blank filled FORTRAN
   string into it}
\listroutine{cnfCreim}
{   Create a temporary C string and import a FORTRAN string into it}
\listroutine{cnfImpb}
{   Import a FORTRAN string into a C string, retaining trailing blanks}
\listroutine{cnfImpbn}
{   Import no more than max characters from a FORTRAN string into a C string,
retaining trailing blanks}
\listroutine{cnfImpch}
{   Import a given number of characters from a FORTRAN string into an array
of char}
\listroutine{cnfImpn}
{   Import no more than max characters from a FORTRAN string into a C string}
\listroutine{cnfImprt}
{   Import a FORTRAN string into a C string}
\listroutine{cnfImprta}
{   Import a FORTRAN CHARACTER array into a C array}
\listroutine{cnfImprtap}
{   Import a FORTRAN CHARACTER array into a C array of pointers to char}
}

\subsection{\xlabel{export_a_c_string_to_fortran}Export a C String to FORTRAN}
\routinelist{
\listroutine{cnfExpch}
{   Export a given number of characters from an array of char into a FORTRAN
string}
\listroutine{cnfExpn}
{   Export a C string to a FORTRAN string, copying given a maximum number of
characters}
\listroutine{cnfExprt}
{   Export a C string to a FORTRAN string}
\listroutine{cnfExprta}
{   Export a C string array to a FORTRAN CHARACTER array}
\listroutine{cnfExprtap}
{   Export a C array of pointers to char, to a FORTRAN CHARACTER array}
}

\subsection{\xlabel{string_lengths}String Lengths}
\routinelist{
\listroutine{cnfLenc}
{   Find the length of a C string}
\listroutine{cnfLenf}
{   Find the length of a FORTRAN string}
}

\subsection{\xlabel{miscellaneous_string_handling}Miscellaneous String Handling}
\routinelist{
\listroutine{cnfCopyf}
{   Copy one FORTRAN string to another FORTRAN string}
\listroutine{cnfCreat}
{   Create a temporary C string and return a pointer to it}
\listroutine{cnfCref}
{   Create a temporary FORTRAN string and return a pointer to it}
\listroutine{cnfCrefa}
{   Create a temporary FORTRAN CHARACTER array and return a pointer to it}
\listroutine{cnfFree}
{   Free allocated space}
\listroutine{cnfFreef}
{   Return temporary FORTRAN string space}
}

\subsection{\xlabel{logical_array_handling}LOGICAL Array Handling}
\routinelist{
\listroutine{cnfCrela}
{   Create a temporary FORTRAN LOGICAL array and return a pointer to it}
\listroutine{cnfImpla}
{   Import a FORTRAN LOGICAL array into a C int array}
\listroutine{cnfExpla}
{   Export a C int array into a FORTRAN LOGICAL array}
}

\subsection{\xlabel{memory_and_pointer_handling}Memory and Pointer Handling}
\routinelist{
\listroutine{cnfCalloc}
{   Allocate space that may be accessed from C and FORTRAN}
\listroutine{cnfCptr}
{   Convert a FORTRAN pointer to a C pointer}
\listroutine{cnfFptr}
{   Convert a C pointer to a FORTRAN pointer}
\listroutine{cnfFree}
{   Free allocated space}
\listroutine{cnfMalloc}
{   Allocate space that may be accessed from C and FORTRAN}
\listroutine{cnfRegp}
{   Register a pointer for use from both C and FORTRAN}
\listroutine{cnfUregp}
{   Unregister a pointer previously registered using cnfRegp}
\listroutine{CNF\_PVAL}
{   Expand a FORTRAN pointer to its full value (FORTRAN function)}
}
\newpage
\section{\xlabel{cnf_routine_descriptions}
\xlabel{cnf_c_routine_descriptions}
\label{cnf_description}CNF C Routine Descriptions}
\sstroutine{
   cnfCalloc
}{
   Allocate space that may be accessed from C and FORTRAN
}{
   \sstdescription{
      This function allocates space in the same way as the standard C
      calloc() function, except that the pointer to the space
      allocated is automatically registered (using
     \htmlref{\texttt{cnfRegp}}{cnfRegp})
      for use
      from both C and FORTRAN. This means that the returned pointer
      may subsequently be converted into a FORTRAN pointer of type
      F77\_POINTER\_TYPE (using
     \htmlref{\texttt{cnfFptr}}{cnfFptr})
      and back into a C pointer
      (using
     \htmlref{\texttt{cnfCptr}}{cnfCptr}).
      The contents of the space may therefore be
      accessed from both languages.
   }
   \sstinvocation{
      cpointer = cnfCalloc( nobj, size );
   }
   \sstarguments{
      \sstsubsection{
         size\_t nobj (Given)
      }{
         The number of objects for which space is required.
      }
      \sstsubsection{
         size\_t size (Given)
      }{
         The size of each object.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         void $*$cnfCalloc
      }{
         A registered pointer to the allocated space, or NULL if the
         space could not be allocated.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         As with calloc(), the allocated space is initialised to zero
         bytes.

         \sstitem
         The space should be freed using
        \htmlref{\texttt{cnfFree }}{cnfFree}
         when no longer
         required.
      }
   }
}
\sstroutine{
   cnfCopyf
}{
   Copy one FORTRAN string to another FORTRAN string
}{
   \sstdescription{
      The FORTRAN string in source\_f is copied to dest\_f.
      The destination string is filled with trailing blanks or
      truncated as necessary.
   }
   \sstinvocation{
      cnfCopyf( source\_f, source\_len, dest\_f, dest\_len )
   }
   \sstarguments{
      \sstsubsection{
         const char  $*$source\_f  (Given)
      }{
         A pointer to the input FORTRAN string
      }
      \sstsubsection{
         int  source\_len  (Given)
      }{
         The length of the input FORTRAN string
      }
      \sstsubsection{
         char  $*$dest\_f  (Returned via pointer)
      }{
         A pointer to the output FORTRAN string
      }
      \sstsubsection{
         int  dest\_len  (Given)
      }{
         The length of the output FORTRAN string
      }
   }
}
\sstroutine{
   cnfCptr
}{
   Convert a FORTRAN pointer to a C pointer
}{
   \sstdescription{
      Given a FORTRAN pointer, stored in a variable of type
      F77\_POINTER\_TYPE, this function returns the equivalent C
      pointer. Note that this conversion is only performed if the C
      pointer has originally been registered (using
     \htmlref{\texttt{cnfRegp}}{cnfRegp})
      for use
      from both C and FORTRAN. All pointers to space allocated by
     \htmlref{\texttt{cnfCalloc}}{cnfCalloc}
      and
     \htmlref{\texttt{cnfMalloc}}{cnfMalloc}
      are automatically registered in this
      way.
   }
   \sstinvocation{
      cpointer = cnfCptr( fpointer )
   }
   \sstarguments{
      \sstsubsection{
         F77\_POINTER\_TYPE fpointer (Given)
      }{
         The FORTRAN pointer value.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         void $*$cnfCptr
      }{
         The equivalent C pointer.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A NULL value will be returned if the C pointer has not
         previously been registered for use from both C and FORTRAN, or
         if the FORTRAN pointer value supplied is zero.
      }
   }
}
\sstroutine{
   cnfCreat
}{
   Create a temporary C string and return a pointer to it
}{
   \sstdescription{
      Create a temporary C string and return a pointer to it.
      The space allocated to the C string is `length' characters and is
      initialized to the null string.
   }
   \sstinvocation{
      pointer = cnfCreat( length )
   }
   \sstarguments{
      \sstsubsection{
         int length (Given)
      }{
         The length of the space to be allocated in characters.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         char $*$cnfCreat
      }{
         A pointer to the storage that has been allocated by this routine.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the argument is given as N then there is room to store N-1
            characters plus a trailing null character in a C string.

         \sstitem
         If the routine could not create the space, then it returns a
            null pointer.
      }
   }
}

\sstroutine{
   cnfCref
}{
   Create a temporary FORTRAN CHARACTER string and return a pointer to it.
}{
   \sstdescription{
      Memory is obtained for a FORTRAN CHARACTER string of the specified
      length and a pointer is returned which may be passed from C to a FORTRAN
      subroutine. The string is not initialised to blanks.
   }
   \sstinvocation{
      string\_f = cnfCref( string\_f\_len )
   }
   \sstarguments{
      \sstsubsection{
         int string\_f\_len  (Given)
      }{
         The required length of the FORTRAN string.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         F77\_CHARACTER\_ARG\_TYPE $*$cnfCref
      }{
         A pointer to the storage that has been allocated by this routine.
         Note that this is not necessarily the location of the string of
         characters.
      }
   }
   \sstnotes{
      \sstitemlist{
         \sstitem
         If the routine could not create the space, then it returns a
            null pointer.

         \sstitem
         This function will usually be called via the F77
         F77\_\-CREATE\_\-CHARACTER macro which will also provide a
         pointer to the actual string of characters.
      }
   }
}

\sstroutine{
   cnfCrefa
}{
   Create a temporary FORTRAN CHARACTER array and return a pointer to it.
}{
   \sstdescription{
      Memory is obtained for a FORTRAN CHARACTER array, of the specified
      dimensions and a pointer is returned which may be passed from C to a
      FORTRAN subroutine. The array is not initialised to blanks.
   }
   \sstinvocation{
      string\_f = cnfCrefa( string\_f\_len, ndims, dims )
   }
   \sstarguments{
      \sstsubsection{
         int string\_f\_len  (Given)
      }{
         The maximum length of the FORTRAN string elements of the array.
      }
      \sstsubsection{
         int ndims (Given)
      }{
         The number of dimensions of the FORTRAN array
      }
      \sstsubsection{
         const int $*$dims (Given)
      }{
         A 1-D array giving the dimensions of the FORTRAN array.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         F77\_CHARACTER\_ARRAY\_ARG\_TYPE $*$cnfCrefa
      }{
         A pointer to the storage that has been allocated by this routine.
         Note that this is not necessarily the location of the strings of
         characters.
      }
   }
   \sstnotes{
      \sstitemlist{
         \sstitem
         If the routine could not create the space, then it returns a
            null pointer.

         \sstitem
         This function will usually be called via the F77
         F77\_\-CREATE\_\-CHARACTER\_\-ARRAY macro which will also provide a
         pointer to the actual strings of characters.

      }
   }
}

\sstroutine{
   cnfCreib
}{
   Create a temporary C string and import a FORTRAN string into it
   including trailing blanks
}{
   \sstdescription{
      Create a temporary C string, import a FORTRAN string into it,
      retaining trailing blanks and return a pointer to this C string.
      The length of the C string that is created is just long enough to
      hold the FORTRAN string (including any trailing blanks), plus the
      null terminator.
   }
   \sstinvocation{
      pointer = cnfCreib( source\_f, source\_len )
   }
   \sstarguments{
      \sstsubsection{
         const char $*$source\_f (Given)
      }{
         A pointer to the input FORTRAN string
      }
      \sstsubsection{
         int source\_len (Given)
      }{
         The length of the input FORTRAN string
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         char $*$cnfCreib
      }{
         A pointer to the temporary storage location
      }
   }
   \sstnotes{
         If the routine could not create the space, then it returns a
            null pointer.
   }
}

\sstroutine{
   cnfCreim
}{
   Create a temporary C string and import a FORTRAN string into it
   discarding trailing blanks
}{
   \sstdescription{
      Create a temporary C string, import a FORTRAN string into it and
      return a pointer to this C string.
      Any trailing blanks in the FORTRAN string are discarded.
      The length of the C string that is created is just long enough to
      hold the FORTRAN string (less trailing blanks), plus the null
      terminator.
   }
   \sstinvocation{
      pointer = cnfCreim( source\_f, source\_len )
   }
   \sstarguments{
      \sstsubsection{
         const char $*$source\_f (Given)
      }{
         A pointer to the input FORTRAN string
      }
      \sstsubsection{
         int source\_len (Given)
      }{
         The length of the input FORTRAN string
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         char $*$cnfCreim
      }{
         A pointer to the storage space allocated by this function.
      }
   }
   \sstnotes{
      If the routine could not create the space, then it returns a null
      pointer.
   }
}

\sstroutine{
   cnfCrela
}{
   Create a temporary FORTRAN LOGICAL array and return a pointer to it.
}{
   \sstdescription{
      Memory is obtained for a FORTRAN LOGICAL array, of the specified
      dimensions and a pointer is returned which may be passed from C to a
      FORTRAN subroutine. The array is not initialised.
   }
   \sstinvocation{
      string\_f = cnfCrela( ndims, dims )
   }
   \sstarguments{
      \sstsubsection{
         int ndims (Given)
      }{
         The number of dimensions of the FORTRAN array
      }
      \sstsubsection{
         const int $*$dims (Given)
      }{
         A 1-D array giving the dimensions of the FORTRAN array.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         F77\_LOGICAL\_TYPE $*$cnfCrefa
      }{
         A pointer to the storage that has been allocated by this routine.
      }
   }
   \sstnotes{
      \sstitemlist{
         \sstitem
         If the routine could not create the space, then it returns a
            null pointer.
      }
   }
}


\sstroutine{
   cnfExpch
}{
      Export a C array of char to a FORTRAN string.
}{
   \sstdescription{
      Export a C array of char to a FORTRAN string, copying `nchars' characters.
      No characters, are special so this may be used to export an HDS locator
      which could contain a null character.
   }
   \sstinvocation{
      cnfExpch( source\_c, dest\_f, nchars )
   }
   \sstarguments{
      \sstsubsection{
         const char $*$source\_c (Given)
      }{
         A pointer to the input C string
      }
      \sstsubsection{
         char $*$dest\_f (Returned via pointer)
      }{
         A pointer to the output FORTRAN string
      }
      \sstsubsection{
         int nchars (Given)
      }{
         The number of characters to be copied from source\_c to dest\_f
      }
   }
}

\sstroutine{
   cnfExpla
}{
   Export a C int array to a FORTRAN LOGICAL array
}{
   \sstdescription{
      Export a C int array to a FORTRAN LOGICAL array setting appropriate
      TRUE or FALSE values in the FORTRAN array.
   }
   \sstinvocation{
      cnfExpla( source\_c, dest\_f, ndims, dims)
   }
   \sstarguments{
      \sstsubsection{
         const int $*$source\_c (Given)
      }{
         A pointer to the input C array
      }
      \sstsubsection{
         F77\_LOGICAL\_TYPE $*$dest\_f (Returned via pointer)
      }{
         A pointer to the FORTRAN output array
      }
      \sstsubsection{
         int ndims (Given)
      }{
         The number of dimensions in the arrays
      }
      \sstsubsection{
         const int $*$dims (Given)
      }{
         A pointer to a 1-D array giving the dimensions of the arrays
      }
   }
}

\sstroutine{
   cnfExpn
}{
   Export a C string to a FORTRAN string, copying a given maximum
   number of characters
}{
   \sstdescription{
      Export a C string to a FORTRAN string, copying a maximum of `max'
      characters. If the C string is shorter than the space allocated
      to the FORTRAN string, then pad it with blanks, even if the
      whole source string was not copied as it had more than `max'
      characters. If the C string is longer than the space allocated
      to the FORTRAN string, then truncate the string.
   }
   \sstinvocation{
      cnfExpn( source\_c, max, dest\_f, dest\_len )
   }
   \sstarguments{
      \sstsubsection{
         const char $*$source\_c (Given)
      }{
         A pointer to the input C string
      }
      \sstsubsection{
         int max (Given)
      }{
         The maximum number of character to be copied from source\_c to
         dest\_f
      }
      \sstsubsection{
         char $*$dest\_f (Returned via pointer)
      }{
         A pointer to the FORTRAN output string
      }
      \sstsubsection{
         int dest\_len (Given)
      }{
         The length of the FORTRAN output string
      }
   }
}
\sstroutine{
   cnfExprt
}{
   Export a C string to a FORTRAN string
}{
   \sstdescription{
      Export a C string to a FORTRAN string. If the C string is
      shorter than the space allocated to the FORTRAN string, then pad
      it with blanks. If the C string is longer than the space
      allocated to the FORTRAN string, then truncate the string.
   }
   \sstinvocation{
      cnfExprt( source\_c, dest\_f, dest\_len )
   }
   \sstarguments{
      \sstsubsection{
         const char $*$source\_c (Given)
      }{
         A pointer to the input C string
      }
      \sstsubsection{
         char $*$dest\_f (Returned via pointer)
      }{
         A pointer to the output FORTRAN string
      }
      \sstsubsection{
         int dest\_len (Given)
      }{
         The length of the output FORTRAN string
      }
   }
}
\sstroutine{
   cnfExprta
}{
   Export a C string array to a FORTRAN CHARACTER array
}{
   \sstdescription{
      Export a C string array to a FORTRAN CHARACTER array. A null character
      is assumed to terminate each C string -- it will not be copied.
      If the C string is shorter than the space allocated to the FORTRAN
      string, then pad it with blanks.
      No more than `dest\_len' characters will be copied for each string.
   }
   \sstinvocation{
      cnfExprta( source\_c, source\_len, dest\_f, dest\_len, ndims, dims )
   }
   \sstarguments{
      \sstsubsection{
         const char $*$source\_c (Given)
      }{
         A pointer to the input C array
      }
      \sstsubsection{
         int source\_len (Given)
      }{
         The maximum number of characters in a string of the C array
         (including terminating null if required). This would be the last
         declared dimension of a \texttt{char} array.
      }
      \sstsubsection{
         char $*$dest\_f (Returned via pointer)
      }{
         A pointer to the output FORTRAN array
      }
      \sstsubsection{
         int dest\_len (Given)
      }{
         The declared maximum number of characters in a element of the FORTRAN
         array
      }
      \sstsubsection{
         int ndims (Given)
      }{
         The number of dimensions of the FORTRAN array
      }
      \sstsubsection{
         const int $*$dims (Given)
      }{
         A pointer to a 1-D array specifying the dimensions of the FORTRAN
         array.
      }
   }
   \sstnotes{
      The C array is treated as an array of strings but it will actually
      be an array of \texttt{char} with one more dimension than the FORTRAN
      array, the last dimension being source\_len. The other dimensions must
      be as for the FORTRAN array.
   }
}
\sstroutine{
   cnfExprtap
}{
   Export a C array of pointers to char, to a FORTRAN CHARACTER array
}{
   \sstdescription{
      Export a C array of pointers to char to a FORTRAN CHARACTER array.
      A null character is assumed to terminate each C string -- it
      will not be copied.
      If the C string is shorter than the space allocated to the FORTRAN
      string, then pad it with blanks.
      No more than `dest\_len' characters will be copied for each string.
   }
   \sstinvocation{
      cnfExprtap( source\_c, dest\_f, dest\_len, ndims, dims )
   }
   \sstarguments{
      \sstsubsection{
         char $*$const $*$source\_c (Given)
      }{
         A pointer to the input C array of pointers to char
      }
      \sstsubsection{
         char $*$dest\_f
      }{
         A pointer to the output FORTRAN array
      }
      \sstsubsection{
         int dest\_len (Given)
      }{
         The declared maximum number of characters in a element of the FORTRAN
         array
      }
      \sstsubsection{
         int ndims (Given)
      }{
         The number of dimensions of the arrays
      }
      \sstsubsection{
         const int $*$dims (Given)
      }{
         A pointer to a 1-D array specifying the dimensions of the arrays.
      }
   }
   \sstnotes{
      The array of pointers to char is assumed to point to null-terminated
      strings. The dimensions of the array of pointers and the FORTRAN
      character array must be the same.

      Strictly, the input array should be declared as
      `\texttt{const char $*$const $*$source\_c}', but this would not allow
      non-constant char to be given.
   }
}
\sstroutine{
   cnfFptr
}{
   Convert a C pointer to a FORTRAN pointer
}{
   \sstdescription{
      Given a C pointer, this function returns the equivalent FORTRAN
      pointer of type F77\_POINTER\_TYPE. Note that this conversion is
      only performed if the C pointer has originally been registered
      (using
     \htmlref{\texttt{cnfRegp}}{cnfRegp})
      for use from both C and FORTRAN. All pointers
      to space allocated by
     \htmlref{\texttt{cnfCalloc}}{cnfCalloc}
      and
     \htmlref{\texttt{cnfMalloc}}{cnfMalloc}
      are
      automatically registered in this way.
   }
   \sstinvocation{
      fpointer = cnfFptr( cpointer )
   }
   \sstarguments{
      \sstsubsection{
         void $*$cpointer (Given)
      }{
         The C pointer.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         F77\_POINTER\_TYPE cnfCptr
      }{
         The equivalent FORTRAN pointer value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A value of zero will be returned if the C pointer has not
         previously been registered for use from both C and FORTRAN, or
         if a NULL pointer is supplied.
      }
   }
}
\sstroutine{
   cnfFree
}{
   Free allocated space
}{
   \sstdescription{
      Free space allocated by a call to
     \htmlref{\texttt{cnfCalloc}}{cnfCalloc},
     \htmlref{\texttt{cnfCreat}}{cnfCreat},
     \htmlref{\texttt{cnfCreib}}{cnfCreib},
     \htmlref{\texttt{cnfCreim}}{cnfCreim}
      or
     \htmlref{\texttt{cnfMalloc}}{cnfMalloc}.
   }
   \sstinvocation{
      cnfFree( pointer )
   }
   \sstarguments{
      \sstsubsection{
         void $*$pointer (Given)
      }{
         A pointer to the space to be freed.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This function is not simply equivalent to the C free()
         function, since if the pointer has been registered (using
        \htmlref{\texttt{cnfRegp}}{cnfRegp})
         for use by both C and FORTRAN, then it will be
         unregistered before the space is freed. All pointers to space
         allocated by
        \htmlref{\texttt{cnfCalloc}}{cnfCalloc}
         and
        \htmlref{\texttt{cnfMalloc}}{cnfMalloc}
         are automatically
         registered in this way, so
        \htmlref{\texttt{cnfFree}}{cnfFree}
         should always be used to
         free them.

         \sstitem
         It is also safe to free unregistered pointers with this
         function.
      }
   }
}
\sstroutine{
   cnfFreef
}{
   Free a FORTRAN string
}{
   \sstdescription{
      Return the temporary storage space which was allocated by a previous call
      to
     \htmlref{\texttt{cnfCref}}{cnfCref}
      or
     \htmlref{\texttt{cnfCrefa}}{cnfCrefa}.
   }
   \sstinvocation{
      cnfFreef( string\_f )
   }
   \sstarguments{
      \sstsubsection{
          F77\_CHARACTER\_ARG\_TYPE $*$string\_f (Given)
      }{
          A pointer (as returned by
         \htmlref{\texttt{cnfCref}}{cnfCref}
          or
         \htmlref{\texttt{cnfCrefa}}{cnfCrefa})
          to the string to be freed.
      }
   }
   \sstnotes{
      \sstitemlist{
         \sstitem
         This function will usually be called via the F77 macro
         F77\_\-FREE\_\-CHARACTER.
      }
   }
}

\sstroutine{
   cnfImpb
}{
   Import a FORTRAN string into a C string, retaining trailing blanks
}{
   \sstdescription{
      Import a FORTRAN string into a C string retaining trailing blanks.
      The null character is appended to the C string after all of the
      blanks in the input string.
   }
   \sstinvocation{
      cnfImpb( source\_f, source\_len, dest\_c )
   }
   \sstarguments{
      \sstsubsection{
         const char $*$source\_f (Given)
      }{
         A pointer to the input FORTRAN string
      }
      \sstsubsection{
         int source\_len (Given)
      }{
         The length of the input FORTRAN string
      }
      \sstsubsection{
         char $*$dest\_c (Returned via pointer)
      }{
         A pointer to the output C string
      }
   }
   \sstnotes{
         No check is made that there is sufficient space allocated to
            the C string to hold the FORTRAN string. It is the
            responsibility of the programmer to check this.
   }
}
\sstroutine{
   cnfImpbn
}{
   Import no more than max characters from a FORTRAN string into a C
   string, retaining trailing blanks
}{
   \sstdescription{
      Import a FORTRAN string into a C string, up to a maximum of `max'
      characters, retaining trailing blanks. The null character is
      appended to the C string after all of the blanks in the input
      string.
   }
   \sstinvocation{
      cnfImpbn( source\_f, source\_len, max, dest\_c )
   }
   \sstarguments{
      \sstsubsection{
         const char $*$source\_f (Given)
      }{
         A pointer to the input FORTRAN string
      }
      \sstsubsection{
         int source\_len (Given)
      }{
         The length of the input FORTRAN string
      }
      \sstsubsection{
         int max (Given)
      }{
         The maximum number of characters to be copied from the input
         FORTRAN string to the output C string
      }
      \sstsubsection{
         char $*$dest\_c (Returned via pointer)
      }{
         A pointer to the output C string
      }
   }
   \sstnotes{
         No check is made that there is sufficient space allocated to
            the C string to hold the FORTRAN string. It is the
            responsibility of the programmer to check this.
   }
}

\sstroutine{
   cnfImpch
}{
   Import a FORTRAN string into a C array of char.
}{
   \sstdescription{
      Import a FORTRAN string into a C array of char, copying `nchars'
      characters.
      No characters, are special so this may be used to import an HDS locator
      which could contain any character.
   }
   \sstinvocation{
      cnfImprt( source\_f, nchars, dest\_c )
   }
   \sstarguments{
      \sstsubsection{
         const char $*$source\_f (Given)
      }{
         A pointer to the input FORTRAN string
      }
      \sstsubsection{
         int nchars (Given)
      }{
         The number of characters to be copied from source\_f to
         dest\_c
      }
      \sstsubsection{
         char $*$dest\_c (Returned via pointer)
      }{
         A pointer to the C array of char

      }
   }
   \sstnotes{
         No check is made that there is sufficient space allocated to
         the C array to hold the FORTRAN string.
         It is the responsibility of the programmer to check this.
   }
}

\sstroutine{
   cnfImpla
}{
   Import a FORTRAN LOGICAL array into a C int array
}{
   \sstdescription{
      Import a FORTRAN LOGICAL array into a C int array setting appropriate
      TRUE or FALSE values in the C array.
   }
   \sstinvocation{
      cnfImpla( source\_f, dest\_c, ndims, dims)
   }
   \sstarguments{
      \sstsubsection{
         const F77\_LOGICAL\_TYPE $*$source\_f (Given)
      }{
         A pointer to the input FORTRAN array
      }
      \sstsubsection{
         int $*$dest\_c (Returned via pointer)
      }{
         A pointer to the output C array
      }
      \sstsubsection{
         int ndims (Given)
      }{
         The number of dimensions in the arrays
      }
      \sstsubsection{
         const int $*$dims (Given)
      }{
         A pointer to a 1-D array giving the dimensions of the arrays
      }
   }
}

\sstroutine{
   cnfImpn
}{
   Import no more than max characters from a FORTRAN string into a C
   string
}{
   \sstdescription{
      Import a FORTRAN string into a C string, up to a maximum of `max'
      characters discarding trailing blanks.  The null character is appended
      to the C string after the last non-blank character.
   }
   \sstinvocation{
      cnfImpn( source\_f, source\_len, max, dest\_c )
   }
   \sstarguments{
      \sstsubsection{
         const char $*$source\_f (Given)
      }{
         A pointer to the input FORTRAN string
      }
      \sstsubsection{
         int source\_len (Given)
      }{
         The length of the input FORTRAN string
      }
      \sstsubsection{
         int max (Given)
      }{
         The maximum number of characters to be copied from the input
         FORTRAN string to the output C string
      }
      \sstsubsection{
         char $*$dest\_c (Returned via pointer)
      }{
         A pointer to the output C string
      }
   }
   \sstnotes{
         No check is made that there is sufficient space allocated to
         the C string to hold the FORTRAN string and a terminating null.
         It is the responsibility of the programmer to check this.
   }
}
\sstroutine{
   cnfImprt
}{
   Import a FORTRAN string into a C string
}{
   \sstdescription{
      Import a FORTRAN string into a C string, discarding trailing
      blanks. The null character is appended to the C string after
      the last non-blank character.
   }
   \sstinvocation{
      cnfImprt( source\_f, source\_len, dest\_c )
   }
   \sstarguments{
      \sstsubsection{
         const char $*$source\_f (Given)
      }{
         A pointer to the input FORTRAN string
      }
      \sstsubsection{
         int source\_len (Given)
      }{
         The length of the input FORTRAN string
      }
      \sstsubsection{
         char $*$dest\_c (Returned via pointer)
      }{
         A pointer to the output C string
      }
   }
   \sstnotes{
         No check is made that there is sufficient space allocated to
         the C string to hold the FORTRAN string and a terminating null.
         It is the responsibility of the programmer to check this.
   }
}
\sstroutine{
   cnfImprta
}{
   Import a FORTRAN CHARACTER array into a C string array.
}{
   \sstdescription{
      Import a FORTRAN CHARACTER array into a C string array, discarding
      trailing blanks.
      The null character is appended to the C string after the last non-blank
      character copied from the FORTRAN string if there is room.
      No more than `dest\_len' characters will be copied for each string.
   }
   \sstinvocation{
      cnfImprta( source\_f, source\_len, dest\_c, dest\_len, ndims, dims )
   }
   \sstarguments{
      \sstsubsection{
         const char $*$source\_f (Given)
      }{
         A pointer to the input FORTRAN array
      }
      \sstsubsection{
         int source\_len (Given)
      }{
         The declared maximum number of characters in a element of the FORTRAN
         array
      }
      \sstsubsection{
         char $*$dest\_c (Returned via pointer)
      }{
         A pointer to the output C array
      }
      \sstsubsection{
         int dest\_len (Given)
      }{
         The maximum number of characters in an element of the C array
         (including terminating null if required). This would be the last
         declared dimension of a char array.
      }
      \sstsubsection{
         int ndims (Given)
      }{
         The number of dimensions of the FORTRAN array
      }
      \sstsubsection{
         const int $*$dims (Given)
      }{
         A pointer to a 1-D array giving the dimensions of the FORTRAN array.
      }
   }
   \sstnotes{
      The C array is treated as an array of strings but it will actually
      be a char array with one more dimension than the FORTRAN array, the
      last dimension being `dest\_len'. The other dimensions must be as for
      the FORTRAN array.
   }
}
\sstroutine{
   cnfImprtap
}{
   Import a FORTRAN CHARACTER array into a C array of pointers to char.
}{
   \sstdescription{
      Import a FORTRAN CHARACTER array into a C array of pointers to char,
      discarding trailing blanks.
      The pointers must each point to an area of allocated memory at least
      `dest\_len' characters long.
      The null character is appended to the C string after the last non-blank
      character copied from the FORTRAN string if there is room.
      No more than `dest\_len' characters will be copied for each string.
   }
   \sstinvocation{
      cnfImprtap( source\_f, source\_len, dest\_c, dest\_len, ndims, dims )
   }
   \sstarguments{
      \sstsubsection{
         const char $*$source\_f (Given)
      }{
         A pointer to the input FORTRAN array
      }
      \sstsubsection{
         int source\_len (Given)
      }{
         The declared maximum number of characters in a element of the FORTRAN
         array
      }
      \sstsubsection{
         char $*$const $*$dest\_c
      }{
         A pointer to the output C array
      }
      \sstsubsection{
         int dest\_len (Given)
      }{
         The maximum number of characters to be copied for each string
         (including terminating null if required).
      }
      \sstsubsection{
         int ndims (Given)
      }{
         The number of dimensions of the arrays
      }
      \sstsubsection{
         const int $*$dims (Given)
      }{
         A pointer to a 1-D array giving the dimensions of the arrays.
      }
   }
   \sstnotes{
      The array of pointers and the FORTRAN character array must have the
      same dimensions.
   }
}
\sstroutine{
   cnfLenc
}{
   Find the length of a C string
}{
   \sstdescription{
      Find the length (\textit{i.e.}\ position of the last non blank character)
      in a C string.
   }
   \sstinvocation{
      result = cnfLenc( source\_c )
   }
   \sstarguments{
      \sstsubsection{
         const char $*$source\_c (Given)
      }{
         A pointer to the input C string
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         int cnfLenc
      }{
         The length of the input C string
      }
   }
   \sstnotes{
         This routine follows the FORTRAN convention of counting
            positions from one, so with an input string of \texttt{"ABCD"} the
            value returned would be 4.
   }
}
\sstroutine{
   cnfLenf
}{
   Find the length of a FORTRAN string
}{
   \sstdescription{
      Find the length (\textit{i.e.}\ position of the last non blank character)
      in a FORTRAN string. This is not necessarily the same as the value
      of source\_len as trailing blanks are not counted.
   }
   \sstinvocation{
      result = cnfLenf( source\_f, source\_len )
   }
   \sstarguments{
      \sstsubsection{
         const char $*$source\_f (Given)
      }{
         A pointer to the input FORTRAN string
      }
      \sstsubsection{
         int source\_len (Given)
      }{
         The length (including trailing blanks) of the input FORTRAN
         string
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         int cnfLenf
      }{
         The length (excluding trailing blanks) of the input FORTRAN
         string.
      }
   }
   \sstnotes{
         This routine follows the FORTRAN convention of counting
            positions from one, so with an input string of \texttt{'ABCD'}
            the value returned would be 4.
   }
}
\sstroutine{
   cnfMalloc
}{
   Allocate space that may be accessed from C and FORTRAN
}{
   \sstdescription{
      This function allocates space in the same way as the standard C
      malloc() function, except that the pointer to the space
      allocated is automatically registered (using
     \htmlref{\texttt{cnfRegp}}{cnfRegp})
      for use
      from both C and FORTRAN. This means that the returned pointer
      may subsequently be converted into a FORTRAN pointer of type
      F77\_POINTER\_TYPE (using
     \htmlref{\texttt{cnfFptr}}{cnfFptr}),
      and back into a C pointer
      (using
     \htmlref{\texttt{cnfCptr}}{cnfCptr}).
      The contents of the space may therefore be
      accessed from both languages.
   }
   \sstinvocation{
      cpointer = cnfMalloc( size );
   }
   \sstarguments{
      \sstsubsection{
         size\_t size (Given)
      }{
         The size of the required space.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         void $*$cnfMalloc
      }{
         A registered pointer to the allocated space, or NULL if the
         space could not be allocated.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The allocated space should be freed using
        \htmlref{\texttt{cnfFree}}{cnfFree}
         when no
         longer required.
      }
   }
}
\sstroutine{
   cnfRegp
}{
   Register a pointer for use from both C and FORTRAN
}{
   \sstdescription{
      This is a low-level function which will normally only be
      required if you are implementing your own memory allocation
      facilities (all memory allocated by
     \htmlref{\texttt{cnfCalloc}}{cnfCalloc}
      and
     \htmlref{\texttt{cnfMalloc}}{cnfMalloc}
      is
      automatically registered using this function).

      The function attempts to register a C pointer so that it may be
      used from both C and FORTRAN. If successful, registration
      subsequently allows the pointer to be converted into a FORTRAN
      pointer of type F77\_POINTER\_TYPE (using
     \htmlref{\texttt{cnfFptr}}{cnfFptr}), and then back
      into a C pointer (using
     \htmlref{\texttt{cnfCptr}}{cnfCptr}).
      These conversions are
      possible even if the FORTRAN pointer is stored in a shorter data
      type than the C pointer.

      Not all C pointers may be registered, and registration may fail
      if the FORTRAN version of the pointer is indistinguishable from
      that of a pointer which has already been registered. In such a
      case, a new C pointer must be obtained (e.g. by allocating a
      different region of memory).
   }
   \sstinvocation{
      result = cnfRegp( cpointer )
   }
   \sstarguments{
      \sstsubsection{
         void $*$cpointer (Given)
      }{
         The C pointer to be registered.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         int cnfRegp
      }{
         If registration was successful, the function returns 1. If
         registration was unsuccessful, it returns zero.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If an internal error occurs (e.g. if insufficient memory is
         available), the function returns -1.
      }
   }
}
\sstroutine{
   cnfUregp
}{
   Unregister a pointer previously registered using
  \htmlref{\texttt{cnfRegp}}{cnfRegp}
}{
   \sstdescription{
      This is a low-level function which will normally only be
      required if you are implementing your own memory allocation
      facilities.

      The function accepts a C pointer which has previously been
      registered for use from both C and FORTRAN (using
     \htmlref{\texttt{cnfRegp}}{cnfRegp})
      and
      removes its registration. Subsequently, conversion between the C
      pointer and its FORTRAN equivalent (and vice versa) will no
      longer be performed by
     \htmlref{\texttt{cnfFptr}}{cnfFptr}
      and
     \htmlref{\texttt{cnfCptr}}{cnfCptr}.
   }
   \sstinvocation{
      cnfUregp( cpointer )
   }
   \sstarguments{
      \sstsubsection{
         void $*$cpointer (Given)
      }{
         The C pointer to be unregistered.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         No action occurs (and no error results) if the C pointer has
         not previously been registered for use from both C and FORTRAN.
      }
   }
}

\newpage
\section{\xlabel{cnf_fortran_function_description}CNF FORTRAN Function Description}
\sstroutine{
   CNF\_PVAL
}{
   Expand a FORTRAN pointer to its full value
}{
   \sstdescription{
      Given a FORTRAN pointer, stored in an INTEGER variable, this
      function returns the full value of the pointer (on some
      platforms, this may be longer than an INTEGER). Typically, this
      is only required when the pointer is used to pass dynamically
      allocated memory to another routine using the \texttt{\%VAL} facility.
   }
   \sstinvocation{
      CALL DOIT( ..., \%VAL( CNF\_PVAL( FPTR ) ), ... )
   }
   \sstarguments{
      \sstsubsection{
         FPTR = INTEGER (Given)
      }{
         The FORTRAN pointer value.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         CNF\_PVAL
      }{
         The full pointer value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The data type of this function will depend on the platform in
         use and is declared in the include file CNF\_PAR.
      }
   }
}
\rule{\textwidth}{0.5mm}
\sstroutine{
   CNF\_CVAL
}{
   Convert a Fortran INTEGER into the same type as used in the TRAIL macro.
}{
   \sstdescription{
      When passing dynamically allocated character strings to Fortran
      or C routines the character string length is passed as a hidden
      argument after the visible ones (see \htmlref{TRAIL}{TRAIL}). With some
      compilers this
      length is a 64bit long (INTEGER*8), whereas for others it is more
      typically a 32bit int (INTEGER*4). Using this function avoids the need
      to know which size is used for the configured compiler.
   }
   \sstinvocation{
      CALL DOIT( \%VAL( CNF\_PVAL( FPTR ) ),..., \%VAL( CNF\_CVAL( FINT ) ) )
   }
   \sstarguments{
      \sstsubsection{
         FINT = INTEGER (Given)
      }{
         The FORTRAN integer value giving the expected length of the strings.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         CNF\_CVAL
      }{
         The string length in the correct type for the configured compiler.
         Fortran equivalent of the type used by the TRAIL macro.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The data type of this function will depend on the platform in
         use and is declared in the include file CNF\_PAR.

         \sstitem
         When mixing calls that pass locally declared character strings
         and dynamically allocated ones, all the declared strings
         must preceed all the dynamic ones in the argument list so that
         the order of the TRAIL arguments is known.

      }
   }
}
\rule{\textwidth}{0.5mm}

\section{\xlabel{references}References}
\nocite{fortran:std}
\nocite{c:std}
\nocite{Banahan}
\begin{thebibliography}{9}

\bibitem{fortran:std}
American National Standard -- Programming Language
-- FORTRAN (ANSI X3.9-1978, ISO 1539-1980(E)). Publ, American National
Standards Institute.

\bibitem{c:std}
American National Standard for Information Systems --
Programming Language -- C (ANSI X3.159-1989). Publ, American National
Standards Institute.

%\bibitem{psx:std}IEEE Standard Portable Operating System Interface for Computer
%Environments (IEEE Std 1003.1-1988). Publ, Institute of Electrical and
%Electronic Engineers, Inc.

\bibitem{Banahan}
Banahan, M.F., 1988. The C Book: featuring the draft ANSI C
standard. Publ, Addison-Wesley.

\end{thebibliography}

\end{document}
